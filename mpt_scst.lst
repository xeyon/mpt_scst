
mpt_scst.o：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <mpt_is_tgt_enabled>:
out:
	return res;
}

static bool mpt_is_tgt_enabled(struct scst_tgt *scst_tgt)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	e8 fc ff ff ff       	call   4 <mpt_is_tgt_enabled+0x4>

out:
	return res;
}

static bool mpt_is_tgt_enabled(struct scst_tgt *scst_tgt)
       8:	8b 40 34             	mov    0x34(%eax),%eax
{
	struct mpt_tgt *tgt = scst_tgt_get_tgt_priv(scst_tgt);

	if (tgt == NULL)
       b:	85 c0                	test   %eax,%eax
       d:	74 11                	je     20 <mpt_is_tgt_enabled+0x20>
		return false;

	return (tgt->target_enable == 0)? false : true;
       f:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
}
      15:	5d                   	pop    %ebp
	struct mpt_tgt *tgt = scst_tgt_get_tgt_priv(scst_tgt);

	if (tgt == NULL)
		return false;

	return (tgt->target_enable == 0)? false : true;
      16:	85 c0                	test   %eax,%eax
      18:	0f 95 c0             	setne  %al
}
      1b:	c3                   	ret    
      1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static bool mpt_is_tgt_enabled(struct scst_tgt *scst_tgt)
{
	struct mpt_tgt *tgt = scst_tgt_get_tgt_priv(scst_tgt);

	if (tgt == NULL)
		return false;
      20:	31 c0                	xor    %eax,%eax

	return (tgt->target_enable == 0)? false : true;
}
      22:	5d                   	pop    %ebp
      23:	c3                   	ret    
      24:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
      2a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000030 <mpt_target_release>:
 * should return 0 to indicate successful release or a negative value if
 * there are some issues with the release. In the current version of SCST
 * the return value is ignored. Must be defined.
 */
static int mpt_target_release(struct scst_tgt *scst_tgt)
{
      30:	55                   	push   %ebp
      31:	89 e5                	mov    %esp,%ebp
      33:	e8 fc ff ff ff       	call   34 <mpt_target_release+0x4>
	/* FIXME */
	return 0;
}
      38:	31 c0                	xor    %eax,%eax
      3a:	5d                   	pop    %ebp
      3b:	c3                   	ret    
      3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000040 <stm_event_process>:
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *rep)
{
      40:	55                   	push   %ebp
      41:	89 e5                	mov    %esp,%ebp
      43:	57                   	push   %edi
      44:	56                   	push   %esi
      45:	53                   	push   %ebx
      46:	83 ec 18             	sub    $0x18,%esp
      49:	e8 fc ff ff ff       	call   4a <stm_event_process+0xa>
      4e:	89 c3                	mov    %eax,%ebx
	MPT_STM_PRIV		*priv = mpt_stm_priv[ioc->id];
      50:	8b 00                	mov    (%eax),%eax
      52:	8b 34 85 20 00 00 00 	mov    0x20(,%eax,4),%esi
	int				ioc_status;
	int				event;
	int				rate;

	TRACE_ENTRY();
	if (priv == NULL)
      59:	85 f6                	test   %esi,%esi
      5b:	74 43                	je     a0 <stm_event_process+0x60>
		return 1;

	ioc_status = le16_to_cpu(rep->IOCStatus);
	event = le32_to_cpu(rep->Event);

	if (ioc_status & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {
      5d:	66 83 7a 0e 00       	cmpw   $0x0,0xe(%edx)
	TRACE_ENTRY();
	if (priv == NULL)
		return 1;

	ioc_status = le16_to_cpu(rep->IOCStatus);
	event = le32_to_cpu(rep->Event);
      62:	8b 7a 14             	mov    0x14(%edx),%edi

	if (ioc_status & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {
      65:	0f 88 ea 01 00 00    	js     255 <stm_event_process+0x215>
		printk(KERN_DEBUG "%s Event = %x, IOCLogInfo = %08x\n",
		       ioc->name, event, le32_to_cpu(rep->IOCLogInfo));
	}

	switch (event) {
      6b:	83 ff 13             	cmp    $0x13,%edi
      6e:	0f 87 74 01 00 00    	ja     1e8 <stm_event_process+0x1a8>
      74:	ff 24 bd 00 00 00 00 	jmp    *0x0(,%edi,4)
      7b:	90                   	nop
      7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		id = le32_to_cpu(logout_data->NPortID);
		break;

	case MPI_EVENT_LOOP_STATE_CHANGE:
		loop_state_data = (EventDataLoopState_t *)rep->Data;
		if (loop_state_data->Type == MPI_EVENT_LOOP_STATE_CHANGE_LIP) {
      80:	80 7a 1e 01          	cmpb   $0x1,0x1e(%edx)
      84:	75 2a                	jne    b0 <stm_event_process+0x70>
			printk(KERN_DEBUG "%s LIP Reset\n", ioc->name);
      86:	83 c3 08             	add    $0x8,%ebx
      89:	89 5c 24 04          	mov    %ebx,0x4(%esp)
      8d:	c7 04 24 65 00 00 00 	movl   $0x65,(%esp)
      94:	e8 fc ff ff ff       	call   95 <stm_event_process+0x55>
      99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#endif
	}
	TRACE_EXIT();

	return 1;
}
      a0:	83 c4 18             	add    $0x18,%esp
      a3:	b8 01 00 00 00       	mov    $0x1,%eax
      a8:	5b                   	pop    %ebx
      a9:	5e                   	pop    %esi
      aa:	5f                   	pop    %edi
      ab:	5d                   	pop    %ebp
      ac:	c3                   	ret    
      ad:	8d 76 00             	lea    0x0(%esi),%esi
		} /* fall-through */

	case MPI_EVENT_SAS_PHY_LINK_STATUS:
		sas_phy_link_status_data = (EventDataSasPhyLinkStatus_t *)rep->Data;
		rate = (sas_phy_link_status_data->LinkRates &
			MPI_EVENT_SAS_PLS_LR_CURRENT_MASK) >>
      b0:	0f b6 42 1d          	movzbl 0x1d(%edx),%eax
			MPI_EVENT_SAS_PLS_LR_CURRENT_SHIFT;
		printk(KERN_DEBUG "%s Phy %d Handle %x is now %s\n",
      b4:	b9 11 00 00 00       	mov    $0x11,%ecx
		} /* fall-through */

	case MPI_EVENT_SAS_PHY_LINK_STATUS:
		sas_phy_link_status_data = (EventDataSasPhyLinkStatus_t *)rep->Data;
		rate = (sas_phy_link_status_data->LinkRates &
			MPI_EVENT_SAS_PLS_LR_CURRENT_MASK) >>
      b9:	c0 e8 04             	shr    $0x4,%al
			break;
		} /* fall-through */

	case MPI_EVENT_SAS_PHY_LINK_STATUS:
		sas_phy_link_status_data = (EventDataSasPhyLinkStatus_t *)rep->Data;
		rate = (sas_phy_link_status_data->LinkRates &
      bc:	0f b6 c0             	movzbl %al,%eax
			MPI_EVENT_SAS_PLS_LR_CURRENT_MASK) >>
			MPI_EVENT_SAS_PLS_LR_CURRENT_SHIFT;
		printk(KERN_DEBUG "%s Phy %d Handle %x is now %s\n",
      bf:	85 c0                	test   %eax,%eax
      c1:	74 24                	je     e7 <stm_event_process+0xa7>
		       ioc->name, sas_phy_link_status_data->PhyNum,
		       le16_to_cpu(sas_phy_link_status_data->DevHandle),
		       rate == MPI_EVENT_SAS_PLS_LR_RATE_UNKNOWN ? "offline" :
		       rate == MPI_EVENT_SAS_PLS_LR_RATE_PHY_DISABLED ? "disabled" :
      c3:	83 f8 01             	cmp    $0x1,%eax
      c6:	b9 08 00 00 00       	mov    $0x8,%ecx
      cb:	74 1a                	je     e7 <stm_event_process+0xa7>
		       rate == MPI_EVENT_SAS_PLS_LR_RATE_1_5 ? "online at 1.5 Gb" :
      cd:	83 f8 08             	cmp    $0x8,%eax
      d0:	b9 19 00 00 00       	mov    $0x19,%ecx
      d5:	74 10                	je     e7 <stm_event_process+0xa7>
		       rate == MPI_EVENT_SAS_PLS_LR_RATE_3_0 ? "online at 3.0 Gb" :
      d7:	83 f8 09             	cmp    $0x9,%eax
      da:	b9 32 00 00 00       	mov    $0x32,%ecx
      df:	b8 2a 00 00 00       	mov    $0x2a,%eax
      e4:	0f 45 c8             	cmovne %eax,%ecx
	case MPI_EVENT_SAS_PHY_LINK_STATUS:
		sas_phy_link_status_data = (EventDataSasPhyLinkStatus_t *)rep->Data;
		rate = (sas_phy_link_status_data->LinkRates &
			MPI_EVENT_SAS_PLS_LR_CURRENT_MASK) >>
			MPI_EVENT_SAS_PLS_LR_CURRENT_SHIFT;
		printk(KERN_DEBUG "%s Phy %d Handle %x is now %s\n",
      e7:	89 4c 24 10          	mov    %ecx,0x10(%esp)
      eb:	0f b7 42 1e          	movzwl 0x1e(%edx),%eax
		       ioc->name, sas_phy_link_status_data->PhyNum,
      ef:	83 c3 08             	add    $0x8,%ebx
	case MPI_EVENT_SAS_PHY_LINK_STATUS:
		sas_phy_link_status_data = (EventDataSasPhyLinkStatus_t *)rep->Data;
		rate = (sas_phy_link_status_data->LinkRates &
			MPI_EVENT_SAS_PLS_LR_CURRENT_MASK) >>
			MPI_EVENT_SAS_PLS_LR_CURRENT_SHIFT;
		printk(KERN_DEBUG "%s Phy %d Handle %x is now %s\n",
      f2:	89 44 24 0c          	mov    %eax,0xc(%esp)
      f6:	0f b6 42 1c          	movzbl 0x1c(%edx),%eax
		       ioc->name, sas_phy_link_status_data->PhyNum,
      fa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
	case MPI_EVENT_SAS_PHY_LINK_STATUS:
		sas_phy_link_status_data = (EventDataSasPhyLinkStatus_t *)rep->Data;
		rate = (sas_phy_link_status_data->LinkRates &
			MPI_EVENT_SAS_PLS_LR_CURRENT_MASK) >>
			MPI_EVENT_SAS_PLS_LR_CURRENT_SHIFT;
		printk(KERN_DEBUG "%s Phy %d Handle %x is now %s\n",
      fe:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
     105:	89 44 24 08          	mov    %eax,0x8(%esp)
     109:	e8 fc ff ff ff       	call   10a <stm_event_process+0xca>
#endif
	}
	TRACE_EXIT();

	return 1;
}
     10e:	83 c4 18             	add    $0x18,%esp
     111:	b8 01 00 00 00       	mov    $0x1,%eax
     116:	5b                   	pop    %ebx
     117:	5e                   	pop    %esi
     118:	5f                   	pop    %edi
     119:	5d                   	pop    %ebp
     11a:	c3                   	ret    
     11b:	90                   	nop
     11c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		printk(KERN_DEBUG "%s Rescan\n", ioc->name);
		break;

	case MPI_EVENT_IOC_BUS_RESET:
		scsi_data = (EventDataScsi_t *)rep->Data;
		printk(KERN_DEBUG "%s IOC Bus Reset on port %d\n",
     120:	0f b6 42 1d          	movzbl 0x1d(%edx),%eax
		       ioc->name, scsi_data->BusPort);
     124:	83 c3 08             	add    $0x8,%ebx
     127:	89 5c 24 04          	mov    %ebx,0x4(%esp)
		printk(KERN_DEBUG "%s Rescan\n", ioc->name);
		break;

	case MPI_EVENT_IOC_BUS_RESET:
		scsi_data = (EventDataScsi_t *)rep->Data;
		printk(KERN_DEBUG "%s IOC Bus Reset on port %d\n",
     12b:	c7 04 24 24 00 00 00 	movl   $0x24,(%esp)
     132:	89 44 24 08          	mov    %eax,0x8(%esp)
     136:	e8 fc ff ff ff       	call   137 <stm_event_process+0xf7>
#endif
	}
	TRACE_EXIT();

	return 1;
}
     13b:	83 c4 18             	add    $0x18,%esp
     13e:	b8 01 00 00 00       	mov    $0x1,%eax
     143:	5b                   	pop    %ebx
     144:	5e                   	pop    %esi
     145:	5f                   	pop    %edi
     146:	5d                   	pop    %ebp
     147:	c3                   	ret    
		       ioc->name, scsi_data->BusPort);
		break;

	case MPI_EVENT_EXT_BUS_RESET:
		scsi_data = (EventDataScsi_t *)rep->Data;
		printk(KERN_DEBUG "%s Ext Bus Reset on port %d\n",
     148:	0f b6 42 1d          	movzbl 0x1d(%edx),%eax
		       ioc->name, scsi_data->BusPort);
     14c:	83 c3 08             	add    $0x8,%ebx
     14f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
		       ioc->name, scsi_data->BusPort);
		break;

	case MPI_EVENT_EXT_BUS_RESET:
		scsi_data = (EventDataScsi_t *)rep->Data;
		printk(KERN_DEBUG "%s Ext Bus Reset on port %d\n",
     153:	c7 04 24 44 00 00 00 	movl   $0x44,(%esp)
     15a:	89 44 24 08          	mov    %eax,0x8(%esp)
     15e:	e8 fc ff ff ff       	call   15f <stm_event_process+0x11f>
		       ioc->name, scsi_data->BusPort);
		/*
		 * clear any pending sense flags on bus reset
		 */
		if (IsScsi(priv)) {
     163:	8b 06                	mov    (%esi),%eax
     165:	80 b8 69 03 00 00 01 	cmpb   $0x1,0x369(%eax)
     16c:	0f 85 2e ff ff ff    	jne    a0 <stm_event_process+0x60>
     172:	31 c0                	xor    %eax,%eax
     174:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 *
 * Atomically sets the value of @v to @i.
 */
static inline void atomic_set(atomic_t *v, int i)
{
	v->counter = i;
     178:	c7 84 86 10 0e 00 00 	movl   $0x0,0xe10(%esi,%eax,4)
     17f:	00 00 00 00 
			for (i = 0; i < NUM_SCSI_DEVICES; i++) {
     183:	83 c0 01             	add    $0x1,%eax
     186:	83 f8 10             	cmp    $0x10,%eax
     189:	75 ed                	jne    178 <stm_event_process+0x138>
     18b:	e9 10 ff ff ff       	jmp    a0 <stm_event_process+0x60>
	case MPI_EVENT_PERSISTENT_TABLE_FULL:
	case MPI_EVENT_SAS_DISCOVERY_ERROR:
		break;

	case MPI_EVENT_RESCAN:
		printk(KERN_DEBUG "%s Rescan\n", ioc->name);
     190:	83 c3 08             	add    $0x8,%ebx
     193:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     197:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
     19e:	e8 fc ff ff ff       	call   19f <stm_event_process+0x15f>
#endif
	}
	TRACE_EXIT();

	return 1;
}
     1a3:	83 c4 18             	add    $0x18,%esp
     1a6:	b8 01 00 00 00       	mov    $0x1,%eax
     1ab:	5b                   	pop    %ebx
     1ac:	5e                   	pop    %esi
     1ad:	5f                   	pop    %edi
     1ae:	5d                   	pop    %ebp
     1af:	c3                   	ret    
		}
		break;

	case MPI_EVENT_LINK_STATUS_CHANGE:
		link_status_data = (EventDataLinkStatus_t *)rep->Data;
		printk(KERN_DEBUG "%s Link is now %s\n",
     1b0:	80 7a 1c 00          	cmpb   $0x0,0x1c(%edx)
     1b4:	b8 00 00 00 00       	mov    $0x0,%eax
     1b9:	ba 03 00 00 00       	mov    $0x3,%edx
     1be:	c7 04 24 50 00 00 00 	movl   $0x50,(%esp)
     1c5:	0f 44 c2             	cmove  %edx,%eax
		       ioc->name, link_status_data->State ? "Up" : "Down");
     1c8:	83 c3 08             	add    $0x8,%ebx
     1cb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
		}
		break;

	case MPI_EVENT_LINK_STATUS_CHANGE:
		link_status_data = (EventDataLinkStatus_t *)rep->Data;
		printk(KERN_DEBUG "%s Link is now %s\n",
     1cf:	89 44 24 08          	mov    %eax,0x8(%esp)
     1d3:	e8 fc ff ff ff       	call   1d4 <stm_event_process+0x194>
#endif
	}
	TRACE_EXIT();

	return 1;
}
     1d8:	83 c4 18             	add    $0x18,%esp
     1db:	b8 01 00 00 00       	mov    $0x1,%eax
     1e0:	5b                   	pop    %ebx
     1e1:	5e                   	pop    %esi
     1e2:	5f                   	pop    %edi
     1e3:	5d                   	pop    %ebp
     1e4:	c3                   	ret    
     1e5:	8d 76 00             	lea    0x0(%esi),%esi
		       rate == MPI_EVENT_SAS_PLS_LR_RATE_3_0 ? "online at 3.0 Gb" :
		       "unknown");
		break;

	default:
		printk(KERN_DEBUG "%s event = %d, ack = %d, length = %d\n",
     1e8:	0f b7 02             	movzwl (%edx),%eax
		       ioc->name, le32_to_cpu(rep->Event),
     1eb:	83 c3 08             	add    $0x8,%ebx
		       rate == MPI_EVENT_SAS_PLS_LR_RATE_3_0 ? "online at 3.0 Gb" :
		       "unknown");
		break;

	default:
		printk(KERN_DEBUG "%s event = %d, ack = %d, length = %d\n",
     1ee:	89 55 f0             	mov    %edx,-0x10(%ebp)
     1f1:	89 44 24 10          	mov    %eax,0x10(%esp)
     1f5:	0f b6 42 06          	movzbl 0x6(%edx),%eax
     1f9:	89 44 24 0c          	mov    %eax,0xc(%esp)
     1fd:	8b 42 14             	mov    0x14(%edx),%eax
     200:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     204:	c7 04 24 88 00 00 00 	movl   $0x88,(%esp)
     20b:	89 44 24 08          	mov    %eax,0x8(%esp)
     20f:	e8 fc ff ff ff       	call   210 <stm_event_process+0x1d0>
		       ioc->name, le32_to_cpu(rep->Event),
		       rep->AckRequired, le16_to_cpu(rep->EventDataLength));
		for (i = 0; i < le16_to_cpu(rep->EventDataLength); i++) {
     214:	8b 55 f0             	mov    -0x10(%ebp),%edx
     217:	66 83 3a 00          	cmpw   $0x0,(%edx)
     21b:	0f 84 7f fe ff ff    	je     a0 <stm_event_process+0x60>
     221:	31 f6                	xor    %esi,%esi
			printk(KERN_DEBUG "%s data[%d] = %08x\n",
     223:	8b 44 b2 1c          	mov    0x1c(%edx,%esi,4),%eax
     227:	89 74 24 08          	mov    %esi,0x8(%esp)

	default:
		printk(KERN_DEBUG "%s event = %d, ack = %d, length = %d\n",
		       ioc->name, le32_to_cpu(rep->Event),
		       rep->AckRequired, le16_to_cpu(rep->EventDataLength));
		for (i = 0; i < le16_to_cpu(rep->EventDataLength); i++) {
     22b:	83 c6 01             	add    $0x1,%esi
			printk(KERN_DEBUG "%s data[%d] = %08x\n",
     22e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     232:	c7 04 24 75 00 00 00 	movl   $0x75,(%esp)
     239:	89 44 24 0c          	mov    %eax,0xc(%esp)
     23d:	89 55 f0             	mov    %edx,-0x10(%ebp)
     240:	e8 fc ff ff ff       	call   241 <stm_event_process+0x201>

	default:
		printk(KERN_DEBUG "%s event = %d, ack = %d, length = %d\n",
		       ioc->name, le32_to_cpu(rep->Event),
		       rep->AckRequired, le16_to_cpu(rep->EventDataLength));
		for (i = 0; i < le16_to_cpu(rep->EventDataLength); i++) {
     245:	8b 55 f0             	mov    -0x10(%ebp),%edx
     248:	0f b7 02             	movzwl (%edx),%eax
     24b:	39 f0                	cmp    %esi,%eax
     24d:	0f 8e 4d fe ff ff    	jle    a0 <stm_event_process+0x60>
     253:	eb ce                	jmp    223 <stm_event_process+0x1e3>

	ioc_status = le16_to_cpu(rep->IOCStatus);
	event = le32_to_cpu(rep->Event);

	if (ioc_status & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {
		printk(KERN_DEBUG "%s Event = %x, IOCLogInfo = %08x\n",
     255:	8b 42 10             	mov    0x10(%edx),%eax
     258:	89 7c 24 08          	mov    %edi,0x8(%esp)
     25c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     263:	89 55 f0             	mov    %edx,-0x10(%ebp)
     266:	89 44 24 0c          	mov    %eax,0xc(%esp)
		       ioc->name, event, le32_to_cpu(rep->IOCLogInfo));
     26a:	8d 43 08             	lea    0x8(%ebx),%eax
     26d:	89 44 24 04          	mov    %eax,0x4(%esp)

	ioc_status = le16_to_cpu(rep->IOCStatus);
	event = le32_to_cpu(rep->Event);

	if (ioc_status & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {
		printk(KERN_DEBUG "%s Event = %x, IOCLogInfo = %08x\n",
     271:	e8 fc ff ff ff       	call   272 <stm_event_process+0x232>
     276:	8b 55 f0             	mov    -0x10(%ebp),%edx
     279:	e9 ed fd ff ff       	jmp    6b <stm_event_process+0x2b>
     27e:	66 90                	xchg   %ax,%ax

00000280 <mpt_on_free_cmd>:
 * called to notify the driver that the command is about to be freed.
 * Necessary, because for aborted commands <bf/xmit_response()/ could not be
 * called. Could be used on IRQ context. Must be defined.
 */
static void mpt_on_free_cmd(struct scst_cmd *scst_cmd)
{
     280:	55                   	push   %ebp
     281:	89 e5                	mov    %esp,%ebp
     283:	57                   	push   %edi
     284:	53                   	push   %ebx
     285:	e8 fc ff ff ff       	call   286 <mpt_on_free_cmd+0x6>
	TRACE_DBG("cmd %p, scst_cmd %p", cmd, scst_cmd);

	scst_cmd_set_tgt_priv(scst_cmd, NULL);

#if 1
	memset(cmd, 0, sizeof(*cmd));
     28a:	bb 28 00 00 00       	mov    $0x28,%ebx
 * this function
 * called to notify the driver that the command is about to be freed.
 * Necessary, because for aborted commands <bf/xmit_response()/ could not be
 * called. Could be used on IRQ context. Must be defined.
 */
static void mpt_on_free_cmd(struct scst_cmd *scst_cmd)
     28f:	8b 90 44 01 00 00    	mov    0x144(%eax),%edx
	return cmd->tgt_i_priv;
}

static inline void scst_cmd_set_tgt_priv(struct scst_cmd *cmd, void *val)
{
	cmd->tgt_i_priv = val;
     295:	c7 80 44 01 00 00 00 	movl   $0x0,0x144(%eax)
     29c:	00 00 00 
	TRACE_DBG("cmd %p, scst_cmd %p", cmd, scst_cmd);

	scst_cmd_set_tgt_priv(scst_cmd, NULL);

#if 1
	memset(cmd, 0, sizeof(*cmd));
     29f:	f6 c2 01             	test   $0x1,%dl
     2a2:	89 d7                	mov    %edx,%edi
     2a4:	75 32                	jne    2d8 <mpt_on_free_cmd+0x58>
     2a6:	f7 c7 02 00 00 00    	test   $0x2,%edi
     2ac:	75 3a                	jne    2e8 <mpt_on_free_cmd+0x68>
     2ae:	89 d9                	mov    %ebx,%ecx
     2b0:	31 c0                	xor    %eax,%eax
     2b2:	c1 e9 02             	shr    $0x2,%ecx
     2b5:	f6 c3 02             	test   $0x2,%bl
     2b8:	f3 ab                	rep stos %eax,%es:(%edi)
     2ba:	74 09                	je     2c5 <mpt_on_free_cmd+0x45>
     2bc:	31 c0                	xor    %eax,%eax
     2be:	83 c7 02             	add    $0x2,%edi
     2c1:	66 89 47 fe          	mov    %ax,-0x2(%edi)
     2c5:	83 e3 01             	and    $0x1,%ebx
     2c8:	74 03                	je     2cd <mpt_on_free_cmd+0x4d>
     2ca:	c6 07 00             	movb   $0x0,(%edi)
#endif
	kfree(cmd);

	TRACE_EXIT();
}
     2cd:	5b                   	pop    %ebx
	scst_cmd_set_tgt_priv(scst_cmd, NULL);

#if 1
	memset(cmd, 0, sizeof(*cmd));
#endif
	kfree(cmd);
     2ce:	89 d0                	mov    %edx,%eax

	TRACE_EXIT();
}
     2d0:	5f                   	pop    %edi
     2d1:	5d                   	pop    %ebp
	scst_cmd_set_tgt_priv(scst_cmd, NULL);

#if 1
	memset(cmd, 0, sizeof(*cmd));
#endif
	kfree(cmd);
     2d2:	e9 fc ff ff ff       	jmp    2d3 <mpt_on_free_cmd+0x53>
     2d7:	90                   	nop
	TRACE_DBG("cmd %p, scst_cmd %p", cmd, scst_cmd);

	scst_cmd_set_tgt_priv(scst_cmd, NULL);

#if 1
	memset(cmd, 0, sizeof(*cmd));
     2d8:	8d 7a 01             	lea    0x1(%edx),%edi
     2db:	b3 27                	mov    $0x27,%bl
     2dd:	f7 c7 02 00 00 00    	test   $0x2,%edi
     2e3:	c6 02 00             	movb   $0x0,(%edx)
     2e6:	74 c6                	je     2ae <mpt_on_free_cmd+0x2e>
     2e8:	31 c9                	xor    %ecx,%ecx
     2ea:	83 c7 02             	add    $0x2,%edi
     2ed:	66 89 4f fe          	mov    %cx,-0x2(%edi)
     2f1:	83 eb 02             	sub    $0x2,%ebx
     2f4:	eb b8                	jmp    2ae <mpt_on_free_cmd+0x2e>
     2f6:	8d 76 00             	lea    0x0(%esi),%esi
     2f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000300 <mpt_target_detect>:
 * scst_register_target(). The function should return a value >= 0 to signify
 * the number of detected target adapters. A negative value should be
 * returned whenever there is an error.
 */
static int mpt_target_detect(struct scst_tgt_template *templ)
{
     300:	55                   	push   %ebp
     301:	89 e5                	mov    %esp,%ebp
     303:	83 ec 04             	sub    $0x4,%esp
     306:	e8 fc ff ff ff       	call   307 <mpt_target_detect+0x7>
	static char function_name[sizeof(__func__)];
	int i;

	TRACE_ENTRY();

	if (function_name[0] == '\0')
     30b:	80 3d 00 00 00 00 00 	cmpb   $0x0,0x0
     312:	74 74                	je     388 <mpt_target_detect+0x88>
 * scst_register_target(). The function should return a value >= 0 to signify
 * the number of detected target adapters. A negative value should be
 * returned whenever there is an error.
 */
static int mpt_target_detect(struct scst_tgt_template *templ)
{
     314:	31 c0                	xor    %eax,%eax
     316:	66 90                	xchg   %ax,%ax

	if (function_name[0] == '\0')
		strcpy(function_name, __func__);

	for (i = 0; i < MPT_MAX_ADAPTERS; i++)
		mpt_stm_priv[i] = NULL;
     318:	c7 04 85 20 00 00 00 	movl   $0x0,0x20(,%eax,4)
     31f:	00 00 00 00 
	TRACE_ENTRY();

	if (function_name[0] == '\0')
		strcpy(function_name, __func__);

	for (i = 0; i < MPT_MAX_ADAPTERS; i++)
     323:	83 c0 01             	add    $0x1,%eax
     326:	83 f8 12             	cmp    $0x12,%eax
     329:	75 ed                	jne    318 <mpt_target_detect+0x18>
	 * Device missing delay error handling" (commit ID
	 * 213aaca3e5727f3eb56002b04a1405db34a54ed8).
	 */
	stm_context = mpt_register(stm_reply, MPTSTM_DRIVER);
#else
	stm_context = mpt_register(stm_reply, MPTSTM_DRIVER, function_name);
     32b:	b9 00 00 00 00       	mov    $0x0,%ecx
     330:	ba 06 00 00 00       	mov    $0x6,%edx
     335:	b8 f0 46 00 00       	mov    $0x46f0,%eax
     33a:	e8 fc ff ff ff       	call   33b <mpt_target_detect+0x3b>
		printk(KERN_ERR MYNAM
		       ": failed to register with MPT driver core\n");
		return -EBUSY;
	}

	if (mpt_event_register(stm_context, stm_event_process)) {
     33f:	ba 40 00 00 00       	mov    $0x40,%edx
	 * Device missing delay error handling" (commit ID
	 * 213aaca3e5727f3eb56002b04a1405db34a54ed8).
	 */
	stm_context = mpt_register(stm_reply, MPTSTM_DRIVER);
#else
	stm_context = mpt_register(stm_reply, MPTSTM_DRIVER, function_name);
     344:	0f b6 c0             	movzbl %al,%eax
     347:	a3 14 00 00 00       	mov    %eax,0x14
		printk(KERN_ERR MYNAM
		       ": failed to register with MPT driver core\n");
		return -EBUSY;
	}

	if (mpt_event_register(stm_context, stm_event_process)) {
     34c:	e8 fc ff ff ff       	call   34d <mpt_target_detect+0x4d>
     351:	85 c0                	test   %eax,%eax
     353:	75 68                	jne    3bd <mpt_target_detect+0xbd>
		printk(KERN_WARNING MYNAM
		       ": failed to register for event notification\n");
	}

	if (mpt_reset_register(stm_context, stm_reset_process)) {
     355:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
     35c:	ba 60 5f 00 00       	mov    $0x5f60,%edx
     361:	e8 fc ff ff ff       	call   362 <mpt_target_detect+0x62>
     366:	85 c0                	test   %eax,%eax
     368:	75 45                	jne    3af <mpt_target_detect+0xaf>
	TRACE_ENTRY();
	ret = _mpt_stm_init();
	if (ret != 0)
		goto out;

	if (mpt_device_driver_register(&mptstm_driver, MPTSTM_DRIVER)) {
     36a:	ba 06 00 00 00       	mov    $0x6,%edx
     36f:	b8 00 00 00 00       	mov    $0x0,%eax
     374:	e8 fc ff ff ff       	call   375 <mpt_target_detect+0x75>
     379:	85 c0                	test   %eax,%eax
     37b:	75 1f                	jne    39c <mpt_target_detect+0x9c>
		       ": failed to register for device driver callbacks\n");
		ret = -ENODEV;
		goto out;
	}

	ret = _mpt_ada_nums;
     37d:	a1 10 00 00 00       	mov    0x10,%eax

out:
	TRACE_EXIT_RES(ret);

	return ret;
}
     382:	c9                   	leave  
     383:	c3                   	ret    
     384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int i;

	TRACE_ENTRY();

	if (function_name[0] == '\0')
		strcpy(function_name, __func__);
     388:	ba 34 03 00 00       	mov    $0x334,%edx
     38d:	b8 00 00 00 00       	mov    $0x0,%eax
     392:	e8 fc ff ff ff       	call   393 <mpt_target_detect+0x93>
     397:	e9 78 ff ff ff       	jmp    314 <mpt_target_detect+0x14>
	ret = _mpt_stm_init();
	if (ret != 0)
		goto out;

	if (mpt_device_driver_register(&mptstm_driver, MPTSTM_DRIVER)) {
		printk(KERN_WARNING MYNAM
     39c:	c7 04 24 1c 01 00 00 	movl   $0x11c,(%esp)
     3a3:	e8 fc ff ff ff       	call   3a4 <mpt_target_detect+0xa4>
		       ": failed to register for device driver callbacks\n");
		ret = -ENODEV;
     3a8:	b8 ed ff ff ff       	mov    $0xffffffed,%eax

out:
	TRACE_EXIT_RES(ret);

	return ret;
}
     3ad:	c9                   	leave  
     3ae:	c3                   	ret    
		printk(KERN_WARNING MYNAM
		       ": failed to register for event notification\n");
	}

	if (mpt_reset_register(stm_context, stm_reset_process)) {
		printk(KERN_WARNING MYNAM
     3af:	c7 04 24 e8 00 00 00 	movl   $0xe8,(%esp)
     3b6:	e8 fc ff ff ff       	call   3b7 <mpt_target_detect+0xb7>
     3bb:	eb ad                	jmp    36a <mpt_target_detect+0x6a>
		       ": failed to register with MPT driver core\n");
		return -EBUSY;
	}

	if (mpt_event_register(stm_context, stm_event_process)) {
		printk(KERN_WARNING MYNAM
     3bd:	c7 04 24 b0 00 00 00 	movl   $0xb0,(%esp)
     3c4:	e8 fc ff ff ff       	call   3c5 <mpt_target_detect+0xc5>
     3c9:	eb 8a                	jmp    355 <mpt_target_detect+0x55>
     3cb:	90                   	nop
     3cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000003d0 <mpt_send_cmd_to_scst>:
	return;
}

static int mpt_send_cmd_to_scst(struct mpt_cmd *cmd,
				enum scst_exec_context context)
{
     3d0:	55                   	push   %ebp
     3d1:	89 e5                	mov    %esp,%ebp
     3d3:	57                   	push   %edi
     3d4:	56                   	push   %esi
     3d5:	53                   	push   %ebx
     3d6:	83 ec 64             	sub    $0x64,%esp
     3d9:	e8 fc ff ff ff       	call   3da <mpt_send_cmd_to_scst+0xa>
     3de:	89 c6                	mov    %eax,%esi
     3e0:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
     3e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
     3e9:	31 c0                	xor    %eax,%eax
	int res = 0;

	TRACE_ENTRY();

	cmd->scst_cmd = _stm_target_command(cmd->priv, cmd->reply_word, cmd);
     3eb:	8b 46 10             	mov    0x10(%esi),%eax
     3ee:	8b 7e 08             	mov    0x8(%esi),%edi
	u8 *cdb;
	int lun, tag, dl, alias, index, init_index, task_mgmt;
	char alias_lun[32];
	CMD *cmd;
	struct scst_cmd *scst_cmd;
	struct mpt_sess *sess = mpt_cmd->sess;
     3f1:	8b 0e                	mov    (%esi),%ecx
	return;
}

static int mpt_send_cmd_to_scst(struct mpt_cmd *cmd,
				enum scst_exec_context context)
{
     3f3:	89 55 b4             	mov    %edx,-0x4c(%ebp)
	int res = 0;

	TRACE_ENTRY();

	cmd->scst_cmd = _stm_target_command(cmd->priv, cmd->reply_word, cmd);
     3f6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	 * Get the CBD, LUN, tag,  Task Mgmt flags, and data length from the
	 * receive packet
	 */
	TRACE_ENTRY();

	index = GET_IO_INDEX(reply_word);
     3f9:	25 ff 3f 00 00       	and    $0x3fff,%eax
	init_index = GET_INITIATOR_INDEX(reply_word);

	cmd = &priv->hw->cmd_buf[index];
     3fe:	69 d8 f0 03 00 00    	imul   $0x3f0,%eax,%ebx
	 * Get the CBD, LUN, tag,  Task Mgmt flags, and data length from the
	 * receive packet
	 */
	TRACE_ENTRY();

	index = GET_IO_INDEX(reply_word);
     404:	89 45 b8             	mov    %eax,-0x48(%ebp)
	init_index = GET_INITIATOR_INDEX(reply_word);

	cmd = &priv->hw->cmd_buf[index];

	if (IsScsi(priv)) {
     407:	8b 07                	mov    (%edi),%eax
	TRACE_ENTRY();

	index = GET_IO_INDEX(reply_word);
	init_index = GET_INITIATOR_INDEX(reply_word);

	cmd = &priv->hw->cmd_buf[index];
     409:	03 5f 20             	add    0x20(%edi),%ebx
	u8 *cdb;
	int lun, tag, dl, alias, index, init_index, task_mgmt;
	char alias_lun[32];
	CMD *cmd;
	struct scst_cmd *scst_cmd;
	struct mpt_sess *sess = mpt_cmd->sess;
     40c:	89 4d c0             	mov    %ecx,-0x40(%ebp)
	index = GET_IO_INDEX(reply_word);
	init_index = GET_INITIATOR_INDEX(reply_word);

	cmd = &priv->hw->cmd_buf[index];

	if (IsScsi(priv)) {
     40f:	0f b6 80 69 03 00 00 	movzbl 0x369(%eax),%eax
     416:	3c 01                	cmp    $0x1,%al
     418:	0f 84 32 01 00 00    	je     550 <mpt_send_cmd_to_scst+0x180>
			sprintf(alias_lun, "alias %d lun %d", alias, lun);
		} else {
			alias = 0;
			sprintf(alias_lun, "lun %d", lun);
		}
	} else if (IsSas(priv)) {
     41e:	3c 30                	cmp    $0x30,%al
     420:	0f 84 8a 01 00 00    	je     5b0 <mpt_send_cmd_to_scst+0x1e0>
		alias = 0;
		sprintf(alias_lun, "lun %d", lun);
	} else {
		FCP_CMD *fcp_cmd = (FCP_CMD *)cmd->cmd;

		cdb = fcp_cmd->FcpCdb;
     426:	8d 43 0c             	lea    0xc(%ebx),%eax
		lun = get2bytes(fcp_cmd->FcpLun, 0);
     429:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
		alias = 0;
		sprintf(alias_lun, "lun %d", lun);
	} else {
		FCP_CMD *fcp_cmd = (FCP_CMD *)cmd->cmd;

		cdb = fcp_cmd->FcpCdb;
     42d:	89 45 bc             	mov    %eax,-0x44(%ebp)
		lun = get2bytes(fcp_cmd->FcpLun, 0);
     430:	0f b6 03             	movzbl (%ebx),%eax
     433:	c1 e0 08             	shl    $0x8,%eax
     436:	01 c2                	add    %eax,%edx
		tag = 0;
		task_mgmt = fcp_cmd->FcpCntl[2];
		dl = be32_to_cpu(fcp_cmd->FcpDl);
		if (reply_word & TARGET_MODE_REPLY_ALIAS_MASK) {
     438:	f7 45 c4 00 00 00 04 	testl  $0x4000000,-0x3c(%ebp)
     43f:	0f 85 d3 00 00 00    	jne    518 <mpt_send_cmd_to_scst+0x148>
			alias = fcp_cmd->AliasIndex;
			sprintf(alias_lun, "alias %d lun %d", alias, lun);
		} else {
			alias = 0;
			sprintf(alias_lun, "lun %d", lun);
     445:	8d 45 d0             	lea    -0x30(%ebp),%eax
     448:	89 54 24 08          	mov    %edx,0x8(%esp)
     44c:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
     453:	00 
     454:	89 04 24             	mov    %eax,(%esp)
     457:	89 55 b0             	mov    %edx,-0x50(%ebp)
     45a:	e8 fc ff ff ff       	call   45b <mpt_send_cmd_to_scst+0x8b>
	} else {
		FCP_CMD *fcp_cmd = (FCP_CMD *)cmd->cmd;

		cdb = fcp_cmd->FcpCdb;
		lun = get2bytes(fcp_cmd->FcpLun, 0);
		tag = 0;
     45f:	8b 55 b0             	mov    -0x50(%ebp),%edx
		dl = be32_to_cpu(fcp_cmd->FcpDl);
		if (reply_word & TARGET_MODE_REPLY_ALIAS_MASK) {
			alias = fcp_cmd->AliasIndex;
			sprintf(alias_lun, "alias %d lun %d", alias, lun);
		} else {
			alias = 0;
     462:	31 c9                	xor    %ecx,%ecx
	} else {
		FCP_CMD *fcp_cmd = (FCP_CMD *)cmd->cmd;

		cdb = fcp_cmd->FcpCdb;
		lun = get2bytes(fcp_cmd->FcpLun, 0);
		tag = 0;
     464:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
			alias = 0;
			sprintf(alias_lun, "lun %d", lun);
		}
	}

	cmd->reply_word = reply_word;
     46b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
	cmd->alias = alias;
     46e:	89 8b e4 03 00 00    	mov    %ecx,0x3e4(%ebx)

	mpt_cmd->CMD = cmd;
	{
		uint16_t _lun = lun;
		_lun = swab16(le16_to_cpu(_lun));
		scst_cmd = scst_rx_cmd(sess->scst_sess, (uint8_t *)&_lun,
     474:	b9 02 00 00 00       	mov    $0x2,%ecx
		}
	}

	cmd->reply_word = reply_word;
	cmd->alias = alias;
	cmd->lun = lun;
     479:	89 93 e8 03 00 00    	mov    %edx,0x3e8(%ebx)
 */

static inline __attribute_const__ __u16 __fswab16(__u16 val)
{
#ifdef __HAVE_BUILTIN_BSWAP16__
	return __builtin_bswap16(val);
     47f:	66 c1 c2 08          	rol    $0x8,%dx
			init_index, priv->scst_cmd[index], dl);

	mpt_cmd->CMD = cmd;
	{
		uint16_t _lun = lun;
		_lun = swab16(le16_to_cpu(_lun));
     483:	66 89 55 ce          	mov    %dx,-0x32(%ebp)
		scst_cmd = scst_rx_cmd(sess->scst_sess, (uint8_t *)&_lun,
     487:	8d 55 ce             	lea    -0x32(%ebp),%edx
			alias = 0;
			sprintf(alias_lun, "lun %d", lun);
		}
	}

	cmd->reply_word = reply_word;
     48a:	89 83 e0 03 00 00    	mov    %eax,0x3e0(%ebx)
	cmd->alias = alias;
	cmd->lun = lun;
	cmd->tag = tag;
     490:	8b 45 c8             	mov    -0x38(%ebp),%eax
     493:	89 83 ec 03 00 00    	mov    %eax,0x3ec(%ebx)

	mpt_cmd->CMD = cmd;
	{
		uint16_t _lun = lun;
		_lun = swab16(le16_to_cpu(_lun));
		scst_cmd = scst_rx_cmd(sess->scst_sess, (uint8_t *)&_lun,
     499:	8b 45 bc             	mov    -0x44(%ebp),%eax
	TRACE_DBG("%s: cmd %p, re_word %x, alias %x, lun %x, tag %x,"
			"%s, init_idx %d, %p, %d",
			ioc->name, cmd, reply_word, alias, lun, tag, alias_lun,
			init_index, priv->scst_cmd[index], dl);

	mpt_cmd->CMD = cmd;
     49c:	89 5e 0c             	mov    %ebx,0xc(%esi)
	{
		uint16_t _lun = lun;
		_lun = swab16(le16_to_cpu(_lun));
		scst_cmd = scst_rx_cmd(sess->scst_sess, (uint8_t *)&_lun,
     49f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
     4a6:	00 
     4a7:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
     4ae:	00 
     4af:	89 04 24             	mov    %eax,(%esp)
     4b2:	8b 45 c0             	mov    -0x40(%ebp),%eax
     4b5:	8b 00                	mov    (%eax),%eax
     4b7:	e8 fc ff ff ff       	call   4b8 <mpt_send_cmd_to_scst+0xe8>
				sizeof(_lun), cdb, MPT_MAX_CDB_LEN, SCST_ATOMIC);
	}
	if (scst_cmd == NULL) {
     4bc:	85 c0                	test   %eax,%eax

	mpt_cmd->CMD = cmd;
	{
		uint16_t _lun = lun;
		_lun = swab16(le16_to_cpu(_lun));
		scst_cmd = scst_rx_cmd(sess->scst_sess, (uint8_t *)&_lun,
     4be:	89 c1                	mov    %eax,%ecx
				sizeof(_lun), cdb, MPT_MAX_CDB_LEN, SCST_ATOMIC);
	}
	if (scst_cmd == NULL) {
     4c0:	0f 84 42 01 00 00    	je     608 <mpt_send_cmd_to_scst+0x238>
     4c6:	8b 45 b8             	mov    -0x48(%ebp),%eax
     4c9:	8d 1c 87             	lea    (%edi,%eax,4),%ebx
		PRINT_ERROR(MYNAM ": scst_rx_cmd() failed for %p", cmd);
		goto out;
	}
	TRACE_DBG("scst cmd %p, index %d", priv->scst_cmd[index], index);

	WARN_ON(priv->scst_cmd[index] != NULL);
     4cc:	8b 83 10 0c 00 00    	mov    0xc10(%ebx),%eax
     4d2:	85 c0                	test   %eax,%eax
     4d4:	0f 85 7c 01 00 00    	jne    656 <mpt_send_cmd_to_scst+0x286>
	priv->scst_cmd[index] = scst_cmd;

	scst_cmd_set_tag(scst_cmd, tag);
     4da:	8b 45 c8             	mov    -0x38(%ebp),%eax
		goto out;
	}
	TRACE_DBG("scst cmd %p, index %d", priv->scst_cmd[index], index);

	WARN_ON(priv->scst_cmd[index] != NULL);
	priv->scst_cmd[index] = scst_cmd;
     4dd:	89 8b 10 0c 00 00    	mov    %ecx,0xc10(%ebx)
     4e3:	89 b1 44 01 00 00    	mov    %esi,0x144(%ecx)

	scst_cmd_set_tag(scst_cmd, tag);
     4e9:	99                   	cltd   
     4ea:	89 51 70             	mov    %edx,0x70(%ecx)
		goto out;
	}
#ifdef DEBUG_WORK_IN_THREAD
	context = SCST_CONTEXT_THREAD;
#endif
	scst_cmd_init_done(cmd->scst_cmd, context);
     4ed:	8b 55 b4             	mov    -0x4c(%ebp),%edx
	TRACE_DBG("scst cmd %p, index %d", priv->scst_cmd[index], index);

	WARN_ON(priv->scst_cmd[index] != NULL);
	priv->scst_cmd[index] = scst_cmd;

	scst_cmd_set_tag(scst_cmd, tag);
     4f0:	89 41 6c             	mov    %eax,0x6c(%ecx)
		goto out;
	}
#ifdef DEBUG_WORK_IN_THREAD
	context = SCST_CONTEXT_THREAD;
#endif
	scst_cmd_init_done(cmd->scst_cmd, context);
     4f3:	89 c8                	mov    %ecx,%eax
{
	int res = 0;

	TRACE_ENTRY();

	cmd->scst_cmd = _stm_target_command(cmd->priv, cmd->reply_word, cmd);
     4f5:	89 4e 04             	mov    %ecx,0x4(%esi)
		goto out;
	}
#ifdef DEBUG_WORK_IN_THREAD
	context = SCST_CONTEXT_THREAD;
#endif
	scst_cmd_init_done(cmd->scst_cmd, context);
     4f8:	e8 fc ff ff ff       	call   4f9 <mpt_send_cmd_to_scst+0x129>
}

static int mpt_send_cmd_to_scst(struct mpt_cmd *cmd,
				enum scst_exec_context context)
{
	int res = 0;
     4fd:	31 c0                	xor    %eax,%eax

out:
	TRACE_EXIT_RES(res);

	return res;
}
     4ff:	8b 7d f0             	mov    -0x10(%ebp),%edi
     502:	65 33 3d 14 00 00 00 	xor    %gs:0x14,%edi
     509:	0f 85 42 01 00 00    	jne    651 <mpt_send_cmd_to_scst+0x281>
     50f:	83 c4 64             	add    $0x64,%esp
     512:	5b                   	pop    %ebx
     513:	5e                   	pop    %esi
     514:	5f                   	pop    %edi
     515:	5d                   	pop    %ebp
     516:	c3                   	ret    
     517:	90                   	nop
		lun = get2bytes(fcp_cmd->FcpLun, 0);
		tag = 0;
		task_mgmt = fcp_cmd->FcpCntl[2];
		dl = be32_to_cpu(fcp_cmd->FcpDl);
		if (reply_word & TARGET_MODE_REPLY_ALIAS_MASK) {
			alias = fcp_cmd->AliasIndex;
     518:	0f b6 4b 20          	movzbl 0x20(%ebx),%ecx
			sprintf(alias_lun, "alias %d lun %d", alias, lun);
     51c:	8d 45 d0             	lea    -0x30(%ebp),%eax
     51f:	89 54 24 0c          	mov    %edx,0xc(%esp)
     523:	c7 44 24 04 8b 00 00 	movl   $0x8b,0x4(%esp)
     52a:	00 
     52b:	89 04 24             	mov    %eax,(%esp)
     52e:	89 4c 24 08          	mov    %ecx,0x8(%esp)
     532:	89 55 ac             	mov    %edx,-0x54(%ebp)
     535:	89 4d b0             	mov    %ecx,-0x50(%ebp)
     538:	e8 fc ff ff ff       	call   539 <mpt_send_cmd_to_scst+0x169>
     53d:	8b 4d b0             	mov    -0x50(%ebp),%ecx
	} else {
		FCP_CMD *fcp_cmd = (FCP_CMD *)cmd->cmd;

		cdb = fcp_cmd->FcpCdb;
		lun = get2bytes(fcp_cmd->FcpLun, 0);
		tag = 0;
     540:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
     547:	8b 55 ac             	mov    -0x54(%ebp),%edx
     54a:	e9 1c ff ff ff       	jmp    46b <mpt_send_cmd_to_scst+0x9b>
     54f:	90                   	nop
	cmd = &priv->hw->cmd_buf[index];

	if (IsScsi(priv)) {
		SCSI_CMD *scsi_cmd = (SCSI_CMD *)cmd->cmd;

		cdb = scsi_cmd->CDB;
     550:	8d 43 14             	lea    0x14(%ebx),%eax
		lun = get2bytes(scsi_cmd->LogicalUnitNumber, 0);
     553:	0f b6 53 05          	movzbl 0x5(%ebx),%edx
	cmd = &priv->hw->cmd_buf[index];

	if (IsScsi(priv)) {
		SCSI_CMD *scsi_cmd = (SCSI_CMD *)cmd->cmd;

		cdb = scsi_cmd->CDB;
     557:	89 45 bc             	mov    %eax,-0x44(%ebp)
		lun = get2bytes(scsi_cmd->LogicalUnitNumber, 0);
     55a:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
     55e:	c1 e0 08             	shl    $0x8,%eax
     561:	01 c2                	add    %eax,%edx
		tag = scsi_cmd->Tag;
     563:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
		task_mgmt = scsi_cmd->TaskManagementFlags;
		dl = 0;
		/*TRACE_DBG("AliasID %d, %d", scsi_cmd->AliasID, priv->port_id);*/
		if (reply_word & TARGET_MODE_REPLY_ALIAS_MASK) {
     567:	f7 45 c4 00 00 00 04 	testl  $0x4000000,-0x3c(%ebp)
	if (IsScsi(priv)) {
		SCSI_CMD *scsi_cmd = (SCSI_CMD *)cmd->cmd;

		cdb = scsi_cmd->CDB;
		lun = get2bytes(scsi_cmd->LogicalUnitNumber, 0);
		tag = scsi_cmd->Tag;
     56e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		task_mgmt = scsi_cmd->TaskManagementFlags;
		dl = 0;
		/*TRACE_DBG("AliasID %d, %d", scsi_cmd->AliasID, priv->port_id);*/
		if (reply_word & TARGET_MODE_REPLY_ALIAS_MASK) {
     571:	74 5c                	je     5cf <mpt_send_cmd_to_scst+0x1ff>
			alias = (scsi_cmd->AliasID - priv->port_id) & 15;
     573:	0f b6 4b 24          	movzbl 0x24(%ebx),%ecx
			sprintf(alias_lun, "alias %d lun %d", alias, lun);
     577:	8d 45 d0             	lea    -0x30(%ebp),%eax
		tag = scsi_cmd->Tag;
		task_mgmt = scsi_cmd->TaskManagementFlags;
		dl = 0;
		/*TRACE_DBG("AliasID %d, %d", scsi_cmd->AliasID, priv->port_id);*/
		if (reply_word & TARGET_MODE_REPLY_ALIAS_MASK) {
			alias = (scsi_cmd->AliasID - priv->port_id) & 15;
     57a:	2b 4f 3c             	sub    0x3c(%edi),%ecx
			sprintf(alias_lun, "alias %d lun %d", alias, lun);
     57d:	89 54 24 0c          	mov    %edx,0xc(%esp)
     581:	c7 44 24 04 8b 00 00 	movl   $0x8b,0x4(%esp)
     588:	00 
		tag = scsi_cmd->Tag;
		task_mgmt = scsi_cmd->TaskManagementFlags;
		dl = 0;
		/*TRACE_DBG("AliasID %d, %d", scsi_cmd->AliasID, priv->port_id);*/
		if (reply_word & TARGET_MODE_REPLY_ALIAS_MASK) {
			alias = (scsi_cmd->AliasID - priv->port_id) & 15;
     589:	83 e1 0f             	and    $0xf,%ecx
			sprintf(alias_lun, "alias %d lun %d", alias, lun);
     58c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
     590:	89 04 24             	mov    %eax,(%esp)
     593:	89 55 ac             	mov    %edx,-0x54(%ebp)
     596:	89 4d b0             	mov    %ecx,-0x50(%ebp)
     599:	e8 fc ff ff ff       	call   59a <mpt_send_cmd_to_scst+0x1ca>
     59e:	8b 4d b0             	mov    -0x50(%ebp),%ecx
     5a1:	8b 55 ac             	mov    -0x54(%ebp),%edx
     5a4:	e9 c2 fe ff ff       	jmp    46b <mpt_send_cmd_to_scst+0x9b>
     5a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			sprintf(alias_lun, "lun %d", lun);
		}
	} else if (IsSas(priv)) {
		SSP_CMD *ssp_cmd = (SSP_CMD *)cmd->cmd;

		cdb = ssp_cmd->CDB;
     5b0:	8d 43 14             	lea    0x14(%ebx),%eax
		lun = get2bytes(ssp_cmd->LogicalUnitNumber, 0);
     5b3:	0f b6 53 09          	movzbl 0x9(%ebx),%edx
			sprintf(alias_lun, "lun %d", lun);
		}
	} else if (IsSas(priv)) {
		SSP_CMD *ssp_cmd = (SSP_CMD *)cmd->cmd;

		cdb = ssp_cmd->CDB;
     5b7:	89 45 bc             	mov    %eax,-0x44(%ebp)
		lun = get2bytes(ssp_cmd->LogicalUnitNumber, 0);
     5ba:	0f b6 43 08          	movzbl 0x8(%ebx),%eax
     5be:	c1 e0 08             	shl    $0x8,%eax
     5c1:	01 c2                	add    %eax,%edx
		if (ssp_cmd->FrameType == SSP_TASK_FRAME) {
     5c3:	80 3b 16             	cmpb   $0x16,(%ebx)
     5c6:	74 30                	je     5f8 <mpt_send_cmd_to_scst+0x228>
			SSP_TASK	*ssp_task = (SSP_TASK *)cmd->cmd;

			tag = ssp_task->ManagedTaskTag;
			task_mgmt = ssp_task->TaskManagementFunction;
		} else {
			tag = ssp_cmd->InitiatorTag;
     5c8:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
     5cc:	89 45 c8             	mov    %eax,-0x38(%ebp)
			task_mgmt = 0;
		}
		dl = 0;
		alias = 0;
		sprintf(alias_lun, "lun %d", lun);
     5cf:	8d 45 d0             	lea    -0x30(%ebp),%eax
     5d2:	89 54 24 08          	mov    %edx,0x8(%esp)
     5d6:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
     5dd:	00 
     5de:	89 04 24             	mov    %eax,(%esp)
     5e1:	89 55 b0             	mov    %edx,-0x50(%ebp)
     5e4:	e8 fc ff ff ff       	call   5e5 <mpt_send_cmd_to_scst+0x215>
		} else {
			tag = ssp_cmd->InitiatorTag;
			task_mgmt = 0;
		}
		dl = 0;
		alias = 0;
     5e9:	31 c9                	xor    %ecx,%ecx
     5eb:	8b 55 b0             	mov    -0x50(%ebp),%edx
     5ee:	e9 78 fe ff ff       	jmp    46b <mpt_send_cmd_to_scst+0x9b>
     5f3:	90                   	nop
     5f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cdb = ssp_cmd->CDB;
		lun = get2bytes(ssp_cmd->LogicalUnitNumber, 0);
		if (ssp_cmd->FrameType == SSP_TASK_FRAME) {
			SSP_TASK	*ssp_task = (SSP_TASK *)cmd->cmd;

			tag = ssp_task->ManagedTaskTag;
     5f8:	0f b7 43 14          	movzwl 0x14(%ebx),%eax
     5fc:	89 45 c8             	mov    %eax,-0x38(%ebp)
     5ff:	eb ce                	jmp    5cf <mpt_send_cmd_to_scst+0x1ff>
     601:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		_lun = swab16(le16_to_cpu(_lun));
		scst_cmd = scst_rx_cmd(sess->scst_sess, (uint8_t *)&_lun,
				sizeof(_lun), cdb, MPT_MAX_CDB_LEN, SCST_ATOMIC);
	}
	if (scst_cmd == NULL) {
		PRINT_ERROR(MYNAM ": scst_rx_cmd() failed for %p", cmd);
     608:	89 5c 24 18          	mov    %ebx,0x18(%esp)
     60c:	c7 44 24 14 58 01 00 	movl   $0x158,0x14(%esp)
     613:	00 
     614:	c7 44 24 10 5b 02 00 	movl   $0x25b,0x10(%esp)
     61b:	00 
     61c:	c7 44 24 0c e1 02 00 	movl   $0x2e1,0xc(%esp)
     623:	00 
     624:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     62b:	00 
     62c:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
     633:	00 
     634:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
     63b:	e8 fc ff ff ff       	call   63c <mpt_send_cmd_to_scst+0x26c>

	TRACE_ENTRY();

	cmd->scst_cmd = _stm_target_command(cmd->priv, cmd->reply_word, cmd);
	if (cmd->scst_cmd == NULL) {
		res = -EFAULT;
     640:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
{
	int res = 0;

	TRACE_ENTRY();

	cmd->scst_cmd = _stm_target_command(cmd->priv, cmd->reply_word, cmd);
     645:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
     64c:	e9 ae fe ff ff       	jmp    4ff <mpt_send_cmd_to_scst+0x12f>

out:
	TRACE_EXIT_RES(res);

	return res;
}
     651:	e8 fc ff ff ff       	call   652 <mpt_send_cmd_to_scst+0x282>
		PRINT_ERROR(MYNAM ": scst_rx_cmd() failed for %p", cmd);
		goto out;
	}
	TRACE_DBG("scst cmd %p, index %d", priv->scst_cmd[index], index);

	WARN_ON(priv->scst_cmd[index] != NULL);
     656:	ba 60 02 00 00       	mov    $0x260,%edx
     65b:	b8 8c 01 00 00       	mov    $0x18c,%eax
     660:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
     663:	e8 fc ff ff ff       	call   664 <mpt_send_cmd_to_scst+0x294>
     668:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
     66b:	e9 6a fe ff ff       	jmp    4da <mpt_send_cmd_to_scst+0x10a>

00000670 <stmapp_set_status>:
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stmapp_set_status(MPT_STM_PRIV *priv, CMD *cmd, int status)
{
     670:	55                   	push   %ebp
     671:	89 e5                	mov    %esp,%ebp
     673:	e8 fc ff ff ff       	call   674 <stmapp_set_status+0x4>
	TRACE_ENTRY();
	if (IsScsi(priv)) {
     678:	8b 00                	mov    (%eax),%eax
     67a:	0f b6 80 69 03 00 00 	movzbl 0x369(%eax),%eax
     681:	3c 01                	cmp    $0x1,%al
     683:	74 0b                	je     690 <stmapp_set_status+0x20>
		SCSI_RSP *rsp = (SCSI_RSP *)cmd->rsp;

		rsp->Status = (u8)status;
	} else if (IsSas(priv)) {
     685:	3c 30                	cmp    $0x30,%al
     687:	74 0f                	je     698 <stmapp_set_status+0x28>

		rsp->Status = (u8)status;
	} else {
		FCP_RSP *rsp = (FCP_RSP *)cmd->rsp;

		rsp->FcpStatus = (u8)status;
     689:	88 4a 4b             	mov    %cl,0x4b(%edx)
	}
	TRACE_EXIT();
}
     68c:	5d                   	pop    %ebp
     68d:	c3                   	ret    
     68e:	66 90                	xchg   %ax,%ax
{
	TRACE_ENTRY();
	if (IsScsi(priv)) {
		SCSI_RSP *rsp = (SCSI_RSP *)cmd->rsp;

		rsp->Status = (u8)status;
     690:	88 4a 43             	mov    %cl,0x43(%edx)
		FCP_RSP *rsp = (FCP_RSP *)cmd->rsp;

		rsp->FcpStatus = (u8)status;
	}
	TRACE_EXIT();
}
     693:	5d                   	pop    %ebp
     694:	c3                   	ret    
     695:	8d 76 00             	lea    0x0(%esi),%esi

		rsp->Status = (u8)status;
	} else if (IsSas(priv)) {
		SSP_RSP *rsp = (SSP_RSP *)cmd->rsp;

		rsp->Status = (u8)status;
     698:	88 4a 63             	mov    %cl,0x63(%edx)
		FCP_RSP *rsp = (FCP_RSP *)cmd->rsp;

		rsp->FcpStatus = (u8)status;
	}
	TRACE_EXIT();
}
     69b:	5d                   	pop    %ebp
     69c:	c3                   	ret    
     69d:	8d 76 00             	lea    0x0(%esi),%esi

000006a0 <mpt_alloc_session_done>:
	stmapp_set_status(cmd->priv, cmd->CMD, STS_BUSY);
}

static void mpt_alloc_session_done(struct scst_session *scst_sess, void *data,
				   int result)
{
     6a0:	55                   	push   %ebp
     6a1:	89 e5                	mov    %esp,%ebp
     6a3:	57                   	push   %edi
     6a4:	56                   	push   %esi
     6a5:	53                   	push   %ebx
     6a6:	83 ec 24             	sub    $0x24,%esp
     6a9:	e8 fc ff ff ff       	call   6aa <mpt_alloc_session_done+0xa>
	struct mpt_sess *sess = (struct mpt_sess *) data;
	struct mpt_tgt *tgt = sess->tgt;
     6ae:	8b 42 04             	mov    0x4(%edx),%eax
	struct mpt_cmd *cmd = NULL;
	int rc = 0;

	TRACE_ENTRY();
	if (result == 0) {
     6b1:	85 c9                	test   %ecx,%ecx
	stmapp_set_status(cmd->priv, cmd->CMD, STS_BUSY);
}

static void mpt_alloc_session_done(struct scst_session *scst_sess, void *data,
				   int result)
{
     6b3:	89 d3                	mov    %edx,%ebx
	struct mpt_sess *sess = (struct mpt_sess *) data;
	struct mpt_tgt *tgt = sess->tgt;
     6b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct mpt_cmd *cmd = NULL;
	int rc = 0;

	TRACE_ENTRY();
	if (result == 0) {
     6b8:	0f 85 c2 00 00 00    	jne    780 <mpt_alloc_session_done+0xe0>
     6be:	8d 42 10             	lea    0x10(%edx),%eax
     6c1:	31 ff                	xor    %edi,%edi
     6c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
     6c6:	8b 4b 10             	mov    0x10(%ebx),%ecx
		while (!list_empty(&sess->delayed_cmds)) {
     6c9:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
     6cc:	74 7b                	je     749 <mpt_alloc_session_done+0xa9>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     6ce:	8b 11                	mov    (%ecx),%edx
			cmd = list_entry(sess->delayed_cmds.next,
					 typeof(*cmd), delayed_cmds_entry);
			list_del(&cmd->delayed_cmds_entry);
			if (rc == 0)
     6d0:	85 ff                	test   %edi,%edi
     6d2:	8b 41 04             	mov    0x4(%ecx),%eax
	int rc = 0;

	TRACE_ENTRY();
	if (result == 0) {
		while (!list_empty(&sess->delayed_cmds)) {
			cmd = list_entry(sess->delayed_cmds.next,
     6d5:	8d 71 ec             	lea    -0x14(%ecx),%esi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     6d8:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
     6db:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     6dd:	c7 01 00 01 10 00    	movl   $0x100100,(%ecx)
	entry->prev = LIST_POISON2;
     6e3:	c7 41 04 00 02 20 00 	movl   $0x200200,0x4(%ecx)
					 typeof(*cmd), delayed_cmds_entry);
			list_del(&cmd->delayed_cmds_entry);
			if (rc == 0)
     6ea:	74 6c                	je     758 <mpt_alloc_session_done+0xb8>
				rc = mpt_send_cmd_to_scst(cmd, SCST_CONTEXT_THREAD);
			if (rc != 0) {
				PRINT_INFO(MYNAM ": Unable to get the command, sending BUSY state %p",
     6ec:	89 74 24 18          	mov    %esi,0x18(%esp)
     6f0:	c7 44 24 14 b8 01 00 	movl   $0x1b8,0x14(%esp)
     6f7:	00 
     6f8:	c7 44 24 10 84 02 00 	movl   $0x284,0x10(%esp)
     6ff:	00 
     700:	c7 44 24 0c 0a 03 00 	movl   $0x30a,0xc(%esp)
     707:	00 
     708:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     70f:	00 
     710:	c7 44 24 04 a5 00 00 	movl   $0xa5,0x4(%esp)
     717:	00 
     718:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
     71f:	89 4d ec             	mov    %ecx,-0x14(%ebp)
     722:	e8 fc ff ff ff       	call   723 <mpt_alloc_session_done+0x83>
	return scst_cmd;
}

static void mpt_send_busy(struct mpt_cmd *cmd)
{
	stmapp_set_status(cmd->priv, cmd->CMD, STS_BUSY);
     727:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     72a:	8b 51 f8             	mov    -0x8(%ecx),%edx
     72d:	8b 41 f4             	mov    -0xc(%ecx),%eax
     730:	b9 08 00 00 00       	mov    $0x8,%ecx
     735:	e8 36 ff ff ff       	call   670 <stmapp_set_status>
				rc = mpt_send_cmd_to_scst(cmd, SCST_CONTEXT_THREAD);
			if (rc != 0) {
				PRINT_INFO(MYNAM ": Unable to get the command, sending BUSY state %p",
					   cmd);
				mpt_send_busy(cmd);
				kfree(cmd);
     73a:	89 f0                	mov    %esi,%eax
     73c:	e8 fc ff ff ff       	call   73d <mpt_alloc_session_done+0x9d>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
     741:	8b 4b 10             	mov    0x10(%ebx),%ecx
	struct mpt_cmd *cmd = NULL;
	int rc = 0;

	TRACE_ENTRY();
	if (result == 0) {
		while (!list_empty(&sess->delayed_cmds)) {
     744:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
     747:	75 85                	jne    6ce <mpt_alloc_session_done+0x2e>
	clear_bit(nr, addr);
}

static inline void __clear_bit(long nr, volatile unsigned long *addr)
{
	asm volatile("btr %1,%0" : ADDR : "Ir" (nr));
     749:	0f ba 73 0c 00       	btrl   $0x0,0xc(%ebx)
			wake_up_all(&tgt->waitQ);
	}

	TRACE_EXIT();
	return;
}
     74e:	83 c4 24             	add    $0x24,%esp
     751:	5b                   	pop    %ebx
     752:	5e                   	pop    %esi
     753:	5f                   	pop    %edi
     754:	5d                   	pop    %ebp
     755:	c3                   	ret    
     756:	66 90                	xchg   %ax,%ax
		while (!list_empty(&sess->delayed_cmds)) {
			cmd = list_entry(sess->delayed_cmds.next,
					 typeof(*cmd), delayed_cmds_entry);
			list_del(&cmd->delayed_cmds_entry);
			if (rc == 0)
				rc = mpt_send_cmd_to_scst(cmd, SCST_CONTEXT_THREAD);
     758:	ba 03 00 00 00       	mov    $0x3,%edx
     75d:	89 f0                	mov    %esi,%eax
     75f:	89 4d ec             	mov    %ecx,-0x14(%ebp)
     762:	e8 69 fc ff ff       	call   3d0 <mpt_send_cmd_to_scst>
			if (rc != 0) {
     767:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     76a:	85 c0                	test   %eax,%eax
		while (!list_empty(&sess->delayed_cmds)) {
			cmd = list_entry(sess->delayed_cmds.next,
					 typeof(*cmd), delayed_cmds_entry);
			list_del(&cmd->delayed_cmds_entry);
			if (rc == 0)
				rc = mpt_send_cmd_to_scst(cmd, SCST_CONTEXT_THREAD);
     76c:	89 c7                	mov    %eax,%edi
			if (rc != 0) {
     76e:	0f 84 52 ff ff ff    	je     6c6 <mpt_alloc_session_done+0x26>
     774:	e9 73 ff ff ff       	jmp    6ec <mpt_alloc_session_done+0x4c>
     779:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				kfree(cmd);
			}
		}
		__clear_bit(MPT_SESS_INITING, &sess->sess_flags);
	} else {
		PRINT_INFO(MYNAM ": Session initialization failed, "
     780:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
     787:	00 
			   "sending BUSY status to all deferred commands %p",
			   cmd);
		while (!list_empty(&sess->delayed_cmds)) {
     788:	8d 7b 10             	lea    0x10(%ebx),%edi
				kfree(cmd);
			}
		}
		__clear_bit(MPT_SESS_INITING, &sess->sess_flags);
	} else {
		PRINT_INFO(MYNAM ": Session initialization failed, "
     78b:	c7 44 24 14 f4 01 00 	movl   $0x1f4,0x14(%esp)
     792:	00 
     793:	c7 44 24 10 8d 02 00 	movl   $0x28d,0x10(%esp)
     79a:	00 
     79b:	c7 44 24 0c 0a 03 00 	movl   $0x30a,0xc(%esp)
     7a2:	00 
     7a3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     7aa:	00 
     7ab:	c7 44 24 04 a5 00 00 	movl   $0xa5,0x4(%esp)
     7b2:	00 
     7b3:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
     7ba:	e8 fc ff ff ff       	call   7bb <mpt_alloc_session_done+0x11b>
     7bf:	8b 73 10             	mov    0x10(%ebx),%esi
			   "sending BUSY status to all deferred commands %p",
			   cmd);
		while (!list_empty(&sess->delayed_cmds)) {
     7c2:	39 f7                	cmp    %esi,%edi
     7c4:	74 38                	je     7fe <mpt_alloc_session_done+0x15e>
     7c6:	66 90                	xchg   %ax,%ax
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     7c8:	8b 16                	mov    (%esi),%edx
	return scst_cmd;
}

static void mpt_send_busy(struct mpt_cmd *cmd)
{
	stmapp_set_status(cmd->priv, cmd->CMD, STS_BUSY);
     7ca:	b9 08 00 00 00       	mov    $0x8,%ecx
     7cf:	8b 46 04             	mov    0x4(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     7d2:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
     7d5:	89 10                	mov    %edx,(%eax)
     7d7:	8b 56 f8             	mov    -0x8(%esi),%edx
     7da:	8b 46 f4             	mov    -0xc(%esi),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     7dd:	c7 06 00 01 10 00    	movl   $0x100100,(%esi)
	entry->prev = LIST_POISON2;
     7e3:	c7 46 04 00 02 20 00 	movl   $0x200200,0x4(%esi)
     7ea:	e8 81 fe ff ff       	call   670 <stmapp_set_status>
	} else {
		PRINT_INFO(MYNAM ": Session initialization failed, "
			   "sending BUSY status to all deferred commands %p",
			   cmd);
		while (!list_empty(&sess->delayed_cmds)) {
			cmd = list_entry(sess->delayed_cmds.next,
     7ef:	8d 46 ec             	lea    -0x14(%esi),%eax
					 typeof(*cmd), delayed_cmds_entry);
			list_del(&cmd->delayed_cmds_entry);
			TRACE(TRACE_MGMT, "Command <%p> Busy", cmd);
			mpt_send_busy(cmd);
			kfree(cmd);
     7f2:	e8 fc ff ff ff       	call   7f3 <mpt_alloc_session_done+0x153>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
     7f7:	8b 73 10             	mov    0x10(%ebx),%esi
		__clear_bit(MPT_SESS_INITING, &sess->sess_flags);
	} else {
		PRINT_INFO(MYNAM ": Session initialization failed, "
			   "sending BUSY status to all deferred commands %p",
			   cmd);
		while (!list_empty(&sess->delayed_cmds)) {
     7fa:	39 f7                	cmp    %esi,%edi
     7fc:	75 ca                	jne    7c8 <mpt_alloc_session_done+0x128>
			list_del(&cmd->delayed_cmds_entry);
			TRACE(TRACE_MGMT, "Command <%p> Busy", cmd);
			mpt_send_busy(cmd);
			kfree(cmd);
		}
		tgt->sess[sess->init_index] = NULL;
     7fe:	8b 43 08             	mov    0x8(%ebx),%eax
     801:	8b 7d f0             	mov    -0x10(%ebp),%edi
     804:	c7 44 87 24 00 00 00 	movl   $0x0,0x24(%edi,%eax,4)
     80b:	00 

		TRACE_MEM("kfree for sess %p", sess);
		kfree(sess);
     80c:	89 d8                	mov    %ebx,%eax
     80e:	e8 fc ff ff ff       	call   80f <mpt_alloc_session_done+0x16f>
 * returns true if the result is 0, or false for all other
 * cases.
 */
static inline int atomic_dec_and_test(atomic_t *v)
{
	GEN_UNARY_RMWcc(LOCK_PREFIX "decl", v->counter, "%0", "e");
     813:	f0 ff 4f 14          	lock decl 0x14(%edi)
     817:	74 0f                	je     828 <mpt_alloc_session_done+0x188>
			wake_up_all(&tgt->waitQ);
	}

	TRACE_EXIT();
	return;
}
     819:	83 c4 24             	add    $0x24,%esp
     81c:	5b                   	pop    %ebx
     81d:	5e                   	pop    %esi
     81e:	5f                   	pop    %edi
     81f:	5d                   	pop    %ebp
     820:	c3                   	ret    
     821:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

		TRACE_MEM("kfree for sess %p", sess);
		kfree(sess);

		if (atomic_dec_and_test(&tgt->sess_count))
			wake_up_all(&tgt->waitQ);
     828:	8b 45 f0             	mov    -0x10(%ebp),%eax
     82b:	31 c9                	xor    %ecx,%ecx
     82d:	ba 03 00 00 00       	mov    $0x3,%edx
     832:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     839:	83 c0 18             	add    $0x18,%eax
     83c:	e8 fc ff ff ff       	call   83d <mpt_alloc_session_done+0x19d>
	}

	TRACE_EXIT();
	return;
}
     841:	83 c4 24             	add    $0x24,%esp
     844:	5b                   	pop    %ebx
     845:	5e                   	pop    %esi
     846:	5f                   	pop    %edi
     847:	5d                   	pop    %ebp
     848:	c3                   	ret    
     849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000850 <mpt_task_mgmt_fn_done>:
 * function has been completed. Completion status could be get via
 * scst_mgmt_cmd_get_status(). No return value expected. Must be
 * defined, if the target supports task management functionality.
 */
static void mpt_task_mgmt_fn_done(struct scst_mgmt_cmd *mgmt_cmd)
{
     850:	55                   	push   %ebp
     851:	89 e5                	mov    %esp,%ebp
     853:	e8 fc ff ff ff       	call   854 <mpt_task_mgmt_fn_done+0x4>
	TRACE_ENTRY();
	WARN_ON(1);
     858:	ba 41 07 00 00       	mov    $0x741,%edx
     85d:	b8 8c 01 00 00       	mov    $0x18c,%eax
	TRACE_EXIT();
}
     862:	5d                   	pop    %ebp
 * defined, if the target supports task management functionality.
 */
static void mpt_task_mgmt_fn_done(struct scst_mgmt_cmd *mgmt_cmd)
{
	TRACE_ENTRY();
	WARN_ON(1);
     863:	e9 fc ff ff ff       	jmp    864 <mpt_task_mgmt_fn_done+0x14>
     868:	90                   	nop
     869:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000870 <stm_wait.constprop.49>:
	TRACE_EXIT_RES(ret);

	return ret;
}

static void stm_wait(MPT_STM_PRIV *priv, int milliseconds, int sleep)
     870:	55                   	push   %ebp
     871:	89 e5                	mov    %esp,%ebp
     873:	53                   	push   %ebx
     874:	83 ec 10             	sub    $0x10,%esp
     877:	e8 fc ff ff ff       	call   878 <stm_wait.constprop.49+0x8>
{
	MPT_ADAPTER		*ioc = priv->ioc;

	TRACE_ENTRY();
	if (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_OPERATIONAL) {
     87c:	ba 01 00 00 00       	mov    $0x1,%edx
	return ret;
}

static void stm_wait(MPT_STM_PRIV *priv, int milliseconds, int sleep)
{
	MPT_ADAPTER		*ioc = priv->ioc;
     881:	8b 18                	mov    (%eax),%ebx

	TRACE_ENTRY();
	if (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_OPERATIONAL) {
     883:	89 d8                	mov    %ebx,%eax
     885:	e8 fc ff ff ff       	call   886 <stm_wait.constprop.49+0x16>
     88a:	3d 00 00 00 20       	cmp    $0x20000000,%eax
     88f:	75 29                	jne    8ba <stm_wait.constprop.49+0x4a>
		printk(KERN_ERR MYNAM
		       ":%s IOC is not operational (doorbell = %x)\n",
		       ioc->name, mpt_GetIocState(ioc, 0));
	} else {
		if (sleep == CAN_SLEEP) {
			set_current_state(TASK_INTERRUPTIBLE);
     891:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
     898:	8b 45 f8             	mov    -0x8(%ebp),%eax

DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
	return this_cpu_read_stable(current_task);
     89b:	64 8b 15 00 00 00 00 	mov    %fs:0x0,%edx
     8a2:	87 02                	xchg   %eax,(%edx)
     8a4:	89 45 f8             	mov    %eax,-0x8(%ebp)
     8a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
			schedule_timeout(milliseconds);
     8aa:	b8 0a 00 00 00       	mov    $0xa,%eax
     8af:	e8 fc ff ff ff       	call   8b0 <stm_wait.constprop.49+0x40>
#endif
			mdelay(milliseconds);
		}
	}
	TRACE_EXIT();
}
     8b4:	83 c4 10             	add    $0x10,%esp
     8b7:	5b                   	pop    %ebx
     8b8:	5d                   	pop    %ebp
     8b9:	c3                   	ret    
{
	MPT_ADAPTER		*ioc = priv->ioc;

	TRACE_ENTRY();
	if (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_OPERATIONAL) {
		printk(KERN_ERR MYNAM
     8ba:	31 d2                	xor    %edx,%edx
     8bc:	89 d8                	mov    %ebx,%eax
     8be:	e8 fc ff ff ff       	call   8bf <stm_wait.constprop.49+0x4f>
		       ":%s IOC is not operational (doorbell = %x)\n",
		       ioc->name, mpt_GetIocState(ioc, 0));
     8c3:	83 c3 08             	add    $0x8,%ebx
     8c6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
{
	MPT_ADAPTER		*ioc = priv->ioc;

	TRACE_ENTRY();
	if (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_OPERATIONAL) {
		printk(KERN_ERR MYNAM
     8ca:	c7 04 24 cc 02 00 00 	movl   $0x2cc,(%esp)
     8d1:	89 44 24 08          	mov    %eax,0x8(%esp)
     8d5:	e8 fc ff ff ff       	call   8d6 <stm_wait.constprop.49+0x66>
     8da:	eb d8                	jmp    8b4 <stm_wait.constprop.49+0x44>
     8dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000008e0 <stm_wait_for.constprop.52>:
	}
	TRACE_EXIT();
}

static int
stm_wait_for(MPT_STM_PRIV *priv, volatile int *flag, int seconds, int sleep)
     8e0:	55                   	push   %ebp
     8e1:	89 e5                	mov    %esp,%ebp
     8e3:	57                   	push   %edi
     8e4:	56                   	push   %esi
     8e5:	53                   	push   %ebx
     8e6:	83 ec 10             	sub    $0x10,%esp
     8e9:	e8 fc ff ff ff       	call   8ea <stm_wait_for.constprop.52+0xa>
{
	MPT_ADAPTER		*ioc = priv->ioc;
     8ee:	8b 38                	mov    (%eax),%edi
	int			i;

	TRACE_ENTRY();
	for (i = 0; i < seconds * ((sleep == CAN_SLEEP) ? HZ : 1000); i++) {
     8f0:	69 c1 e8 03 00 00    	imul   $0x3e8,%ecx,%eax
	}
	TRACE_EXIT();
}

static int
stm_wait_for(MPT_STM_PRIV *priv, volatile int *flag, int seconds, int sleep)
     8f6:	89 d6                	mov    %edx,%esi
{
	MPT_ADAPTER		*ioc = priv->ioc;
	int			i;

	TRACE_ENTRY();
	for (i = 0; i < seconds * ((sleep == CAN_SLEEP) ? HZ : 1000); i++) {
     8f8:	85 c0                	test   %eax,%eax
     8fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
     8fd:	7e 65                	jle    964 <stm_wait_for.constprop.52+0x84>
		if (!(*flag))
     8ff:	8b 02                	mov    (%edx),%eax
     901:	85 c0                	test   %eax,%eax
     903:	74 2e                	je     933 <stm_wait_for.constprop.52+0x53>
     905:	31 db                	xor    %ebx,%ebx
     907:	90                   	nop
			return 0;
		if (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_OPERATIONAL) {
     908:	ba 01 00 00 00       	mov    $0x1,%edx
     90d:	89 f8                	mov    %edi,%eax
     90f:	e8 fc ff ff ff       	call   910 <stm_wait_for.constprop.52+0x30>
     914:	3d 00 00 00 20       	cmp    $0x20000000,%eax
     919:	75 22                	jne    93d <stm_wait_for.constprop.52+0x5d>
		} else {
#ifndef __linux__
			if (priv->poll_enabled)
				_mpt_poll(priv->ioc);
#endif
			mdelay(1);
     91b:	b8 58 89 41 00       	mov    $0x418958,%eax
{
	MPT_ADAPTER		*ioc = priv->ioc;
	int			i;

	TRACE_ENTRY();
	for (i = 0; i < seconds * ((sleep == CAN_SLEEP) ? HZ : 1000); i++) {
     920:	83 c3 01             	add    $0x1,%ebx
		} else {
#ifndef __linux__
			if (priv->poll_enabled)
				_mpt_poll(priv->ioc);
#endif
			mdelay(1);
     923:	e8 fc ff ff ff       	call   924 <stm_wait_for.constprop.52+0x44>
{
	MPT_ADAPTER		*ioc = priv->ioc;
	int			i;

	TRACE_ENTRY();
	for (i = 0; i < seconds * ((sleep == CAN_SLEEP) ? HZ : 1000); i++) {
     928:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
     92b:	74 37                	je     964 <stm_wait_for.constprop.52+0x84>
		if (!(*flag))
     92d:	8b 06                	mov    (%esi),%eax
     92f:	85 c0                	test   %eax,%eax
     931:	75 d5                	jne    908 <stm_wait_for.constprop.52+0x28>
			return 0;
     933:	31 c0                	xor    %eax,%eax

	printk(KERN_ERR MYNAM ":%s timed out in stm_wait_for!\n", ioc->name);
	TRACE_EXIT();

	return -1;
}
     935:	83 c4 10             	add    $0x10,%esp
     938:	5b                   	pop    %ebx
     939:	5e                   	pop    %esi
     93a:	5f                   	pop    %edi
     93b:	5d                   	pop    %ebp
     93c:	c3                   	ret    
	TRACE_ENTRY();
	for (i = 0; i < seconds * ((sleep == CAN_SLEEP) ? HZ : 1000); i++) {
		if (!(*flag))
			return 0;
		if (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_OPERATIONAL) {
			printk(KERN_ERR MYNAM
     93d:	31 d2                	xor    %edx,%edx
     93f:	89 f8                	mov    %edi,%eax
     941:	e8 fc ff ff ff       	call   942 <stm_wait_for.constprop.52+0x62>
			       ":%s IOC is not operational (doorbell = %x)\n",
			       ioc->name, mpt_GetIocState(ioc, 0));
     946:	83 c7 08             	add    $0x8,%edi
     949:	89 7c 24 04          	mov    %edi,0x4(%esp)
	TRACE_ENTRY();
	for (i = 0; i < seconds * ((sleep == CAN_SLEEP) ? HZ : 1000); i++) {
		if (!(*flag))
			return 0;
		if (mpt_GetIocState(ioc, 1) != MPI_IOC_STATE_OPERATIONAL) {
			printk(KERN_ERR MYNAM
     94d:	c7 04 24 cc 02 00 00 	movl   $0x2cc,(%esp)
     954:	89 44 24 08          	mov    %eax,0x8(%esp)
     958:	e8 fc ff ff ff       	call   959 <stm_wait_for.constprop.52+0x79>
			       ":%s IOC is not operational (doorbell = %x)\n",
			       ioc->name, mpt_GetIocState(ioc, 0));
			return -1;
     95d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     962:	eb d1                	jmp    935 <stm_wait_for.constprop.52+0x55>
		}
	}

	/* timed out, so return failure */

	printk(KERN_ERR MYNAM ":%s timed out in stm_wait_for!\n", ioc->name);
     964:	83 c7 08             	add    $0x8,%edi
     967:	89 7c 24 04          	mov    %edi,0x4(%esp)
     96b:	c7 04 24 04 03 00 00 	movl   $0x304,(%esp)
     972:	e8 fc ff ff ff       	call   973 <stm_wait_for.constprop.52+0x93>
	TRACE_EXIT();

	return -1;
     977:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     97c:	eb b7                	jmp    935 <stm_wait_for.constprop.52+0x55>
     97e:	66 90                	xchg   %ax,%ax

00000980 <stmapp_set_sense_info.constprop.55>:
	*io_state &= ~IO_STATE_AUTO_REPOST;
	stm_target_cleanup(priv, index);
	TRACE_EXIT();
}

static void stmapp_set_sense_info(MPT_STM_PRIV *priv, CMD *cmd, int sense_key,
     980:	55                   	push   %ebp
     981:	89 e5                	mov    %esp,%ebp
     983:	53                   	push   %ebx
     984:	e8 fc ff ff ff       	call   985 <stmapp_set_sense_info.constprop.55+0x5>
				  int asc, int ascq)
{
	u8	*info;

	TRACE_ENTRY();
	if (IsScsi(priv)) {
     989:	8b 00                	mov    (%eax),%eax
     98b:	0f b6 80 69 03 00 00 	movzbl 0x369(%eax),%eax
     992:	3c 01                	cmp    $0x1,%al
     994:	74 42                	je     9d8 <stmapp_set_sense_info.constprop.55+0x58>
		rsp->Valid |= SCSI_SENSE_LEN_VALID;
		rsp->SenseDataListLength = cpu_to_be32(14);
		info = rsp->SenseData;
		if (rsp->Valid & SCSI_RSP_LEN_VALID)
			info += be32_to_cpu(rsp->PktFailuresListLength);
	} else if (IsSas(priv)) {
     996:	3c 30                	cmp    $0x30,%al
     998:	74 66                	je     a00 <stmapp_set_sense_info.constprop.55+0x80>
			info += be32_to_cpu(rsp->ResponseDataLength);
	} else {
		FCP_RSP *rsp = (FCP_RSP *)cmd->rsp;

		rsp->FcpStatus = STS_CHECK_CONDITION;
		rsp->FcpFlags |= FCP_SENSE_LEN_VALID;
     99a:	0f b6 5a 4a          	movzbl 0x4a(%edx),%ebx
		if (rsp->DataPres & SSP_RSP_LEN_VALID)
			info += be32_to_cpu(rsp->ResponseDataLength);
	} else {
		FCP_RSP *rsp = (FCP_RSP *)cmd->rsp;

		rsp->FcpStatus = STS_CHECK_CONDITION;
     99e:	c6 42 4b 02          	movb   $0x2,0x4b(%edx)
		rsp->FcpFlags |= FCP_SENSE_LEN_VALID;
		rsp->FcpSenseLength = cpu_to_be32(14);
     9a2:	c7 42 50 00 00 00 0e 	movl   $0xe000000,0x50(%edx)
			info += be32_to_cpu(rsp->ResponseDataLength);
	} else {
		FCP_RSP *rsp = (FCP_RSP *)cmd->rsp;

		rsp->FcpStatus = STS_CHECK_CONDITION;
		rsp->FcpFlags |= FCP_SENSE_LEN_VALID;
     9a9:	89 d8                	mov    %ebx,%eax
     9ab:	83 c8 02             	or     $0x2,%eax
		rsp->FcpSenseLength = cpu_to_be32(14);
		info = rsp->FcpSenseData - sizeof(rsp->FcpResponseData);
		if (rsp->FcpFlags & FCP_RSP_LEN_VALID)
     9ae:	83 e3 01             	and    $0x1,%ebx
			info += be32_to_cpu(rsp->ResponseDataLength);
	} else {
		FCP_RSP *rsp = (FCP_RSP *)cmd->rsp;

		rsp->FcpStatus = STS_CHECK_CONDITION;
		rsp->FcpFlags |= FCP_SENSE_LEN_VALID;
     9b1:	88 42 4a             	mov    %al,0x4a(%edx)
		rsp->FcpSenseLength = cpu_to_be32(14);
		info = rsp->FcpSenseData - sizeof(rsp->FcpResponseData);
     9b4:	8d 42 58             	lea    0x58(%edx),%eax
		if (rsp->FcpFlags & FCP_RSP_LEN_VALID)
     9b7:	74 07                	je     9c0 <stmapp_set_sense_info.constprop.55+0x40>
}

static inline __attribute_const__ __u32 __fswab32(__u32 val)
{
#ifdef __HAVE_BUILTIN_BSWAP32__
	return __builtin_bswap32(val);
     9b9:	8b 52 54             	mov    0x54(%edx),%edx
     9bc:	0f ca                	bswap  %edx
			info += be32_to_cpu(rsp->FcpResponseLength);
     9be:	01 d0                	add    %edx,%eax
	info[0] = 0x70;
	info[2] = (u8)sense_key;
	info[7] = 6;

	info[12] = (u8)asc;
	info[13] = (u8)ascq;
     9c0:	8b 55 08             	mov    0x8(%ebp),%edx
		info = rsp->FcpSenseData - sizeof(rsp->FcpResponseData);
		if (rsp->FcpFlags & FCP_RSP_LEN_VALID)
			info += be32_to_cpu(rsp->FcpResponseLength);
	}

	info[0] = 0x70;
     9c3:	c6 00 70             	movb   $0x70,(%eax)
	info[2] = (u8)sense_key;
     9c6:	c6 40 02 0b          	movb   $0xb,0x2(%eax)
	info[7] = 6;
     9ca:	c6 40 07 06          	movb   $0x6,0x7(%eax)

	info[12] = (u8)asc;
     9ce:	88 48 0c             	mov    %cl,0xc(%eax)
	info[13] = (u8)ascq;
     9d1:	88 50 0d             	mov    %dl,0xd(%eax)
	TRACE_EXIT();
}
     9d4:	5b                   	pop    %ebx
     9d5:	5d                   	pop    %ebp
     9d6:	c3                   	ret    
     9d7:	90                   	nop
	TRACE_ENTRY();
	if (IsScsi(priv)) {
		SCSI_RSP *rsp = (SCSI_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
		rsp->Valid |= SCSI_SENSE_LEN_VALID;
     9d8:	0f b6 5a 42          	movzbl 0x42(%edx),%ebx

	TRACE_ENTRY();
	if (IsScsi(priv)) {
		SCSI_RSP *rsp = (SCSI_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
     9dc:	c6 42 43 02          	movb   $0x2,0x43(%edx)
		rsp->Valid |= SCSI_SENSE_LEN_VALID;
		rsp->SenseDataListLength = cpu_to_be32(14);
     9e0:	c7 42 44 00 00 00 0e 	movl   $0xe000000,0x44(%edx)
	TRACE_ENTRY();
	if (IsScsi(priv)) {
		SCSI_RSP *rsp = (SCSI_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
		rsp->Valid |= SCSI_SENSE_LEN_VALID;
     9e7:	89 d8                	mov    %ebx,%eax
     9e9:	83 c8 02             	or     $0x2,%eax
		rsp->SenseDataListLength = cpu_to_be32(14);
		info = rsp->SenseData;
		if (rsp->Valid & SCSI_RSP_LEN_VALID)
     9ec:	83 e3 01             	and    $0x1,%ebx
	TRACE_ENTRY();
	if (IsScsi(priv)) {
		SCSI_RSP *rsp = (SCSI_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
		rsp->Valid |= SCSI_SENSE_LEN_VALID;
     9ef:	88 42 42             	mov    %al,0x42(%edx)
		rsp->SenseDataListLength = cpu_to_be32(14);
		info = rsp->SenseData;
     9f2:	8d 42 4c             	lea    0x4c(%edx),%eax
		if (rsp->Valid & SCSI_RSP_LEN_VALID)
     9f5:	74 c9                	je     9c0 <stmapp_set_sense_info.constprop.55+0x40>
     9f7:	8b 52 48             	mov    0x48(%edx),%edx
     9fa:	0f ca                	bswap  %edx
			info += be32_to_cpu(rsp->PktFailuresListLength);
     9fc:	01 d0                	add    %edx,%eax
     9fe:	eb c0                	jmp    9c0 <stmapp_set_sense_info.constprop.55+0x40>
	} else if (IsSas(priv)) {
		SSP_RSP *rsp = (SSP_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
		rsp->DataPres |= SSP_SENSE_LEN_VALID;
     a00:	0f b6 5a 62          	movzbl 0x62(%edx),%ebx
		if (rsp->Valid & SCSI_RSP_LEN_VALID)
			info += be32_to_cpu(rsp->PktFailuresListLength);
	} else if (IsSas(priv)) {
		SSP_RSP *rsp = (SSP_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
     a04:	c6 42 63 02          	movb   $0x2,0x63(%edx)
		rsp->DataPres |= SSP_SENSE_LEN_VALID;
		rsp->SenseDataLength = cpu_to_be32(14);
     a08:	c7 42 68 00 00 00 0e 	movl   $0xe000000,0x68(%edx)
			info += be32_to_cpu(rsp->PktFailuresListLength);
	} else if (IsSas(priv)) {
		SSP_RSP *rsp = (SSP_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
		rsp->DataPres |= SSP_SENSE_LEN_VALID;
     a0f:	89 d8                	mov    %ebx,%eax
     a11:	83 c8 02             	or     $0x2,%eax
		rsp->SenseDataLength = cpu_to_be32(14);
		info = rsp->ResponseSenseData;
		if (rsp->DataPres & SSP_RSP_LEN_VALID)
     a14:	83 e3 01             	and    $0x1,%ebx
			info += be32_to_cpu(rsp->PktFailuresListLength);
	} else if (IsSas(priv)) {
		SSP_RSP *rsp = (SSP_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
		rsp->DataPres |= SSP_SENSE_LEN_VALID;
     a17:	88 42 62             	mov    %al,0x62(%edx)
		rsp->SenseDataLength = cpu_to_be32(14);
		info = rsp->ResponseSenseData;
     a1a:	8d 42 70             	lea    0x70(%edx),%eax
		if (rsp->DataPres & SSP_RSP_LEN_VALID)
     a1d:	74 a1                	je     9c0 <stmapp_set_sense_info.constprop.55+0x40>
     a1f:	8b 52 6c             	mov    0x6c(%edx),%edx
     a22:	0f ca                	bswap  %edx
			info += be32_to_cpu(rsp->ResponseDataLength);
     a24:	01 d0                	add    %edx,%eax
     a26:	eb 98                	jmp    9c0 <stmapp_set_sense_info.constprop.55+0x40>
     a28:	90                   	nop
     a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000a30 <stm_data_done.isra.38>:
	}

	TRACE_EXIT_RES(ret);
}

static void stm_data_done(MPT_ADAPTER *ioc, u32 reply_word,
     a30:	55                   	push   %ebp
     a31:	89 e5                	mov    %esp,%ebp
     a33:	57                   	push   %edi
     a34:	56                   	push   %esi
     a35:	53                   	push   %ebx
     a36:	83 ec 10             	sub    $0x10,%esp
     a39:	e8 fc ff ff ff       	call   a3a <stm_data_done.isra.38+0xa>
			  struct scst_cmd *scst_cmd, struct mpt_cmd *cmd,
			  int index)
{
	MPT_STM_PRIV *priv = mpt_stm_priv[ioc->id];
     a3e:	8b 34 85 20 00 00 00 	mov    0x20(,%eax,4),%esi
	}

	TRACE_EXIT_RES(ret);
}

static void stm_data_done(MPT_ADAPTER *ioc, u32 reply_word,
     a45:	89 d3                	mov    %edx,%ebx
	MPT_STM_PRIV *priv = mpt_stm_priv[ioc->id];

	TRACE_ENTRY();
	TRACE_DBG("scst cmd %p, index %d, data done",  scst_cmd, index);

	if (scst_cmd_get_resp_data_len(scst_cmd) > 0) {
     a47:	8b 92 e8 00 00 00    	mov    0xe8(%edx),%edx
     a4d:	85 d2                	test   %edx,%edx
     a4f:	7e 54                	jle    aa5 <stm_data_done.isra.38+0x75>
		TRACE_DBG("clear the data flags <%p>", scst_cmd);
		sBUG_ON(scst_cmd_get_sg_cnt(scst_cmd) == 0);
     a51:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
     a57:	85 c0                	test   %eax,%eax
     a59:	74 52                	je     aad <stm_data_done.isra.38+0x7d>
		pci_unmap_sg(priv->ioc->pcidev,
			scst_cmd_get_sg(scst_cmd),
			scst_cmd_get_sg_cnt(scst_cmd),
			scst_to_tgt_dma_dir(scst_cmd_get_data_direction(scst_cmd)));
     a5b:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
     a61:	e8 fc ff ff ff       	call   a62 <stm_data_done.isra.38+0x32>

	TRACE_EXIT_RES(ret);
}

static void stm_data_done(MPT_ADAPTER *ioc, u32 reply_word,
			  struct scst_cmd *scst_cmd, struct mpt_cmd *cmd,
     a66:	8b 8b d4 00 00 00    	mov    0xd4(%ebx),%ecx
     a6c:	8b 93 d8 00 00 00    	mov    0xd8(%ebx),%edx
	TRACE_DBG("scst cmd %p, index %d, data done",  scst_cmd, index);

	if (scst_cmd_get_resp_data_len(scst_cmd) > 0) {
		TRACE_DBG("clear the data flags <%p>", scst_cmd);
		sBUG_ON(scst_cmd_get_sg_cnt(scst_cmd) == 0);
		pci_unmap_sg(priv->ioc->pcidev,
     a72:	8b 1e                	mov    (%esi),%ebx
     a74:	8b b3 48 01 00 00    	mov    0x148(%ebx),%esi

static inline void
pci_unmap_sg(struct pci_dev *hwdev, struct scatterlist *sg,
	     int nents, int direction)
{
	dma_unmap_sg(hwdev == NULL ? NULL : &hwdev->dev, sg, nents, (enum dma_data_direction)direction);
     a7a:	31 db                	xor    %ebx,%ebx
     a7c:	8d 7e 64             	lea    0x64(%esi),%edi
     a7f:	85 f6                	test   %esi,%esi
extern struct dma_map_ops *dma_ops;

static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
     a81:	8b 35 00 00 00 00    	mov    0x0,%esi
     a87:	0f 45 df             	cmovne %edi,%ebx
				      int nents, enum dma_data_direction dir,
				      struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
     a8a:	83 f8 02             	cmp    $0x2,%eax
     a8d:	77 6f                	ja     afe <stm_data_done.isra.38+0xce>
	debug_dma_unmap_sg(dev, sg, nents, dir);
	if (ops->unmap_sg)
     a8f:	8b 76 1c             	mov    0x1c(%esi),%esi
     a92:	85 f6                	test   %esi,%esi
     a94:	74 0f                	je     aa5 <stm_data_done.isra.38+0x75>
		ops->unmap_sg(dev, sg, nents, dir, attrs);
     a96:	89 04 24             	mov    %eax,(%esp)
     a99:	89 d8                	mov    %ebx,%eax
     a9b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
     aa2:	00 
     aa3:	ff d6                	call   *%esi
			scst_cmd_get_sg(scst_cmd),
			scst_cmd_get_sg_cnt(scst_cmd),
			scst_to_tgt_dma_dir(scst_cmd_get_data_direction(scst_cmd)));
	}
	TRACE_EXIT();
}
     aa5:	83 c4 10             	add    $0x10,%esp
     aa8:	5b                   	pop    %ebx
     aa9:	5e                   	pop    %esi
     aaa:	5f                   	pop    %edi
     aab:	5d                   	pop    %ebp
     aac:	c3                   	ret    
	TRACE_ENTRY();
	TRACE_DBG("scst cmd %p, index %d, data done",  scst_cmd, index);

	if (scst_cmd_get_resp_data_len(scst_cmd) > 0) {
		TRACE_DBG("clear the data flags <%p>", scst_cmd);
		sBUG_ON(scst_cmd_get_sg_cnt(scst_cmd) == 0);
     aad:	c7 44 24 0c 30 03 00 	movl   $0x330,0xc(%esp)
     ab4:	00 
     ab5:	c7 44 24 08 e0 02 00 	movl   $0x2e0,0x8(%esp)
     abc:	00 
     abd:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
     ac4:	00 
     ac5:	c7 04 24 b3 00 00 00 	movl   $0xb3,(%esp)
     acc:	e8 fc ff ff ff       	call   acd <stm_data_done.isra.38+0x9d>
	PVOP_VCALLEE0(pv_irq_ops.irq_disable);
}

static inline notrace void arch_local_irq_enable(void)
{
	PVOP_VCALLEE0(pv_irq_ops.irq_enable);
     ad1:	ff 15 0c 00 00 00    	call   *0xc
 * We mask the PREEMPT_NEED_RESCHED bit so as not to confuse all current users
 * that think a non-zero value indicates we cannot preempt.
 */
static __always_inline int preempt_count(void)
{
	return raw_cpu_read_4(__preempt_count) & ~PREEMPT_NEED_RESCHED;
     ad7:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
     add:	f6 c4 ff             	test   $0xff,%ah
     ae0:	74 1a                	je     afc <stm_data_done.isra.38+0xcc>
	__local_bh_enable_ip(ip, SOFTIRQ_DISABLE_OFFSET);
}

static inline void local_bh_enable(void)
{
	__local_bh_enable_ip(_THIS_IP_, SOFTIRQ_DISABLE_OFFSET);
     ae2:	b8 e2 0a 00 00       	mov    $0xae2,%eax
     ae7:	ba 00 02 00 00       	mov    $0x200,%edx
     aec:	e8 fc ff ff ff       	call   aed <stm_data_done.isra.38+0xbd>
     af1:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
     af7:	f6 c4 ff             	test   $0xff,%ah
     afa:	75 e6                	jne    ae2 <stm_data_done.isra.38+0xb2>
     afc:	0f 0b                	ud2    
				      int nents, enum dma_data_direction dir,
				      struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
     afe:	0f 0b                	ud2    

00000b00 <stm_link_serv_buf_post>:
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_link_serv_buf_post(MPT_STM_PRIV *priv, int index)
{
     b00:	55                   	push   %ebp
     b01:	89 e5                	mov    %esp,%ebp
     b03:	57                   	push   %edi
     b04:	56                   	push   %esi
     b05:	53                   	push   %ebx
     b06:	83 ec 08             	sub    $0x8,%esp
     b09:	e8 fc ff ff ff       	call   b0a <stm_link_serv_buf_post+0xa>
     b0e:	89 c6                	mov    %eax,%esi
	MPT_ADAPTER				*ioc = priv->ioc;
     b10:	8b 00                	mov    (%eax),%eax
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_link_serv_buf_post(MPT_STM_PRIV *priv, int index)
{
     b12:	89 55 ec             	mov    %edx,-0x14(%ebp)
	MPT_ADAPTER				*ioc = priv->ioc;
     b15:	89 45 f0             	mov    %eax,-0x10(%ebp)
     b18:	89 c2                	mov    %eax,%edx
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
     b1a:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
     b21:	e8 fc ff ff ff       	call   b22 <stm_link_serv_buf_post+0x22>

	sBUG_ON(mf == NULL);
     b26:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
     b28:	89 c2                	mov    %eax,%edx

	sBUG_ON(mf == NULL);
     b2a:	0f 84 b9 00 00 00    	je     be9 <stm_link_serv_buf_post+0xe9>
	MPT_STM_SIMPLE			*sge_simple;
	dma_addr_t				dma_addr;

	TRACE_ENTRY();
	req = (LinkServiceBufferPostRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
     b30:	a8 01                	test   $0x1,%al
     b32:	89 c7                	mov    %eax,%edi
     b34:	bb 24 00 00 00       	mov    $0x24,%ebx
     b39:	0f 85 81 00 00 00    	jne    bc0 <stm_link_serv_buf_post+0xc0>
     b3f:	f7 c7 02 00 00 00    	test   $0x2,%edi
     b45:	0f 85 8d 00 00 00    	jne    bd8 <stm_link_serv_buf_post+0xd8>
     b4b:	89 d9                	mov    %ebx,%ecx
     b4d:	31 c0                	xor    %eax,%eax
     b4f:	c1 e9 02             	shr    $0x2,%ecx
     b52:	f6 c3 02             	test   $0x2,%bl
     b55:	f3 ab                	rep stos %eax,%es:(%edi)
     b57:	74 09                	je     b62 <stm_link_serv_buf_post+0x62>
     b59:	31 c0                	xor    %eax,%eax
     b5b:	83 c7 02             	add    $0x2,%edi
     b5e:	66 89 47 fe          	mov    %ax,-0x2(%edi)
     b62:	83 e3 01             	and    $0x1,%ebx
     b65:	74 03                	je     b6a <stm_link_serv_buf_post+0x6a>
     b67:	c6 07 00             	movb   $0x0,(%edi)
	req->Function = MPI_FUNCTION_FC_LINK_SRVC_BUF_POST;
	sge_trans = (SGETransaction32_t *)&req->SGL;
	sge_trans->ContextSize = 4;
	sge_trans->DetailsLength = 0;
	sge_trans->Flags = 0;
	sge_trans->TransactionContext[0] = cpu_to_le32(index);
     b6a:	8b 45 ec             	mov    -0x14(%ebp),%eax

	TRACE_ENTRY();
	req = (LinkServiceBufferPostRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));

	req->BufferCount = 1;
     b6d:	c6 42 01 01          	movb   $0x1,0x1(%edx)
	req->Function = MPI_FUNCTION_FC_LINK_SRVC_BUF_POST;
     b71:	c6 42 03 0e          	movb   $0xe,0x3(%edx)
	sge_trans = (SGETransaction32_t *)&req->SGL;
	sge_trans->ContextSize = 4;
     b75:	c6 42 0d 04          	movb   $0x4,0xd(%edx)
								MPI_SGE_FLAGS_END_OF_BUFFER |
								MPI_SGE_FLAGS_END_OF_LIST |
								MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
								MPI_SGE_FLAGS_HOST_TO_IOC));
	dma_addr = priv->hw_dma +
		((u8 *)priv->hw->fc_link_serv_buf[index].fc_els - (u8 *)priv->hw);
     b79:	8d 88 f0 03 00 00    	lea    0x3f0(%eax),%ecx
     b7f:	c1 e1 07             	shl    $0x7,%ecx
								MPI_SGE_FLAGS_LAST_ELEMENT |
								MPI_SGE_FLAGS_END_OF_BUFFER |
								MPI_SGE_FLAGS_END_OF_LIST |
								MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
								MPI_SGE_FLAGS_HOST_TO_IOC));
	dma_addr = priv->hw_dma +
     b82:	89 cb                	mov    %ecx,%ebx
	req->Function = MPI_FUNCTION_FC_LINK_SRVC_BUF_POST;
	sge_trans = (SGETransaction32_t *)&req->SGL;
	sge_trans->ContextSize = 4;
	sge_trans->DetailsLength = 0;
	sge_trans->Flags = 0;
	sge_trans->TransactionContext[0] = cpu_to_le32(index);
     b84:	89 42 10             	mov    %eax,0x10(%edx)
								MPI_SGE_FLAGS_LAST_ELEMENT |
								MPI_SGE_FLAGS_END_OF_BUFFER |
								MPI_SGE_FLAGS_END_OF_LIST |
								MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
								MPI_SGE_FLAGS_HOST_TO_IOC));
	dma_addr = priv->hw_dma +
     b87:	c1 fb 1f             	sar    $0x1f,%ebx
			TRACE(TRACE_MPI, "%s: req[%02x] = %08x",
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif
	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     b8a:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax

	req->BufferCount = 1;
	req->Function = MPI_FUNCTION_FC_LINK_SRVC_BUF_POST;
	sge_trans = (SGETransaction32_t *)&req->SGL;
	sge_trans->ContextSize = 4;
	sge_trans->DetailsLength = 0;
     b91:	c6 42 0e 00          	movb   $0x0,0xe(%edx)
	sge_trans->Flags = 0;
     b95:	c6 42 0f 00          	movb   $0x0,0xf(%edx)
	sge_trans->TransactionContext[0] = cpu_to_le32(index);
	sge_simple = (MPT_STM_SIMPLE *)&sge_trans->TransactionDetails[0];
	sge_simple->FlagsLength = cpu_to_le32(sizeof(FC_ELS) |
     b99:	c7 42 14 80 00 00 d7 	movl   $0xd7000080,0x14(%edx)
								MPI_SGE_FLAGS_LAST_ELEMENT |
								MPI_SGE_FLAGS_END_OF_BUFFER |
								MPI_SGE_FLAGS_END_OF_LIST |
								MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
								MPI_SGE_FLAGS_HOST_TO_IOC));
	dma_addr = priv->hw_dma +
     ba0:	03 4e 24             	add    0x24(%esi),%ecx
     ba3:	13 5e 28             	adc    0x28(%esi),%ebx
		((u8 *)priv->hw->fc_link_serv_buf[index].fc_els - (u8 *)priv->hw);
	stm_set_dma_addr(sge_simple->Address, dma_addr);
     ba6:	89 4a 18             	mov    %ecx,0x18(%edx)
			TRACE(TRACE_MPI, "%s: req[%02x] = %08x",
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif
	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     ba9:	89 d1                	mov    %edx,%ecx
								MPI_SGE_FLAGS_END_OF_LIST |
								MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
								MPI_SGE_FLAGS_HOST_TO_IOC));
	dma_addr = priv->hw_dma +
		((u8 *)priv->hw->fc_link_serv_buf[index].fc_els - (u8 *)priv->hw);
	stm_set_dma_addr(sge_simple->Address, dma_addr);
     bab:	89 5a 1c             	mov    %ebx,0x1c(%edx)
			TRACE(TRACE_MPI, "%s: req[%02x] = %08x",
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif
	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     bae:	8b 55 f0             	mov    -0x10(%ebp),%edx
	TRACE_EXIT();
}
     bb1:	83 c4 08             	add    $0x8,%esp
     bb4:	5b                   	pop    %ebx
     bb5:	5e                   	pop    %esi
     bb6:	5f                   	pop    %edi
     bb7:	5d                   	pop    %ebp
			TRACE(TRACE_MPI, "%s: req[%02x] = %08x",
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif
	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     bb8:	e9 fc ff ff ff       	jmp    bb9 <stm_link_serv_buf_post+0xb9>
     bbd:	8d 76 00             	lea    0x0(%esi),%esi
	MPT_STM_SIMPLE			*sge_simple;
	dma_addr_t				dma_addr;

	TRACE_ENTRY();
	req = (LinkServiceBufferPostRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
     bc0:	8d 78 01             	lea    0x1(%eax),%edi
     bc3:	b3 23                	mov    $0x23,%bl
     bc5:	f7 c7 02 00 00 00    	test   $0x2,%edi
     bcb:	c6 00 00             	movb   $0x0,(%eax)
     bce:	0f 84 77 ff ff ff    	je     b4b <stm_link_serv_buf_post+0x4b>
     bd4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     bd8:	31 c9                	xor    %ecx,%ecx
     bda:	83 c7 02             	add    $0x2,%edi
     bdd:	66 89 4f fe          	mov    %cx,-0x2(%edi)
     be1:	83 eb 02             	sub    $0x2,%ebx
     be4:	e9 62 ff ff ff       	jmp    b4b <stm_link_serv_buf_post+0x4b>
     be9:	e8 11 00 00 00       	call   bff <stm_send_els+0xf>
     bee:	66 90                	xchg   %ax,%ax

00000bf0 <stm_send_els>:
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_send_els(MPT_STM_PRIV *priv, LinkServiceBufferPostReply_t *rep,
			 int index, int length)
{
     bf0:	55                   	push   %ebp
     bf1:	89 e5                	mov    %esp,%ebp
     bf3:	57                   	push   %edi
     bf4:	56                   	push   %esi
     bf5:	53                   	push   %ebx
     bf6:	83 ec 10             	sub    $0x10,%esp
     bf9:	e8 fc ff ff ff       	call   bfa <stm_send_els+0xa>
     bfe:	8b 75 08             	mov    0x8(%ebp),%esi
     c01:	89 45 ec             	mov    %eax,-0x14(%ebp)
	MPT_ADAPTER			*ioc = priv->ioc;
     c04:	8b 00                	mov    (%eax),%eax
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_send_els(MPT_STM_PRIV *priv, LinkServiceBufferPostReply_t *rep,
			 int index, int length)
{
     c06:	89 d3                	mov    %edx,%ebx
     c08:	89 4d e8             	mov    %ecx,-0x18(%ebp)
     c0b:	89 75 e4             	mov    %esi,-0x1c(%ebp)
	MPT_ADAPTER			*ioc = priv->ioc;
     c0e:	89 c2                	mov    %eax,%edx
     c10:	89 45 f0             	mov    %eax,-0x10(%ebp)
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
     c13:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
     c1a:	e8 fc ff ff ff       	call   c1b <stm_send_els+0x2b>

	sBUG_ON(mf == NULL);
     c1f:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
     c21:	89 c2                	mov    %eax,%edx

	sBUG_ON(mf == NULL);
     c23:	0f 84 e0 00 00 00    	je     d09 <stm_send_els+0x119>
	int				*p_index;
	dma_addr_t			dma_addr;

	TRACE_ENTRY();
	req = (LinkServiceRspRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
     c29:	a8 01                	test   $0x1,%al
     c2b:	89 c7                	mov    %eax,%edi
     c2d:	be 30 00 00 00       	mov    $0x30,%esi
     c32:	0f 85 a8 00 00 00    	jne    ce0 <stm_send_els+0xf0>
     c38:	f7 c7 02 00 00 00    	test   $0x2,%edi
     c3e:	0f 85 b4 00 00 00    	jne    cf8 <stm_send_els+0x108>
     c44:	89 f1                	mov    %esi,%ecx
     c46:	31 c0                	xor    %eax,%eax
     c48:	c1 e9 02             	shr    $0x2,%ecx
     c4b:	f7 c6 02 00 00 00    	test   $0x2,%esi
     c51:	f3 ab                	rep stos %eax,%es:(%edi)
     c53:	74 09                	je     c5e <stm_send_els+0x6e>
     c55:	31 c0                	xor    %eax,%eax
     c57:	83 c7 02             	add    $0x2,%edi
     c5a:	66 89 47 fe          	mov    %ax,-0x2(%edi)
     c5e:	83 e6 01             	and    $0x1,%esi
     c61:	74 03                	je     c66 <stm_send_els+0x76>
     c63:	c6 07 00             	movb   $0x0,(%edi)

	req->RspLength = (u8)length;
     c66:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	req->Function = MPI_FUNCTION_FC_LINK_SRVC_RSP;
	memcpy((u8 *)req + 0x0c, (u8 *)rep + 0x1c, 24);
     c69:	8d 4b 1c             	lea    0x1c(%ebx),%ecx
	TRACE_ENTRY();
	req = (LinkServiceRspRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));

	req->RspLength = (u8)length;
	req->Function = MPI_FUNCTION_FC_LINK_SRVC_RSP;
     c6c:	c6 42 03 0f          	movb   $0xf,0x3(%edx)
								MPI_SGE_FLAGS_END_OF_BUFFER |
								MPI_SGE_FLAGS_END_OF_LIST |
								MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
								MPI_SGE_FLAGS_HOST_TO_IOC));
	dma_addr = priv->hw_dma +
		((u8 *)priv->hw->fc_link_serv_buf[index].fc_els - (u8 *)priv->hw);
     c70:	8b 7d e8             	mov    -0x18(%ebp),%edi

	TRACE_ENTRY();
	req = (LinkServiceRspRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));

	req->RspLength = (u8)length;
     c73:	89 f0                	mov    %esi,%eax
     c75:	88 42 01             	mov    %al,0x1(%edx)
	req->Function = MPI_FUNCTION_FC_LINK_SRVC_RSP;
	memcpy((u8 *)req + 0x0c, (u8 *)rep + 0x1c, 24);
     c78:	8b 5b 1c             	mov    0x1c(%ebx),%ebx
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	sge_simple->FlagsLength = cpu_to_le32(length |
     c7b:	89 f0                	mov    %esi,%eax
     c7d:	0d 00 00 00 d7       	or     $0xd7000000,%eax
	req = (LinkServiceRspRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));

	req->RspLength = (u8)length;
	req->Function = MPI_FUNCTION_FC_LINK_SRVC_RSP;
	memcpy((u8 *)req + 0x0c, (u8 *)rep + 0x1c, 24);
     c82:	89 5a 0c             	mov    %ebx,0xc(%edx)
     c85:	8b 59 04             	mov    0x4(%ecx),%ebx
     c88:	89 5a 10             	mov    %ebx,0x10(%edx)
     c8b:	8b 59 08             	mov    0x8(%ecx),%ebx
     c8e:	89 5a 14             	mov    %ebx,0x14(%edx)
     c91:	8b 59 0c             	mov    0xc(%ecx),%ebx
     c94:	89 5a 18             	mov    %ebx,0x18(%edx)
     c97:	8b 59 10             	mov    0x10(%ecx),%ebx
     c9a:	89 5a 1c             	mov    %ebx,0x1c(%edx)
     c9d:	8b 49 14             	mov    0x14(%ecx),%ecx
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	sge_simple->FlagsLength = cpu_to_le32(length |
     ca0:	89 42 24             	mov    %eax,0x24(%edx)
								MPI_SGE_FLAGS_LAST_ELEMENT |
								MPI_SGE_FLAGS_END_OF_BUFFER |
								MPI_SGE_FLAGS_END_OF_LIST |
								MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
								MPI_SGE_FLAGS_HOST_TO_IOC));
	dma_addr = priv->hw_dma +
     ca3:	8b 45 ec             	mov    -0x14(%ebp),%eax
	req = (LinkServiceRspRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));

	req->RspLength = (u8)length;
	req->Function = MPI_FUNCTION_FC_LINK_SRVC_RSP;
	memcpy((u8 *)req + 0x0c, (u8 *)rep + 0x1c, 24);
     ca6:	89 4a 20             	mov    %ecx,0x20(%edx)
								MPI_SGE_FLAGS_END_OF_BUFFER |
								MPI_SGE_FLAGS_END_OF_LIST |
								MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
								MPI_SGE_FLAGS_HOST_TO_IOC));
	dma_addr = priv->hw_dma +
		((u8 *)priv->hw->fc_link_serv_buf[index].fc_els - (u8 *)priv->hw);
     ca9:	8d 8f f0 03 00 00    	lea    0x3f0(%edi),%ecx
     caf:	c1 e1 07             	shl    $0x7,%ecx
								MPI_SGE_FLAGS_LAST_ELEMENT |
								MPI_SGE_FLAGS_END_OF_BUFFER |
								MPI_SGE_FLAGS_END_OF_LIST |
								MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
								MPI_SGE_FLAGS_HOST_TO_IOC));
	dma_addr = priv->hw_dma +
     cb2:	89 cb                	mov    %ecx,%ebx
     cb4:	c1 fb 1f             	sar    $0x1f,%ebx
     cb7:	03 48 24             	add    0x24(%eax),%ecx
     cba:	13 58 28             	adc    0x28(%eax),%ebx
		((u8 *)priv->hw->fc_link_serv_buf[index].fc_els - (u8 *)priv->hw);
	stm_set_dma_addr(sge_simple->Address, dma_addr);
	p_index = (int *)(sge_simple + 1);
	*p_index = index;
     cbd:	89 7a 30             	mov    %edi,0x30(%edx)
			TRACE(TRACE_MPI, "%s: req[%02x] = %08x",
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif
	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     cc0:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
								MPI_SGE_FLAGS_END_OF_LIST |
								MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
								MPI_SGE_FLAGS_HOST_TO_IOC));
	dma_addr = priv->hw_dma +
		((u8 *)priv->hw->fc_link_serv_buf[index].fc_els - (u8 *)priv->hw);
	stm_set_dma_addr(sge_simple->Address, dma_addr);
     cc7:	89 4a 28             	mov    %ecx,0x28(%edx)
			TRACE(TRACE_MPI, "%s: req[%02x] = %08x",
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif
	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     cca:	89 d1                	mov    %edx,%ecx
								MPI_SGE_FLAGS_END_OF_LIST |
								MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
								MPI_SGE_FLAGS_HOST_TO_IOC));
	dma_addr = priv->hw_dma +
		((u8 *)priv->hw->fc_link_serv_buf[index].fc_els - (u8 *)priv->hw);
	stm_set_dma_addr(sge_simple->Address, dma_addr);
     ccc:	89 5a 2c             	mov    %ebx,0x2c(%edx)
			TRACE(TRACE_MPI, "%s: req[%02x] = %08x",
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif
	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     ccf:	8b 55 f0             	mov    -0x10(%ebp),%edx
	TRACE_EXIT();
}
     cd2:	83 c4 10             	add    $0x10,%esp
     cd5:	5b                   	pop    %ebx
     cd6:	5e                   	pop    %esi
     cd7:	5f                   	pop    %edi
     cd8:	5d                   	pop    %ebp
			TRACE(TRACE_MPI, "%s: req[%02x] = %08x",
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif
	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     cd9:	e9 fc ff ff ff       	jmp    cda <stm_send_els+0xea>
     cde:	66 90                	xchg   %ax,%ax
	int				*p_index;
	dma_addr_t			dma_addr;

	TRACE_ENTRY();
	req = (LinkServiceRspRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
     ce0:	8d 78 01             	lea    0x1(%eax),%edi
     ce3:	66 be 2f 00          	mov    $0x2f,%si
     ce7:	f7 c7 02 00 00 00    	test   $0x2,%edi
     ced:	c6 00 00             	movb   $0x0,(%eax)
     cf0:	0f 84 4e ff ff ff    	je     c44 <stm_send_els+0x54>
     cf6:	66 90                	xchg   %ax,%ax
     cf8:	31 c9                	xor    %ecx,%ecx
     cfa:	83 c7 02             	add    $0x2,%edi
     cfd:	66 89 4f fe          	mov    %cx,-0x2(%edi)
     d01:	83 ee 02             	sub    $0x2,%esi
     d04:	e9 3b ff ff ff       	jmp    c44 <stm_send_els+0x54>
     d09:	e8 11 00 00 00       	call   d1f <mptstm_remove+0xf>
     d0e:	66 90                	xchg   %ax,%ax

00000d10 <mptstm_remove>:

	return ret;
}

static void mptstm_remove(struct pci_dev *pdev)
{
     d10:	55                   	push   %ebp
     d11:	89 e5                	mov    %esp,%ebp
     d13:	57                   	push   %edi
     d14:	56                   	push   %esi
     d15:	53                   	push   %ebx
     d16:	83 ec 1c             	sub    $0x1c,%esp
     d19:	e8 fc ff ff ff       	call   d1a <mptstm_remove+0xa>
	MPT_ADAPTER	*ioc = pci_get_drvdata(pdev);
	MPT_STM_PRIV *priv;

	priv = mpt_stm_priv[ioc->id];
     d1e:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
     d24:	8b 00                	mov    (%eax),%eax
     d26:	8b 1c 85 20 00 00 00 	mov    0x20(,%eax,4),%ebx
	if (priv != NULL)
     d2d:	85 db                	test   %ebx,%ebx
     d2f:	0f 84 c9 01 00 00    	je     efe <mptstm_remove+0x1ee>
	MPT_ADAPTER *ioc;

	TRACE_ENTRY();
	priv->exiting = 1;

	ioc = priv->ioc;
     d35:	8b 03                	mov    (%ebx),%eax

	if (mpt_GetIocState(ioc, 1) == MPI_IOC_STATE_OPERATIONAL) {
     d37:	ba 01 00 00 00       	mov    $0x1,%edx
static void mpt_stm_adapter_dispose(MPT_STM_PRIV *priv)
{
	MPT_ADAPTER *ioc;

	TRACE_ENTRY();
	priv->exiting = 1;
     d3c:	c7 83 80 00 00 00 01 	movl   $0x1,0x80(%ebx)
     d43:	00 00 00 

	ioc = priv->ioc;
     d46:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (mpt_GetIocState(ioc, 1) == MPI_IOC_STATE_OPERATIONAL) {
     d49:	e8 fc ff ff ff       	call   d4a <mptstm_remove+0x3a>
     d4e:	3d 00 00 00 20       	cmp    $0x20000000,%eax
     d53:	0f 84 ac 00 00 00    	je     e05 <mptstm_remove+0xf5>
			if (IsFc(priv))
				stm_link_serv_abort(priv);
		}
	}

	mpt_stm_priv[ioc->id] = NULL;
     d59:	8b 7d f0             	mov    -0x10(%ebp),%edi
     d5c:	8b 07                	mov    (%edi),%eax
     d5e:	c7 04 85 20 00 00 00 	movl   $0x0,0x20(,%eax,4)
     d65:	00 00 00 00 
	if (priv->hw != NULL)
     d69:	8b 73 20             	mov    0x20(%ebx),%esi
     d6c:	85 f6                	test   %esi,%esi
     d6e:	74 75                	je     de5 <mptstm_remove+0xd5>
		pci_free_consistent(ioc->pcidev, sizeof(*priv->hw),
     d70:	8b 43 24             	mov    0x24(%ebx),%eax
     d73:	8b 53 28             	mov    0x28(%ebx),%edx
     d76:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     d79:	8b 87 48 01 00 00    	mov    0x148(%edi),%eax

static inline void
pci_free_consistent(struct pci_dev *hwdev, size_t size,
		    void *vaddr, dma_addr_t dma_handle)
{
	dma_free_coherent(hwdev == NULL ? NULL : &hwdev->dev, size, vaddr, dma_handle);
     d7f:	31 ff                	xor    %edi,%edi
     d81:	89 55 e8             	mov    %edx,-0x18(%ebp)
     d84:	85 c0                	test   %eax,%eax
     d86:	8d 50 64             	lea    0x64(%eax),%edx
     d89:	a1 00 00 00 00       	mov    0x0,%eax
     d8e:	0f 45 fa             	cmovne %edx,%edi
     d91:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define __PV_IS_CALLEE_SAVE(func)			\
	((struct paravirt_callee_save) { func })

static inline notrace unsigned long arch_local_save_flags(void)
{
	return PVOP_CALLEE0(unsigned long, pv_irq_ops.save_fl);
     d94:	ff 15 00 00 00 00    	call   *0x0
				  void *vaddr, dma_addr_t bus,
				  struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	WARN_ON(irqs_disabled());       /* for portability */
     d9a:	f6 c4 02             	test   $0x2,%ah
     d9d:	0f 84 fa 01 00 00    	je     f9d <mptstm_remove+0x28d>

	if (dma_release_from_coherent(dev, get_order(size), vaddr))
     da3:	89 f1                	mov    %esi,%ecx
     da5:	ba 06 00 00 00       	mov    $0x6,%edx
     daa:	89 f8                	mov    %edi,%eax
     dac:	e8 fc ff ff ff       	call   dad <mptstm_remove+0x9d>
     db1:	85 c0                	test   %eax,%eax
     db3:	75 30                	jne    de5 <mptstm_remove+0xd5>
		return;

	debug_dma_free_coherent(dev, size, vaddr, bus);
	if (ops->free)
     db5:	8b 45 ec             	mov    -0x14(%ebp),%eax
     db8:	8b 40 04             	mov    0x4(%eax),%eax
     dbb:	85 c0                	test   %eax,%eax
     dbd:	89 45 ec             	mov    %eax,-0x14(%ebp)
     dc0:	74 23                	je     de5 <mptstm_remove+0xd5>
		ops->free(dev, size, vaddr, bus, attrs);
     dc2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
     dc5:	89 f8                	mov    %edi,%eax
     dc7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
     dca:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     dd1:	00 
     dd2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
     dd6:	89 f1                	mov    %esi,%ecx
     dd8:	8b 75 ec             	mov    -0x14(%ebp),%esi
     ddb:	89 14 24             	mov    %edx,(%esp)
     dde:	ba 80 20 02 00       	mov    $0x22080,%edx
     de3:	ff d6                	call   *%esi
				    priv->hw, priv->hw_dma);
	if (priv->config_mf != NULL)
     de5:	8b 93 84 00 00 00    	mov    0x84(%ebx),%edx
     deb:	85 d2                	test   %edx,%edx
     ded:	74 08                	je     df7 <mptstm_remove+0xe7>
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->config_mf);
     def:	8b 45 f0             	mov    -0x10(%ebp),%eax
     df2:	e8 fc ff ff ff       	call   df3 <mptstm_remove+0xe3>
	MPT_STM_PRIV *priv;

	priv = mpt_stm_priv[ioc->id];
	if (priv != NULL)
		mpt_stm_adapter_dispose(priv);
}
     df7:	83 c4 1c             	add    $0x1c,%esp
	if (priv->hw != NULL)
		pci_free_consistent(ioc->pcidev, sizeof(*priv->hw),
				    priv->hw, priv->hw_dma);
	if (priv->config_mf != NULL)
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->config_mf);
	kfree(priv);
     dfa:	89 d8                	mov    %ebx,%eax
	MPT_STM_PRIV *priv;

	priv = mpt_stm_priv[ioc->id];
	if (priv != NULL)
		mpt_stm_adapter_dispose(priv);
}
     dfc:	5b                   	pop    %ebx
     dfd:	5e                   	pop    %esi
     dfe:	5f                   	pop    %edi
     dff:	5d                   	pop    %ebp
	if (priv->hw != NULL)
		pci_free_consistent(ioc->pcidev, sizeof(*priv->hw),
				    priv->hw, priv->hw_dma);
	if (priv->config_mf != NULL)
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->config_mf);
	kfree(priv);
     e00:	e9 fc ff ff ff       	jmp    e01 <mptstm_remove+0xf1>
	priv->exiting = 1;

	ioc = priv->ioc;

	if (mpt_GetIocState(ioc, 1) == MPI_IOC_STATE_OPERATIONAL) {
		if (priv->enable_target_mode && priv->tgt->target_enable) {
     e05:	8b 53 04             	mov    0x4(%ebx),%edx
     e08:	85 d2                	test   %edx,%edx
     e0a:	0f 84 49 ff ff ff    	je     d59 <mptstm_remove+0x49>
     e10:	8b 83 0c 0c 00 00    	mov    0xc0c(%ebx),%eax
     e16:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
     e1c:	85 c0                	test   %eax,%eax
     e1e:	0f 84 35 ff ff ff    	je     d59 <mptstm_remove+0x49>
     e24:	8b 73 14             	mov    0x14(%ebx),%esi
	int			i;
	int			n;

	TRACE_ENTRY();
	while (1) {
		n = 0;
     e27:	31 c9                	xor    %ecx,%ecx
		for (i = 0; i < priv->num_cmd_buffers; i++)
     e29:	31 c0                	xor    %eax,%eax
     e2b:	eb 15                	jmp    e42 <mptstm_remove+0x132>
     e2d:	8d 76 00             	lea    0x0(%esi),%esi
			if (priv->io_state[i] & IO_STATE_AUTO_REPOST)
     e30:	8d 50 28             	lea    0x28(%eax),%edx
     e33:	8b 14 93             	mov    (%ebx,%edx,4),%edx
     e36:	83 e2 20             	and    $0x20,%edx
				n++;
     e39:	83 fa 01             	cmp    $0x1,%edx
     e3c:	83 d9 ff             	sbb    $0xffffffff,%ecx
	int			n;

	TRACE_ENTRY();
	while (1) {
		n = 0;
		for (i = 0; i < priv->num_cmd_buffers; i++)
     e3f:	83 c0 01             	add    $0x1,%eax
     e42:	39 f0                	cmp    %esi,%eax
     e44:	7c ea                	jl     e30 <mptstm_remove+0x120>
			if (priv->io_state[i] & IO_STATE_AUTO_REPOST)
				n++;

		if (n == 0)
     e46:	85 c9                	test   %ecx,%ecx
     e48:	0f 85 b8 00 00 00    	jne    f06 <mptstm_remove+0x1f6>
					   sizeof(*req), (u32 *)req _HS_SLEEP);
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
	}

	ret = stm_wait_for(priv, &priv->target_mode_abort_pending, 60,
     e4e:	8d 73 64             	lea    0x64(%ebx),%esi
     e51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_target_mode_abort_all(MPT_STM_PRIV *priv)
{
	MPT_ADAPTER		*ioc = priv->ioc;
     e58:	8b 3b                	mov    (%ebx),%edi
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
     e5a:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
     e61:	89 fa                	mov    %edi,%edx
     e63:	e8 fc ff ff ff       	call   e64 <mptstm_remove+0x154>

	sBUG_ON(mf == NULL);
     e68:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
     e6a:	89 c1                	mov    %eax,%ecx

	sBUG_ON(mf == NULL);
     e6c:	0f 84 26 01 00 00    	je     f98 <mptstm_remove+0x288>
	TargetModeAbort_t	*req;
	int ret;
	TRACE_ENTRY();

	req = (TargetModeAbort_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
     e72:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
     e78:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
     e7f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
     e86:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
     e8d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

	req->AbortType = TARGET_MODE_ABORT_TYPE_ALL_CMD_BUFFERS;
	req->Function = MPI_FUNCTION_TARGET_MODE_ABORT;
     e94:	c6 40 03 0d          	movb   $0xd,0x3(%eax)

	priv->target_mode_abort_pending = 1;

	if (IsScsi(priv)) {
     e98:	8b 03                	mov    (%ebx),%eax
	memset(req, 0, sizeof(*req));

	req->AbortType = TARGET_MODE_ABORT_TYPE_ALL_CMD_BUFFERS;
	req->Function = MPI_FUNCTION_TARGET_MODE_ABORT;

	priv->target_mode_abort_pending = 1;
     e9a:	c7 43 64 01 00 00 00 	movl   $0x1,0x64(%ebx)

	if (IsScsi(priv)) {
     ea1:	80 b8 69 03 00 00 01 	cmpb   $0x1,0x369(%eax)
		mpt_send_handshake_request(stm_context, _IOC_ID,
     ea8:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
	req->AbortType = TARGET_MODE_ABORT_TYPE_ALL_CMD_BUFFERS;
	req->Function = MPI_FUNCTION_TARGET_MODE_ABORT;

	priv->target_mode_abort_pending = 1;

	if (IsScsi(priv)) {
     eaf:	74 61                	je     f12 <mptstm_remove+0x202>
		mpt_send_handshake_request(stm_context, _IOC_ID,
					   sizeof(*req), (u32 *)req _HS_SLEEP);
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     eb1:	89 fa                	mov    %edi,%edx
     eb3:	e8 fc ff ff ff       	call   eb4 <mptstm_remove+0x1a4>
	}

	ret = stm_wait_for(priv, &priv->target_mode_abort_pending, 60,
     eb8:	89 f2                	mov    %esi,%edx
     eba:	b9 3c 00 00 00       	mov    $0x3c,%ecx
     ebf:	89 d8                	mov    %ebx,%eax
     ec1:	e8 1a fa ff ff       	call   8e0 <stm_wait_for.constprop.52>

	while (1) {
		stm_target_mode_abort_all(priv);

		n = 0;
		for (i = 0; i < priv->num_cmd_buffers; i++)
     ec6:	8b 7b 14             	mov    0x14(%ebx),%edi
	}

	while (1) {
		stm_target_mode_abort_all(priv);

		n = 0;
     ec9:	31 d2                	xor    %edx,%edx
		for (i = 0; i < priv->num_cmd_buffers; i++)
     ecb:	85 ff                	test   %edi,%edi
     ecd:	7e 1f                	jle    eee <mptstm_remove+0x1de>
     ecf:	31 c9                	xor    %ecx,%ecx
     ed1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			if (priv->io_state[i] & IO_STATE_POSTED)
     ed8:	8d 41 28             	lea    0x28(%ecx),%eax
     edb:	8b 04 83             	mov    (%ebx,%eax,4),%eax
     ede:	83 e0 01             	and    $0x1,%eax
				n++;
     ee1:	83 f8 01             	cmp    $0x1,%eax
     ee4:	83 da ff             	sbb    $0xffffffff,%edx

	while (1) {
		stm_target_mode_abort_all(priv);

		n = 0;
		for (i = 0; i < priv->num_cmd_buffers; i++)
     ee7:	83 c1 01             	add    $0x1,%ecx
     eea:	39 f9                	cmp    %edi,%ecx
     eec:	75 ea                	jne    ed8 <mptstm_remove+0x1c8>
			if (priv->io_state[i] & IO_STATE_POSTED)
				n++;

		if (n == priv->num_cmd_buffers)
     eee:	39 d7                	cmp    %edx,%edi
     ef0:	74 39                	je     f2b <mptstm_remove+0x21b>
			break;

		TRACE_DBG("%s: %d out of %d commands still active, waiting...",
			  ioc->name, n, priv->num_cmd_buffers);
		stm_wait(priv, 10, CAN_SLEEP);
     ef2:	89 d8                	mov    %ebx,%eax
     ef4:	e8 77 f9 ff ff       	call   870 <stm_wait.constprop.49>
     ef9:	e9 5a ff ff ff       	jmp    e58 <mptstm_remove+0x148>
	MPT_STM_PRIV *priv;

	priv = mpt_stm_priv[ioc->id];
	if (priv != NULL)
		mpt_stm_adapter_dispose(priv);
}
     efe:	83 c4 1c             	add    $0x1c,%esp
     f01:	5b                   	pop    %ebx
     f02:	5e                   	pop    %esi
     f03:	5f                   	pop    %edi
     f04:	5d                   	pop    %ebp
     f05:	c3                   	ret    
		if (n == 0)
			break;

		TRACE_DBG("%s: %d out of %d commands being auto-reposted, waiting...",
			  ioc->name, n, priv->num_cmd_buffers);
		stm_wait(priv, 10, CAN_SLEEP);
     f06:	89 d8                	mov    %ebx,%eax
     f08:	e8 63 f9 ff ff       	call   870 <stm_wait.constprop.49>
     f0d:	e9 12 ff ff ff       	jmp    e24 <mptstm_remove+0x114>
	req->Function = MPI_FUNCTION_TARGET_MODE_ABORT;

	priv->target_mode_abort_pending = 1;

	if (IsScsi(priv)) {
		mpt_send_handshake_request(stm_context, _IOC_ID,
     f12:	89 0c 24             	mov    %ecx,(%esp)
     f15:	89 fa                	mov    %edi,%edx
     f17:	b9 14 00 00 00       	mov    $0x14,%ecx
     f1c:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
     f23:	00 
     f24:	e8 fc ff ff ff       	call   f25 <mptstm_remove+0x215>
     f29:	eb 8d                	jmp    eb8 <mptstm_remove+0x1a8>
	ioc = priv->ioc;

	if (mpt_GetIocState(ioc, 1) == MPI_IOC_STATE_OPERATIONAL) {
		if (priv->enable_target_mode && priv->tgt->target_enable) {
			stm_target_mode_abort(priv);
			if (IsFc(priv))
     f2b:	8b 33                	mov    (%ebx),%esi
     f2d:	80 be 69 03 00 00 10 	cmpb   $0x10,0x369(%esi)
     f34:	0f 85 1f fe ff ff    	jne    d59 <mptstm_remove+0x49>
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
     f3a:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
     f41:	89 f2                	mov    %esi,%edx
     f43:	e8 fc ff ff ff       	call   f44 <mptstm_remove+0x234>

	sBUG_ON(mf == NULL);
     f48:	85 c0                	test   %eax,%eax
     f4a:	74 4c                	je     f98 <mptstm_remove+0x288>
	req->AbortType = FC_ABORT_TYPE_ALL_FC_BUFFERS;
	req->Function = MPI_FUNCTION_FC_ABORT;

	priv->link_serv_abort_pending = 1;

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     f4c:	0f b6 3d 14 00 00 00 	movzbl 0x14,%edi
     f53:	89 c1                	mov    %eax,%ecx
     f55:	89 f2                	mov    %esi,%edx
	int ret;

	TRACE_ENTRY();

	req = (FcAbortRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
     f57:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
     f5d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
     f64:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
     f6b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	req->AbortType = FC_ABORT_TYPE_ALL_FC_BUFFERS;
	req->Function = MPI_FUNCTION_FC_ABORT;
     f72:	c6 40 03 11          	movb   $0x11,0x3(%eax)

	priv->link_serv_abort_pending = 1;

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     f76:	89 f8                	mov    %edi,%eax
	memset(req, 0, sizeof(*req));

	req->AbortType = FC_ABORT_TYPE_ALL_FC_BUFFERS;
	req->Function = MPI_FUNCTION_FC_ABORT;

	priv->link_serv_abort_pending = 1;
     f78:	c7 43 68 01 00 00 00 	movl   $0x1,0x68(%ebx)

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
     f7f:	e8 fc ff ff ff       	call   f80 <mptstm_remove+0x270>

	ret = stm_wait_for(priv, &priv->link_serv_abort_pending, 60, NO_SLEEP);
     f84:	8d 53 68             	lea    0x68(%ebx),%edx
     f87:	b9 3c 00 00 00       	mov    $0x3c,%ecx
     f8c:	89 d8                	mov    %ebx,%eax
     f8e:	e8 4d f9 ff ff       	call   8e0 <stm_wait_for.constprop.52>
     f93:	e9 c1 fd ff ff       	jmp    d59 <mptstm_remove+0x49>
     f98:	e8 11 00 00 00       	call   fae <mptstm_remove+0x29e>
				  void *vaddr, dma_addr_t bus,
				  struct dma_attrs *attrs)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	WARN_ON(irqs_disabled());       /* for portability */
     f9d:	ba a6 00 00 00       	mov    $0xa6,%edx
     fa2:	b8 54 03 00 00       	mov    $0x354,%eax
     fa7:	e8 fc ff ff ff       	call   fa8 <mptstm_remove+0x298>
     fac:	e9 f2 fd ff ff       	jmp    da3 <mptstm_remove+0x93>
     fb1:	eb 0d                	jmp    fc0 <stm_send_target_status>
     fb3:	90                   	nop
     fb4:	90                   	nop
     fb5:	90                   	nop
     fb6:	90                   	nop
     fb7:	90                   	nop
     fb8:	90                   	nop
     fb9:	90                   	nop
     fba:	90                   	nop
     fbb:	90                   	nop
     fbc:	90                   	nop
     fbd:	90                   	nop
     fbe:	90                   	nop
     fbf:	90                   	nop

00000fc0 <stm_send_target_status>:
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_send_target_status(MPT_STM_PRIV *priv, u32 reply_word, int index,
				  int flags, int lun, int tag)
{
     fc0:	55                   	push   %ebp
     fc1:	89 e5                	mov    %esp,%ebp
     fc3:	57                   	push   %edi
     fc4:	56                   	push   %esi
     fc5:	53                   	push   %ebx
     fc6:	83 ec 24             	sub    $0x24,%esp
     fc9:	e8 fc ff ff ff       	call   fca <stm_send_target_status+0xa>
     fce:	89 c6                	mov    %eax,%esi
	MPT_ADAPTER			*ioc = priv->ioc;
     fd0:	8b 00                	mov    (%eax),%eax
static inline MPT_FRAME_HDR *mpt_msg_frame_alloc(MPT_ADAPTER *ioc, int index)
{
	MPT_STM_PRIV *priv = mpt_stm_priv[ioc->id];
	MPT_FRAME_HDR *mf;

	if (index != -1) {
     fd2:	83 f9 ff             	cmp    $0xffffffff,%ecx
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_send_target_status(MPT_STM_PRIV *priv, u32 reply_word, int index,
				  int flags, int lun, int tag)
{
     fd5:	89 55 ec             	mov    %edx,-0x14(%ebp)
     fd8:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	MPT_ADAPTER			*ioc = priv->ioc;
     fdb:	89 45 e8             	mov    %eax,-0x18(%ebp)
	}
}

static inline MPT_FRAME_HDR *mpt_msg_frame_alloc(MPT_ADAPTER *ioc, int index)
{
	MPT_STM_PRIV *priv = mpt_stm_priv[ioc->id];
     fde:	8b 00                	mov    (%eax),%eax
     fe0:	8b 04 85 20 00 00 00 	mov    0x20(,%eax,4),%eax
	MPT_FRAME_HDR *mf;

	if (index != -1) {
     fe7:	0f 84 1a 04 00 00    	je     1407 <stm_send_target_status+0x447>
     fed:	8d 3c 88             	lea    (%eax,%ecx,4),%edi
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
     ff0:	8b 9f a0 03 00 00    	mov    0x3a0(%edi),%ebx
     ff6:	85 db                	test   %ebx,%ebx
     ff8:	0f 85 f5 03 00 00    	jne    13f3 <stm_send_target_status+0x433>
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
     ffe:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    1005:	8b 55 e8             	mov    -0x18(%ebp),%edx
    1008:	e8 fc ff ff ff       	call   1009 <stm_send_target_status+0x49>

	sBUG_ON(mf == NULL);
    100d:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    100f:	89 c3                	mov    %eax,%ebx

	sBUG_ON(mf == NULL);
    1011:	0f 84 09 04 00 00    	je     1420 <stm_send_target_status+0x460>

	if (index != -1)
		priv->current_mf[index] = mf;
    1017:	89 9f a0 03 00 00    	mov    %ebx,0x3a0(%edi)
	int				init_index;
	dma_addr_t			dma_addr;

	TRACE_ENTRY();
	req = (TargetStatusSendRequest_t *)mpt_msg_frame_alloc(ioc, index);
	memset(req, 0, sizeof(*req));
    101d:	f6 c3 01             	test   $0x1,%bl
    1020:	89 df                	mov    %ebx,%edi
    1022:	ba 24 00 00 00       	mov    $0x24,%edx
    1027:	0f 85 6b 03 00 00    	jne    1398 <stm_send_target_status+0x3d8>
    102d:	f7 c7 02 00 00 00    	test   $0x2,%edi
    1033:	0f 85 77 03 00 00    	jne    13b0 <stm_send_target_status+0x3f0>
    1039:	89 d1                	mov    %edx,%ecx
    103b:	31 c0                	xor    %eax,%eax
    103d:	c1 e9 02             	shr    $0x2,%ecx
    1040:	f6 c2 02             	test   $0x2,%dl
    1043:	f3 ab                	rep stos %eax,%es:(%edi)
    1045:	0f 85 dd 01 00 00    	jne    1228 <stm_send_target_status+0x268>
    104b:	83 e2 01             	and    $0x1,%edx
    104e:	0f 85 bc 01 00 00    	jne    1210 <stm_send_target_status+0x250>

	if (priv->exiting) {
    1054:	8b 86 80 00 00 00    	mov    0x80(%esi),%eax
    105a:	85 c0                	test   %eax,%eax
    105c:	74 1c                	je     107a <stm_send_target_status+0xba>
    105e:	8b 45 f0             	mov    -0x10(%ebp),%eax
		flags &= ~TARGET_ASSIST_FLAGS_REPOST_CMD_BUFFER;
    1061:	81 65 08 7f ff ff ff 	andl   $0xffffff7f,0x8(%ebp)
    1068:	8d 14 86             	lea    (%esi,%eax,4),%edx
		priv->io_state[index] &= ~IO_STATE_AUTO_REPOST;
    106b:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
    1071:	83 e0 df             	and    $0xffffffdf,%eax
    1074:	89 82 a0 00 00 00    	mov    %eax,0xa0(%edx)
    107a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    107d:	8d 0c 86             	lea    (%esi,%eax,4),%ecx
	}

	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
    1080:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
    1086:	a8 80                	test   $0x80,%al
    1088:	74 16                	je     10a0 <stm_send_target_status+0xe0>
		flags |= TARGET_STATUS_SEND_FLAGS_HIGH_PRIORITY;
		flags |= TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER;
		priv->io_state[index] |= IO_STATE_AUTO_REPOST;
    108a:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
		priv->io_state[index] &= ~IO_STATE_AUTO_REPOST;
	}

	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
		flags |= TARGET_STATUS_SEND_FLAGS_HIGH_PRIORITY;
		flags |= TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER;
    1090:	81 4d 08 84 00 00 00 	orl    $0x84,0x8(%ebp)
		priv->io_state[index] |= IO_STATE_AUTO_REPOST;
    1097:	83 c8 20             	or     $0x20,%eax
    109a:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
		  }*/
	}

	cmd = priv->hw->cmd_buf + index;

	if (flags & TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS) {
    10a0:	f6 45 08 01          	testb  $0x1,0x8(%ebp)
		  if (init != NULL && init->confirm_capable) {
		  flags |= TARGET_STATUS_SEND_FLAGS_CONFIRMED;
		  }*/
	}

	cmd = priv->hw->cmd_buf + index;
    10a4:	8b 46 20             	mov    0x20(%esi),%eax

	if (flags & TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS) {
    10a7:	74 5f                	je     1108 <stm_send_target_status+0x148>
			}
		}
		req->StatusCode = (u8)status;
	}

	req->StatusFlags = (u8)flags;
    10a9:	0f b6 45 08          	movzbl 0x8(%ebp),%eax

	cmd = priv->hw->cmd_buf + index;

	if (flags & TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS) {
		length = 0;
		req->StatusCode = 0;
    10ad:	c6 03 00             	movb   $0x0,(%ebx)
		}
		req->StatusCode = (u8)status;
	}

	req->StatusFlags = (u8)flags;
	req->Function = MPI_FUNCTION_TARGET_STATUS_SEND;
    10b0:	c6 43 03 0c          	movb   $0xc,0x3(%ebx)
			}
		}
		req->StatusCode = (u8)status;
	}

	req->StatusFlags = (u8)flags;
    10b4:	88 43 01             	mov    %al,0x1(%ebx)
	req->Function = MPI_FUNCTION_TARGET_STATUS_SEND;
	req->QueueTag = (u16)tag;
    10b7:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
    10bb:	66 89 43 04          	mov    %ax,0x4(%ebx)
	req->ReplyWord = cpu_to_le32(reply_word);
    10bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    10c2:	89 43 0c             	mov    %eax,0xc(%ebx)
	req->LUN[0] = (u8)(lun >> 8);
    10c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    10c8:	c1 f8 08             	sar    $0x8,%eax
    10cb:	88 43 10             	mov    %al,0x10(%ebx)
	req->LUN[1] = (u8)lun;
    10ce:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    10d2:	88 43 11             	mov    %al,0x11(%ebx)

	/*
	 *  there's a limitation here -- if target data is outstanding, we must
	 *  wait for it to finish before we send the target status
	 */
	if (priv->io_state[index] & IO_STATE_DATA_SENT) {
    10d5:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
    10db:	a8 02                	test   $0x2,%al
    10dd:	0f 84 e4 00 00 00    	je     11c7 <stm_send_target_status+0x207>
		priv->status_deferred_mf[index] = (MPT_FRAME_HDR *)req;
		priv->io_state[index] |= IO_STATE_STATUS_DEFERRED;
    10e3:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
	/*
	 *  there's a limitation here -- if target data is outstanding, we must
	 *  wait for it to finish before we send the target status
	 */
	if (priv->io_state[index] & IO_STATE_DATA_SENT) {
		priv->status_deferred_mf[index] = (MPT_FRAME_HDR *)req;
    10e9:	89 99 a0 05 00 00    	mov    %ebx,0x5a0(%ecx)
		priv->io_state[index] |= IO_STATE_STATUS_DEFERRED;
    10ef:	83 c8 08             	or     $0x8,%eax
    10f2:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
	}
	TRACE_EXIT_RES(1);
	return 1;
}
    10f8:	83 c4 24             	add    $0x24,%esp
    10fb:	b8 01 00 00 00       	mov    $0x1,%eax
    1100:	5b                   	pop    %ebx
    1101:	5e                   	pop    %esi
    1102:	5f                   	pop    %edi
    1103:	5d                   	pop    %ebp
    1104:	c3                   	ret    
    1105:	8d 76 00             	lea    0x0(%esi),%esi
		  if (init != NULL && init->confirm_capable) {
		  flags |= TARGET_STATUS_SEND_FLAGS_CONFIRMED;
		  }*/
	}

	cmd = priv->hw->cmd_buf + index;
    1108:	69 7d f0 f0 03 00 00 	imul   $0x3f0,-0x10(%ebp),%edi
    110f:	01 c7                	add    %eax,%edi
	if (flags & TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS) {
		length = 0;
		req->StatusCode = 0;
	} else {
		length = 0;
		if (IsScsi(priv)) {
    1111:	8b 06                	mov    (%esi),%eax
    1113:	0f b6 80 69 03 00 00 	movzbl 0x369(%eax),%eax
    111a:	3c 01                	cmp    $0x1,%al
    111c:	0f 84 4e 01 00 00    	je     1270 <stm_send_target_status+0x2b0>
				atomic_set(&priv->pending_sense[init_index],
					   MPT_STATUS_SENSE_ATTEMPT);
			}
			if (rsp->Valid & SCSI_RSP_LEN_VALID)
				length += be32_to_cpu(rsp->PktFailuresListLength);
		} else if (IsSas(priv)) {
    1122:	3c 30                	cmp    $0x30,%al
    1124:	0f 84 36 02 00 00    	je     1360 <stm_send_target_status+0x3a0>
		} else {
			FCP_RSP	*rsp = (FCP_RSP *)cmd->rsp;

			length += sizeof(*rsp);
			length -= sizeof(rsp->FcpSenseData) + sizeof(rsp->FcpResponseData);
			status = rsp->FcpStatus;
    112a:	0f b6 47 4b          	movzbl 0x4b(%edi),%eax
			if (flags & TARGET_STATUS_SEND_FLAGS_CONFIRMED)
    112e:	f6 45 08 08          	testb  $0x8,0x8(%ebp)
		} else {
			FCP_RSP	*rsp = (FCP_RSP *)cmd->rsp;

			length += sizeof(*rsp);
			length -= sizeof(rsp->FcpSenseData) + sizeof(rsp->FcpResponseData);
			status = rsp->FcpStatus;
    1132:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (flags & TARGET_STATUS_SEND_FLAGS_CONFIRMED)
				rsp->FcpFlags |= FCP_REQUEST_CONFIRM;
    1135:	0f b6 47 4a          	movzbl 0x4a(%edi),%eax
			FCP_RSP	*rsp = (FCP_RSP *)cmd->rsp;

			length += sizeof(*rsp);
			length -= sizeof(rsp->FcpSenseData) + sizeof(rsp->FcpResponseData);
			status = rsp->FcpStatus;
			if (flags & TARGET_STATUS_SEND_FLAGS_CONFIRMED)
    1139:	74 06                	je     1141 <stm_send_target_status+0x181>
				rsp->FcpFlags |= FCP_REQUEST_CONFIRM;
    113b:	83 c8 10             	or     $0x10,%eax
    113e:	88 47 4a             	mov    %al,0x4a(%edi)
			if (rsp->FcpFlags & FCP_SENSE_LEN_VALID)
    1141:	a8 02                	test   $0x2,%al
				length += be32_to_cpu(rsp->ResponseDataLength);
		} else {
			FCP_RSP	*rsp = (FCP_RSP *)cmd->rsp;

			length += sizeof(*rsp);
			length -= sizeof(rsp->FcpSenseData) + sizeof(rsp->FcpResponseData);
    1143:	c7 45 e4 18 00 00 00 	movl   $0x18,-0x1c(%ebp)
			status = rsp->FcpStatus;
			if (flags & TARGET_STATUS_SEND_FLAGS_CONFIRMED)
				rsp->FcpFlags |= FCP_REQUEST_CONFIRM;
			if (rsp->FcpFlags & FCP_SENSE_LEN_VALID)
    114a:	74 0b                	je     1157 <stm_send_target_status+0x197>
    114c:	8b 57 50             	mov    0x50(%edi),%edx
    114f:	0f ca                	bswap  %edx
				length += be32_to_cpu(rsp->FcpSenseLength);
    1151:	83 c2 18             	add    $0x18,%edx
    1154:	89 55 e4             	mov    %edx,-0x1c(%ebp)
			if (rsp->FcpFlags & FCP_RSP_LEN_VALID) {
    1157:	a8 01                	test   $0x1,%al
    1159:	0f 85 f9 00 00 00    	jne    1258 <stm_send_target_status+0x298>
				/* and Task Mgmt responses can't be confirmed */
				rsp->FcpFlags &= ~FCP_REQUEST_CONFIRM;
				flags &= ~TARGET_STATUS_SEND_FLAGS_CONFIRMED;
			}
		}
		req->StatusCode = (u8)status;
    115f:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
	req->Function = MPI_FUNCTION_TARGET_STATUS_SEND;
	req->QueueTag = (u16)tag;
	req->ReplyWord = cpu_to_le32(reply_word);
	req->LUN[0] = (u8)(lun >> 8);
	req->LUN[1] = (u8)lun;
	if (length != 0) {
    1163:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		}
		req->StatusCode = (u8)status;
	}

	req->StatusFlags = (u8)flags;
	req->Function = MPI_FUNCTION_TARGET_STATUS_SEND;
    1166:	c6 43 03 0c          	movb   $0xc,0x3(%ebx)
				/* and Task Mgmt responses can't be confirmed */
				rsp->FcpFlags &= ~FCP_REQUEST_CONFIRM;
				flags &= ~TARGET_STATUS_SEND_FLAGS_CONFIRMED;
			}
		}
		req->StatusCode = (u8)status;
    116a:	88 03                	mov    %al,(%ebx)
	}

	req->StatusFlags = (u8)flags;
    116c:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
    1170:	88 43 01             	mov    %al,0x1(%ebx)
	req->Function = MPI_FUNCTION_TARGET_STATUS_SEND;
	req->QueueTag = (u16)tag;
    1173:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
    1177:	66 89 43 04          	mov    %ax,0x4(%ebx)
	req->ReplyWord = cpu_to_le32(reply_word);
    117b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    117e:	89 43 0c             	mov    %eax,0xc(%ebx)
	req->LUN[0] = (u8)(lun >> 8);
    1181:	8b 45 0c             	mov    0xc(%ebp),%eax
    1184:	c1 f8 08             	sar    $0x8,%eax
	req->LUN[1] = (u8)lun;
	if (length != 0) {
    1187:	85 d2                	test   %edx,%edx

	req->StatusFlags = (u8)flags;
	req->Function = MPI_FUNCTION_TARGET_STATUS_SEND;
	req->QueueTag = (u16)tag;
	req->ReplyWord = cpu_to_le32(reply_word);
	req->LUN[0] = (u8)(lun >> 8);
    1189:	88 43 10             	mov    %al,0x10(%ebx)
	req->LUN[1] = (u8)lun;
    118c:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1190:	88 43 11             	mov    %al,0x11(%ebx)
	if (length != 0) {
    1193:	0f 84 3c ff ff ff    	je     10d5 <stm_send_target_status+0x115>
						  MPI_SGE_FLAGS_END_OF_BUFFER |
						  MPI_SGE_FLAGS_END_OF_LIST |
						  MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
						  MPI_SGE_FLAGS_HOST_TO_IOC));
		dma_addr = priv->hw_dma +
			((u8 *)priv->hw->cmd_buf[index].rsp - (u8 *)priv->hw);
    1199:	69 45 f0 f0 03 00 00 	imul   $0x3f0,-0x10(%ebp),%eax
	req->LUN[0] = (u8)(lun >> 8);
	req->LUN[1] = (u8)lun;
	if (length != 0) {
		sge_simple = (MPT_STM_SIMPLE *)&req->StatusDataSGE;
		sge_simple->FlagsLength =
			cpu_to_le32(length |
    11a0:	81 ca 00 00 00 d7    	or     $0xd7000000,%edx
    11a6:	89 53 18             	mov    %edx,0x18(%ebx)
						  MPI_SGE_FLAGS_END_OF_BUFFER |
						  MPI_SGE_FLAGS_END_OF_LIST |
						  MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
						  MPI_SGE_FLAGS_HOST_TO_IOC));
		dma_addr = priv->hw_dma +
			((u8 *)priv->hw->cmd_buf[index].rsp - (u8 *)priv->hw);
    11a9:	83 c0 40             	add    $0x40,%eax
						  MPI_SGE_FLAGS_LAST_ELEMENT |
						  MPI_SGE_FLAGS_END_OF_BUFFER |
						  MPI_SGE_FLAGS_END_OF_LIST |
						  MPI_SGE_FLAGS_MPT_STM_ADDRESSING |
						  MPI_SGE_FLAGS_HOST_TO_IOC));
		dma_addr = priv->hw_dma +
    11ac:	99                   	cltd   
    11ad:	03 46 24             	add    0x24(%esi),%eax
    11b0:	13 56 28             	adc    0x28(%esi),%edx
			((u8 *)priv->hw->cmd_buf[index].rsp - (u8 *)priv->hw);
		stm_set_dma_addr(sge_simple->Address, dma_addr);
    11b3:	89 43 1c             	mov    %eax,0x1c(%ebx)
    11b6:	89 53 20             	mov    %edx,0x20(%ebx)

	/*
	 *  there's a limitation here -- if target data is outstanding, we must
	 *  wait for it to finish before we send the target status
	 */
	if (priv->io_state[index] & IO_STATE_DATA_SENT) {
    11b9:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
    11bf:	a8 02                	test   $0x2,%al
    11c1:	0f 85 1c ff ff ff    	jne    10e3 <stm_send_target_status+0x123>
		priv->status_deferred_mf[index] = (MPT_FRAME_HDR *)req;
		priv->io_state[index] |= IO_STATE_STATUS_DEFERRED;
		TRACE_EXIT_RES(1);
		return 1;
	}
	priv->io_state[index] |= IO_STATE_STATUS_SENT;
    11c7:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
    11cd:	83 c8 04             	or     $0x4,%eax
    11d0:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif

	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
    11d6:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
    11dc:	a8 80                	test   $0x80,%al
		mpt_send_handshake_request(stm_context, _IOC_ID,
    11de:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif

	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
    11e5:	74 59                	je     1240 <stm_send_target_status+0x280>
		mpt_send_handshake_request(stm_context, _IOC_ID,
    11e7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    11ea:	b9 24 00 00 00       	mov    $0x24,%ecx
    11ef:	89 1c 24             	mov    %ebx,(%esp)
    11f2:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    11f9:	00 
    11fa:	e8 fc ff ff ff       	call   11fb <stm_send_target_status+0x23b>
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
	}
	TRACE_EXIT_RES(1);
	return 1;
}
    11ff:	83 c4 24             	add    $0x24,%esp
    1202:	b8 01 00 00 00       	mov    $0x1,%eax
    1207:	5b                   	pop    %ebx
    1208:	5e                   	pop    %esi
    1209:	5f                   	pop    %edi
    120a:	5d                   	pop    %ebp
    120b:	c3                   	ret    
    120c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int				init_index;
	dma_addr_t			dma_addr;

	TRACE_ENTRY();
	req = (TargetStatusSendRequest_t *)mpt_msg_frame_alloc(ioc, index);
	memset(req, 0, sizeof(*req));
    1210:	c6 07 00             	movb   $0x0,(%edi)

	if (priv->exiting) {
    1213:	8b 86 80 00 00 00    	mov    0x80(%esi),%eax
    1219:	85 c0                	test   %eax,%eax
    121b:	0f 84 59 fe ff ff    	je     107a <stm_send_target_status+0xba>
    1221:	e9 38 fe ff ff       	jmp    105e <stm_send_target_status+0x9e>
    1226:	66 90                	xchg   %ax,%ax
	int				init_index;
	dma_addr_t			dma_addr;

	TRACE_ENTRY();
	req = (TargetStatusSendRequest_t *)mpt_msg_frame_alloc(ioc, index);
	memset(req, 0, sizeof(*req));
    1228:	31 c0                	xor    %eax,%eax
    122a:	83 c7 02             	add    $0x2,%edi
    122d:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    1231:	83 e2 01             	and    $0x1,%edx
    1234:	0f 84 1a fe ff ff    	je     1054 <stm_send_target_status+0x94>
    123a:	eb d4                	jmp    1210 <stm_send_target_status+0x250>
    123c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
		mpt_send_handshake_request(stm_context, _IOC_ID,
					   sizeof(*req), (u32 *)req _HS_SLEEP);
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    1240:	8b 55 e8             	mov    -0x18(%ebp),%edx
    1243:	89 d9                	mov    %ebx,%ecx
    1245:	e8 fc ff ff ff       	call   1246 <stm_send_target_status+0x286>
	}
	TRACE_EXIT_RES(1);
	return 1;
}
    124a:	83 c4 24             	add    $0x24,%esp
    124d:	b8 01 00 00 00       	mov    $0x1,%eax
    1252:	5b                   	pop    %ebx
    1253:	5e                   	pop    %esi
    1254:	5f                   	pop    %edi
    1255:	5d                   	pop    %ebp
    1256:	c3                   	ret    
    1257:	90                   	nop
    1258:	8b 57 54             	mov    0x54(%edi),%edx
				length += be32_to_cpu(rsp->FcpSenseLength);
			if (rsp->FcpFlags & FCP_RSP_LEN_VALID) {
				length += be32_to_cpu(rsp->FcpResponseLength);
				/* FCP_RSP_LEN_VALID will only be set for Task Mgmt responses */
				/* and Task Mgmt responses can't be confirmed */
				rsp->FcpFlags &= ~FCP_REQUEST_CONFIRM;
    125b:	83 e0 ef             	and    $0xffffffef,%eax
    125e:	88 47 4a             	mov    %al,0x4a(%edi)
				flags &= ~TARGET_STATUS_SEND_FLAGS_CONFIRMED;
    1261:	83 65 08 f7          	andl   $0xfffffff7,0x8(%ebp)
    1265:	0f ca                	bswap  %edx
			if (flags & TARGET_STATUS_SEND_FLAGS_CONFIRMED)
				rsp->FcpFlags |= FCP_REQUEST_CONFIRM;
			if (rsp->FcpFlags & FCP_SENSE_LEN_VALID)
				length += be32_to_cpu(rsp->FcpSenseLength);
			if (rsp->FcpFlags & FCP_RSP_LEN_VALID) {
				length += be32_to_cpu(rsp->FcpResponseLength);
    1267:	01 55 e4             	add    %edx,-0x1c(%ebp)
    126a:	e9 f0 fe ff ff       	jmp    115f <stm_send_target_status+0x19f>
    126f:	90                   	nop
			SCSI_RSP	*rsp = (SCSI_RSP *)cmd->rsp;
			size_t sense_size;

			length += sizeof(*rsp);
			length -= sizeof(rsp->SenseData);
			status = rsp->Status;
    1270:	0f b6 47 43          	movzbl 0x43(%edi),%eax
    1274:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (rsp->Valid & SCSI_SENSE_LEN_VALID) {
    1277:	0f b6 47 42          	movzbl 0x42(%edi),%eax
    127b:	a8 02                	test   $0x2,%al
    127d:	0f 84 45 01 00 00    	je     13c8 <stm_send_target_status+0x408>
    1283:	8b 57 44             	mov    0x44(%edi),%edx
    1286:	0f ca                	bswap  %edx
				length += be32_to_cpu(rsp->SenseDataListLength);
    1288:	8d 42 0c             	lea    0xc(%edx),%eax
    128b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				init_index = GET_INITIATOR_INDEX(reply_word);
    128e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1291:	25 00 c0 ff 03       	and    $0x3ffc000,%eax
    1296:	89 45 d8             	mov    %eax,-0x28(%ebp)
				/*
				 *  try to avoid a SCSI firmware bug by not using Auto Repost
				 *  here, unless required (High Priority requires it)
				 */
				if (!(priv->io_state[index] & IO_STATE_HIGH_PRIORITY)) {
    1299:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
			length += sizeof(*rsp);
			length -= sizeof(rsp->SenseData);
			status = rsp->Status;
			if (rsp->Valid & SCSI_SENSE_LEN_VALID) {
				length += be32_to_cpu(rsp->SenseDataListLength);
				init_index = GET_INITIATOR_INDEX(reply_word);
    129f:	c1 6d d8 0e          	shrl   $0xe,-0x28(%ebp)
				/*
				 *  try to avoid a SCSI firmware bug by not using Auto Repost
				 *  here, unless required (High Priority requires it)
				 */
				if (!(priv->io_state[index] & IO_STATE_HIGH_PRIORITY)) {
    12a3:	a8 80                	test   $0x80,%al
    12a5:	0f 84 2d 01 00 00    	je     13d8 <stm_send_target_status+0x418>
				 * MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT IOCStatus)
				 */
				sense_size = min(sizeof(rsp->SenseData),
						 (size_t)SCSI_SENSE_BUFFERSIZE);
				TRACE_DBG("caching %zd bytes pending sense", sense_size);
				memcpy(priv->pending_sense_buffer[init_index],
    12ab:	8b 45 d8             	mov    -0x28(%ebp),%eax
    12ae:	8d 57 4c             	lea    0x4c(%edi),%edx
    12b1:	89 55 dc             	mov    %edx,-0x24(%ebp)
    12b4:	8b 57 4c             	mov    0x4c(%edi),%edx
    12b7:	8d 04 40             	lea    (%eax,%eax,2),%eax
    12ba:	c1 e0 05             	shl    $0x5,%eax
    12bd:	8d 84 06 50 0e 00 00 	lea    0xe50(%esi,%eax,1),%eax
    12c4:	89 10                	mov    %edx,(%eax)
    12c6:	8b 55 dc             	mov    -0x24(%ebp),%edx
    12c9:	8b 52 04             	mov    0x4(%edx),%edx
    12cc:	89 50 04             	mov    %edx,0x4(%eax)
    12cf:	8b 55 dc             	mov    -0x24(%ebp),%edx
    12d2:	8b 52 08             	mov    0x8(%edx),%edx
    12d5:	89 50 08             	mov    %edx,0x8(%eax)
    12d8:	8b 55 dc             	mov    -0x24(%ebp),%edx
    12db:	8b 52 0c             	mov    0xc(%edx),%edx
    12de:	89 50 0c             	mov    %edx,0xc(%eax)
    12e1:	8b 55 dc             	mov    -0x24(%ebp),%edx
    12e4:	8b 52 10             	mov    0x10(%edx),%edx
    12e7:	89 50 10             	mov    %edx,0x10(%eax)
    12ea:	8b 55 dc             	mov    -0x24(%ebp),%edx
    12ed:	8b 52 14             	mov    0x14(%edx),%edx
    12f0:	89 50 14             	mov    %edx,0x14(%eax)
    12f3:	8b 55 dc             	mov    -0x24(%ebp),%edx
    12f6:	8b 52 18             	mov    0x18(%edx),%edx
    12f9:	89 50 18             	mov    %edx,0x18(%eax)
    12fc:	8b 55 dc             	mov    -0x24(%ebp),%edx
    12ff:	8b 52 1c             	mov    0x1c(%edx),%edx
    1302:	89 50 1c             	mov    %edx,0x1c(%eax)
    1305:	8b 55 dc             	mov    -0x24(%ebp),%edx
    1308:	8b 52 20             	mov    0x20(%edx),%edx
    130b:	89 50 20             	mov    %edx,0x20(%eax)
    130e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    1311:	8b 52 24             	mov    0x24(%edx),%edx
    1314:	89 50 24             	mov    %edx,0x24(%eax)
    1317:	8b 55 dc             	mov    -0x24(%ebp),%edx
    131a:	8b 52 28             	mov    0x28(%edx),%edx
    131d:	89 50 28             	mov    %edx,0x28(%eax)
    1320:	8b 55 dc             	mov    -0x24(%ebp),%edx
    1323:	8b 52 2c             	mov    0x2c(%edx),%edx
    1326:	89 50 2c             	mov    %edx,0x2c(%eax)
    1329:	8b 55 dc             	mov    -0x24(%ebp),%edx
    132c:	8b 52 30             	mov    0x30(%edx),%edx
    132f:	89 50 30             	mov    %edx,0x30(%eax)
 *
 * Atomically sets the value of @v to @i.
 */
static inline void atomic_set(atomic_t *v, int i)
{
	v->counter = i;
    1332:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1335:	c7 84 86 10 0e 00 00 	movl   $0x1,0xe10(%esi,%eax,4)
    133c:	01 00 00 00 
    1340:	0f b6 47 42          	movzbl 0x42(%edi),%eax
					     priv->pending_sense_buffer[init_index],
					     sense_size);
				atomic_set(&priv->pending_sense[init_index],
					   MPT_STATUS_SENSE_ATTEMPT);
			}
			if (rsp->Valid & SCSI_RSP_LEN_VALID)
    1344:	a8 01                	test   $0x1,%al
    1346:	0f 84 13 fe ff ff    	je     115f <stm_send_target_status+0x19f>
    134c:	8b 47 48             	mov    0x48(%edi),%eax
    134f:	0f c8                	bswap  %eax
				length += be32_to_cpu(rsp->PktFailuresListLength);
    1351:	01 45 e4             	add    %eax,-0x1c(%ebp)
    1354:	e9 06 fe ff ff       	jmp    115f <stm_send_target_status+0x19f>
    1359:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		} else if (IsSas(priv)) {
			SSP_RSP	*rsp = (SSP_RSP *)cmd->rsp;

			length += sizeof(*rsp);
			length -= sizeof(rsp->ResponseSenseData);
			status = rsp->Status;
    1360:	0f b6 47 63          	movzbl 0x63(%edi),%eax
				length += be32_to_cpu(rsp->PktFailuresListLength);
		} else if (IsSas(priv)) {
			SSP_RSP	*rsp = (SSP_RSP *)cmd->rsp;

			length += sizeof(*rsp);
			length -= sizeof(rsp->ResponseSenseData);
    1364:	c7 45 e4 30 00 00 00 	movl   $0x30,-0x1c(%ebp)
			status = rsp->Status;
    136b:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (rsp->DataPres & SSP_SENSE_LEN_VALID)
    136e:	0f b6 47 62          	movzbl 0x62(%edi),%eax
    1372:	a8 02                	test   $0x2,%al
    1374:	74 0b                	je     1381 <stm_send_target_status+0x3c1>
    1376:	8b 57 68             	mov    0x68(%edi),%edx
    1379:	0f ca                	bswap  %edx
				length += be32_to_cpu(rsp->SenseDataLength);
    137b:	83 c2 30             	add    $0x30,%edx
    137e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
			if (rsp->DataPres & SSP_RSP_LEN_VALID)
    1381:	a8 01                	test   $0x1,%al
    1383:	0f 84 d6 fd ff ff    	je     115f <stm_send_target_status+0x19f>
    1389:	8b 47 6c             	mov    0x6c(%edi),%eax
    138c:	0f c8                	bswap  %eax
				length += be32_to_cpu(rsp->ResponseDataLength);
    138e:	01 45 e4             	add    %eax,-0x1c(%ebp)
    1391:	e9 c9 fd ff ff       	jmp    115f <stm_send_target_status+0x19f>
    1396:	66 90                	xchg   %ax,%ax
	int				init_index;
	dma_addr_t			dma_addr;

	TRACE_ENTRY();
	req = (TargetStatusSendRequest_t *)mpt_msg_frame_alloc(ioc, index);
	memset(req, 0, sizeof(*req));
    1398:	8d 7b 01             	lea    0x1(%ebx),%edi
    139b:	b2 23                	mov    $0x23,%dl
    139d:	f7 c7 02 00 00 00    	test   $0x2,%edi
    13a3:	c6 03 00             	movb   $0x0,(%ebx)
    13a6:	0f 84 8d fc ff ff    	je     1039 <stm_send_target_status+0x79>
    13ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    13b0:	31 c9                	xor    %ecx,%ecx
    13b2:	83 c7 02             	add    $0x2,%edi
    13b5:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    13b9:	83 ea 02             	sub    $0x2,%edx
    13bc:	e9 78 fc ff ff       	jmp    1039 <stm_send_target_status+0x79>
    13c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (IsScsi(priv)) {
			SCSI_RSP	*rsp = (SCSI_RSP *)cmd->rsp;
			size_t sense_size;

			length += sizeof(*rsp);
			length -= sizeof(rsp->SenseData);
    13c8:	c7 45 e4 0c 00 00 00 	movl   $0xc,-0x1c(%ebp)
    13cf:	e9 70 ff ff ff       	jmp    1344 <stm_send_target_status+0x384>
    13d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				 *  try to avoid a SCSI firmware bug by not using Auto Repost
				 *  here, unless required (High Priority requires it)
				 */
				if (!(priv->io_state[index] & IO_STATE_HIGH_PRIORITY)) {
					flags &= ~TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER;
					priv->io_state[index] &= ~IO_STATE_AUTO_REPOST;
    13d8:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
				/*
				 *  try to avoid a SCSI firmware bug by not using Auto Repost
				 *  here, unless required (High Priority requires it)
				 */
				if (!(priv->io_state[index] & IO_STATE_HIGH_PRIORITY)) {
					flags &= ~TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER;
    13de:	81 65 08 7f ff ff ff 	andl   $0xffffff7f,0x8(%ebp)
					priv->io_state[index] &= ~IO_STATE_AUTO_REPOST;
    13e5:	83 e0 df             	and    $0xffffffdf,%eax
    13e8:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
    13ee:	e9 b8 fe ff ff       	jmp    12ab <stm_send_target_status+0x2eb>
	MPT_FRAME_HDR *mf;

	if (index != -1) {
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
    13f3:	ba 4d 01 00 00       	mov    $0x14d,%edx
    13f8:	b8 8c 01 00 00       	mov    $0x18c,%eax
    13fd:	e8 fc ff ff ff       	call   13fe <stm_send_target_status+0x43e>
    1402:	e9 f7 fb ff ff       	jmp    ffe <stm_send_target_status+0x3e>
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    1407:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    140e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    1411:	e8 fc ff ff ff       	call   1412 <stm_send_target_status+0x452>

	sBUG_ON(mf == NULL);
    1416:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    1418:	89 c3                	mov    %eax,%ebx

	sBUG_ON(mf == NULL);
    141a:	0f 85 fd fb ff ff    	jne    101d <stm_send_target_status+0x5d>
    1420:	e8 11 00 00 00       	call   1436 <stm_cmd_buf_post+0x6>
    1425:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1429:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001430 <stm_cmd_buf_post>:
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_cmd_buf_post(MPT_STM_PRIV *priv, int index)
{
    1430:	55                   	push   %ebp
    1431:	89 e5                	mov    %esp,%ebp
    1433:	57                   	push   %edi
    1434:	56                   	push   %esi
    1435:	53                   	push   %ebx
    1436:	83 ec 10             	sub    $0x10,%esp
    1439:	e8 fc ff ff ff       	call   143a <stm_cmd_buf_post+0xa>
	MPT_ADAPTER	*ioc = priv->ioc;
    143e:	8b 18                	mov    (%eax),%ebx
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_cmd_buf_post(MPT_STM_PRIV *priv, int index)
{
    1440:	89 c1                	mov    %eax,%ecx
	MPT_ADAPTER	*ioc = priv->ioc;
	TargetCmdBufferPostRequest_t *req;
	dma_addr_t	dma_addr;

	TRACE_ENTRY();
	if (priv->exiting) {
    1442:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_cmd_buf_post(MPT_STM_PRIV *priv, int index)
{
    1448:	89 d6                	mov    %edx,%esi
	MPT_ADAPTER	*ioc = priv->ioc;
	TargetCmdBufferPostRequest_t *req;
	dma_addr_t	dma_addr;

	TRACE_ENTRY();
	if (priv->exiting) {
    144a:	85 c0                	test   %eax,%eax
    144c:	0f 85 0e 01 00 00    	jne    1560 <stm_cmd_buf_post+0x130>
		priv->io_state[index] |= IO_STATE_POSTED;
		return;
	}

	if (IsSas(priv)) {
    1452:	80 bb 69 03 00 00 30 	cmpb   $0x30,0x369(%ebx)
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    1459:	89 da                	mov    %ebx,%edx
    145b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    145e:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
	if (priv->exiting) {
		priv->io_state[index] |= IO_STATE_POSTED;
		return;
	}

	if (IsSas(priv)) {
    1465:	0f 84 15 01 00 00    	je     1580 <stm_cmd_buf_post+0x150>
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    146b:	e8 fc ff ff ff       	call   146c <stm_cmd_buf_post+0x3c>

	sBUG_ON(mf == NULL);
    1470:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    1473:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    1475:	89 c2                	mov    %eax,%edx

	sBUG_ON(mf == NULL);
    1477:	0f 84 b5 01 00 00    	je     1632 <stm_cmd_buf_post+0x202>

	/*
	 *  get a free message frame, and post a command buffer
	 */
	req = (TargetCmdBufferPostRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
    147d:	a8 01                	test   $0x1,%al
    147f:	89 c7                	mov    %eax,%edi
    1481:	c7 45 f0 18 00 00 00 	movl   $0x18,-0x10(%ebp)
    1488:	0f 85 7a 01 00 00    	jne    1608 <stm_cmd_buf_post+0x1d8>
    148e:	f7 c7 02 00 00 00    	test   $0x2,%edi
    1494:	0f 85 86 01 00 00    	jne    1620 <stm_cmd_buf_post+0x1f0>
    149a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    149d:	83 e0 fc             	and    $0xfffffffc,%eax
    14a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    14a3:	31 c0                	xor    %eax,%eax
    14a5:	c7 04 07 00 00 00 00 	movl   $0x0,(%edi,%eax,1)
    14ac:	83 c0 04             	add    $0x4,%eax
    14af:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    14b2:	72 f1                	jb     14a5 <stm_cmd_buf_post+0x75>
    14b4:	01 c7                	add    %eax,%edi
    14b6:	f6 45 f0 02          	testb  $0x2,-0x10(%ebp)
    14ba:	0f 85 38 01 00 00    	jne    15f8 <stm_cmd_buf_post+0x1c8>
    14c0:	f6 45 f0 01          	testb  $0x1,-0x10(%ebp)
    14c4:	0f 85 26 01 00 00    	jne    15f0 <stm_cmd_buf_post+0x1c0>
    14ca:	8d 04 b1             	lea    (%ecx,%esi,4),%eax

#ifdef CMD_BUFFER_POST_FLAGS_HIGH_PRIORITY
	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY)
		req->BufferPostFlags = CMD_BUFFER_POST_FLAGS_HIGH_PRIORITY;
#else
	priv->io_state[index] &= ~IO_STATE_HIGH_PRIORITY;
    14cd:	8b b8 a0 00 00 00    	mov    0xa0(%eax),%edi
    14d3:	81 e7 7f ff ff ff    	and    $0xffffff7f,%edi
    14d9:	89 b8 a0 00 00 00    	mov    %edi,0xa0(%eax)
#endif

	req->BufferCount = 1;
	req->Function = MPI_FUNCTION_TARGET_CMD_BUFFER_POST;
	req->BufferLength = sizeof(priv->hw->cmd_buf[index].cmd);
	req->Buffer[0].IoIndex = cpu_to_le16(index);
    14df:	66 89 72 0c          	mov    %si,0xc(%edx)
	dma_addr = priv->hw_dma +
		((u8 *)priv->hw->cmd_buf[index].cmd - (u8 *)priv->hw);
    14e3:	69 f6 f0 03 00 00    	imul   $0x3f0,%esi,%esi
		req->BufferPostFlags = CMD_BUFFER_POST_FLAGS_HIGH_PRIORITY;
#else
	priv->io_state[index] &= ~IO_STATE_HIGH_PRIORITY;
#endif

	req->BufferCount = 1;
    14e9:	c6 42 01 01          	movb   $0x1,0x1(%edx)
	req->Function = MPI_FUNCTION_TARGET_CMD_BUFFER_POST;
    14ed:	c6 42 03 0a          	movb   $0xa,0x3(%edx)
	req->BufferLength = sizeof(priv->hw->cmd_buf[index].cmd);
    14f1:	c6 42 04 40          	movb   $0x40,0x4(%edx)
	req->Buffer[0].IoIndex = cpu_to_le16(index);
	dma_addr = priv->hw_dma +
    14f5:	89 f7                	mov    %esi,%edi
    14f7:	c1 ff 1f             	sar    $0x1f,%edi
    14fa:	03 71 24             	add    0x24(%ecx),%esi
    14fd:	13 79 28             	adc    0x28(%ecx),%edi
		((u8 *)priv->hw->cmd_buf[index].cmd - (u8 *)priv->hw);
	req->Buffer[0].u.PhysicalAddress64.Low = cpu_to_le32(dma_addr);
#if MPT_STM_64_BIT_DMA
	req->Buffer[0].u.PhysicalAddress64.High = cpu_to_le32((u64)dma_addr>>32);
	req->BufferPostFlags = CMD_BUFFER_POST_FLAGS_64_BIT_ADDR;
    1500:	c6 02 80             	movb   $0x80,(%edx)
	req->Function = MPI_FUNCTION_TARGET_CMD_BUFFER_POST;
	req->BufferLength = sizeof(priv->hw->cmd_buf[index].cmd);
	req->Buffer[0].IoIndex = cpu_to_le16(index);
	dma_addr = priv->hw_dma +
		((u8 *)priv->hw->cmd_buf[index].cmd - (u8 *)priv->hw);
	req->Buffer[0].u.PhysicalAddress64.Low = cpu_to_le32(dma_addr);
    1503:	89 72 10             	mov    %esi,0x10(%edx)
#if MPT_STM_64_BIT_DMA
	req->Buffer[0].u.PhysicalAddress64.High = cpu_to_le32((u64)dma_addr>>32);
    1506:	89 7a 14             	mov    %edi,0x14(%edx)
	req->BufferPostFlags = CMD_BUFFER_POST_FLAGS_64_BIT_ADDR;
#endif

	priv->io_state[index] |= IO_STATE_POSTED;
    1509:	8b 88 a0 00 00 00    	mov    0xa0(%eax),%ecx
    150f:	83 c9 01             	or     $0x1,%ecx
    1512:	89 88 a0 00 00 00    	mov    %ecx,0xa0(%eax)
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif

	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
    1518:	8b 88 a0 00 00 00    	mov    0xa0(%eax),%ecx
    151e:	81 e1 80 00 00 00    	and    $0x80,%ecx
    1524:	0f 84 ad 00 00 00    	je     15d7 <stm_cmd_buf_post+0x1a7>
		priv->io_state[index] &= ~IO_STATE_HIGH_PRIORITY;
    152a:	8b 88 a0 00 00 00    	mov    0xa0(%eax),%ecx
    1530:	80 e1 7f             	and    $0x7f,%cl
    1533:	89 88 a0 00 00 00    	mov    %ecx,0xa0(%eax)
		mpt_send_handshake_request(stm_context, _IOC_ID,
    1539:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    1540:	b9 18 00 00 00       	mov    $0x18,%ecx
    1545:	89 14 24             	mov    %edx,(%esp)
    1548:	89 da                	mov    %ebx,%edx
    154a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    1551:	00 
    1552:	e8 fc ff ff ff       	call   1553 <stm_cmd_buf_post+0x123>
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
	}

	TRACE_EXIT();
}
    1557:	83 c4 10             	add    $0x10,%esp
    155a:	5b                   	pop    %ebx
    155b:	5e                   	pop    %esi
    155c:	5f                   	pop    %edi
    155d:	5d                   	pop    %ebp
    155e:	c3                   	ret    
    155f:	90                   	nop
    1560:	8d 14 91             	lea    (%ecx,%edx,4),%edx
	TargetCmdBufferPostRequest_t *req;
	dma_addr_t	dma_addr;

	TRACE_ENTRY();
	if (priv->exiting) {
		priv->io_state[index] |= IO_STATE_POSTED;
    1563:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
    1569:	83 c8 01             	or     $0x1,%eax
    156c:	89 82 a0 00 00 00    	mov    %eax,0xa0(%edx)
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
	}

	TRACE_EXIT();
}
    1572:	83 c4 10             	add    $0x10,%esp
    1575:	5b                   	pop    %ebx
    1576:	5e                   	pop    %esi
    1577:	5f                   	pop    %edi
    1578:	5d                   	pop    %ebp
    1579:	c3                   	ret    
    157a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    1580:	e8 fc ff ff ff       	call   1581 <stm_cmd_buf_post+0x151>

	sBUG_ON(mf == NULL);
    1585:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    1588:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    158a:	89 c2                	mov    %eax,%edx

	sBUG_ON(mf == NULL);
    158c:	0f 84 a0 00 00 00    	je     1632 <stm_cmd_buf_post+0x202>
	MPT_ADAPTER				*ioc = priv->ioc;
	TargetCmdBufferPostListRequest_t	*req;

	TRACE_ENTRY();
	req = (TargetCmdBufferPostListRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
    1592:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    1598:	8d 0c b1             	lea    (%ecx,%esi,4),%ecx
    159b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    15a2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    15a9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    15b0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

	req->Function = MPI_FUNCTION_TARGET_CMD_BUF_LIST_POST;
    15b7:	c6 40 03 25          	movb   $0x25,0x3(%eax)
	req->CmdBufferCount = cpu_to_le16(1);
    15bb:	b8 01 00 00 00       	mov    $0x1,%eax
    15c0:	66 89 42 04          	mov    %ax,0x4(%edx)
	req->IoIndex[0] = cpu_to_le16(index);
    15c4:	66 89 72 10          	mov    %si,0x10(%edx)

	priv->io_state[index] |= IO_STATE_POSTED;
    15c8:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
    15ce:	83 c8 01             	or     $0x1,%eax
    15d1:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
		priv->io_state[index] &= ~IO_STATE_HIGH_PRIORITY;
		mpt_send_handshake_request(stm_context, _IOC_ID,
					   sizeof(*req), (u32 *)req _HS_SLEEP);
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    15d7:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
	}

	TRACE_EXIT();
}
    15de:	83 c4 10             	add    $0x10,%esp
	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
		priv->io_state[index] &= ~IO_STATE_HIGH_PRIORITY;
		mpt_send_handshake_request(stm_context, _IOC_ID,
					   sizeof(*req), (u32 *)req _HS_SLEEP);
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    15e1:	89 d1                	mov    %edx,%ecx
    15e3:	89 da                	mov    %ebx,%edx
	}

	TRACE_EXIT();
}
    15e5:	5b                   	pop    %ebx
    15e6:	5e                   	pop    %esi
    15e7:	5f                   	pop    %edi
    15e8:	5d                   	pop    %ebp
	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
		priv->io_state[index] &= ~IO_STATE_HIGH_PRIORITY;
		mpt_send_handshake_request(stm_context, _IOC_ID,
					   sizeof(*req), (u32 *)req _HS_SLEEP);
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    15e9:	e9 fc ff ff ff       	jmp    15ea <stm_cmd_buf_post+0x1ba>
    15ee:	66 90                	xchg   %ax,%ax

	/*
	 *  get a free message frame, and post a command buffer
	 */
	req = (TargetCmdBufferPostRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
    15f0:	c6 07 00             	movb   $0x0,(%edi)
    15f3:	e9 d2 fe ff ff       	jmp    14ca <stm_cmd_buf_post+0x9a>
    15f8:	31 c0                	xor    %eax,%eax
    15fa:	83 c7 02             	add    $0x2,%edi
    15fd:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    1601:	e9 ba fe ff ff       	jmp    14c0 <stm_cmd_buf_post+0x90>
    1606:	66 90                	xchg   %ax,%ax
    1608:	c6 00 00             	movb   $0x0,(%eax)
    160b:	8d 78 01             	lea    0x1(%eax),%edi
    160e:	c7 45 f0 17 00 00 00 	movl   $0x17,-0x10(%ebp)
    1615:	e9 74 fe ff ff       	jmp    148e <stm_cmd_buf_post+0x5e>
    161a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    1620:	31 c0                	xor    %eax,%eax
    1622:	83 c7 02             	add    $0x2,%edi
    1625:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    1629:	83 6d f0 02          	subl   $0x2,-0x10(%ebp)
    162d:	e9 68 fe ff ff       	jmp    149a <stm_cmd_buf_post+0x6a>
    1632:	e8 11 00 00 00       	call   1648 <stm_target_cleanup+0x8>
    1637:	89 f6                	mov    %esi,%esi
    1639:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001640 <stm_target_cleanup>:
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_target_cleanup(MPT_STM_PRIV *priv, int index)
{
    1640:	55                   	push   %ebp
    1641:	89 e5                	mov    %esp,%ebp
    1643:	57                   	push   %edi
    1644:	56                   	push   %esi
    1645:	53                   	push   %ebx
    1646:	83 ec 04             	sub    $0x4,%esp
    1649:	e8 fc ff ff ff       	call   164a <stm_target_cleanup+0xa>
	MPT_ADAPTER	*ioc = priv->ioc;
    164e:	8b 08                	mov    (%eax),%ecx
    1650:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_target_cleanup(MPT_STM_PRIV *priv, int index)
{
    1653:	89 c6                	mov    %eax,%esi
	MPT_ADAPTER	*ioc = priv->ioc;
	volatile int	*io_state;

	TRACE_ENTRY();
	io_state = priv->io_state + index;
	if (*io_state & (IO_STATE_DATA_SENT | IO_STATE_STATUS_SENT)) {
    1655:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_target_cleanup(MPT_STM_PRIV *priv, int index)
{
    165b:	89 d7                	mov    %edx,%edi
	MPT_ADAPTER	*ioc = priv->ioc;
	volatile int	*io_state;

	TRACE_ENTRY();
	io_state = priv->io_state + index;
	if (*io_state & (IO_STATE_DATA_SENT | IO_STATE_STATUS_SENT)) {
    165d:	a8 06                	test   $0x6,%al
    165f:	0f 85 b3 00 00 00    	jne    1718 <stm_target_cleanup+0xd8>
		*io_state &= ~IO_STATE_DATA_SENT;
		*io_state &= ~IO_STATE_STATUS_SENT;
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
	}
	if (*io_state & IO_STATE_STATUS_DEFERRED) {
    1665:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    166b:	a8 08                	test   $0x8,%al
    166d:	0f 85 e5 00 00 00    	jne    1758 <stm_target_cleanup+0x118>
		*io_state &= ~IO_STATE_STATUS_DEFERRED;
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->status_deferred_mf[index]);
	}
	*io_state &= ~IO_STATE_REISSUE_REQUEST;
    1673:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    1679:	80 e4 fd             	and    $0xfd,%ah
    167c:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	*io_state &= ~IO_STATE_ADJUST_OFFSET;
    1682:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    1688:	80 e4 fb             	and    $0xfb,%ah
    168b:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	*io_state &= ~IO_STATE_CONVERT_TA_TO_TSS;
    1691:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    1697:	80 e4 f7             	and    $0xf7,%ah
    169a:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	*io_state &= ~IO_STATE_REDO_COMMAND;
    16a0:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    16a6:	80 e4 ef             	and    $0xef,%ah
    16a9:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	*io_state &= ~IO_STATE_REQUEST_ABORTED;
    16af:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    16b5:	80 e4 fe             	and    $0xfe,%ah
    16b8:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	*io_state &= ~IO_STATE_INCOMPLETE;
    16be:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    16c4:	83 e0 ef             	and    $0xffffffef,%eax
    16c7:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	/*  *io_state &= ~IO_STATE_AUTO_REPOST;*/
	*io_state &= ~IO_STATE_ABORTED;
    16cd:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    16d3:	83 e0 bf             	and    $0xffffffbf,%eax
    16d6:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	*io_state &= ~IO_STATE_POSTED;
    16dc:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    16e2:	83 e0 fe             	and    $0xfffffffe,%eax
    16e5:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == IO_STATE_AUTO_REPOST)
    16eb:	8b 8b a0 00 00 00    	mov    0xa0(%ebx),%ecx
    16f1:	80 e1 7f             	and    $0x7f,%cl
    16f4:	83 f9 20             	cmp    $0x20,%ecx
    16f7:	0f 84 83 00 00 00    	je     1780 <stm_target_cleanup+0x140>
		*io_state = IO_STATE_POSTED;
	else if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == 0)
    16fd:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    1703:	a9 7f ff ff ff       	test   $0xffffff7f,%eax
    1708:	0f 84 8a 00 00 00    	je     1798 <stm_target_cleanup+0x158>
		stm_cmd_buf_post(priv, index);
	TRACE_EXIT();
}
    170e:	83 c4 04             	add    $0x4,%esp
    1711:	5b                   	pop    %ebx
    1712:	5e                   	pop    %esi
    1713:	5f                   	pop    %edi
    1714:	5d                   	pop    %ebp
    1715:	c3                   	ret    
    1716:	66 90                	xchg   %ax,%ax
	volatile int	*io_state;

	TRACE_ENTRY();
	io_state = priv->io_state + index;
	if (*io_state & (IO_STATE_DATA_SENT | IO_STATE_STATUS_SENT)) {
		*io_state &= ~IO_STATE_DATA_SENT;
    1718:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
		*io_state &= ~IO_STATE_STATUS_SENT;
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    171e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	volatile int	*io_state;

	TRACE_ENTRY();
	io_state = priv->io_state + index;
	if (*io_state & (IO_STATE_DATA_SENT | IO_STATE_STATUS_SENT)) {
		*io_state &= ~IO_STATE_DATA_SENT;
    1721:	83 e0 fd             	and    $0xfffffffd,%eax
    1724:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
		*io_state &= ~IO_STATE_STATUS_SENT;
    172a:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    1730:	83 e0 fb             	and    $0xfffffffb,%eax
    1733:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    1739:	8b 94 96 a0 03 00 00 	mov    0x3a0(%esi,%edx,4),%edx
    1740:	89 c8                	mov    %ecx,%eax
    1742:	e8 fc ff ff ff       	call   1743 <stm_target_cleanup+0x103>
	}
	if (*io_state & IO_STATE_STATUS_DEFERRED) {
    1747:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	TRACE_ENTRY();
	io_state = priv->io_state + index;
	if (*io_state & (IO_STATE_DATA_SENT | IO_STATE_STATUS_SENT)) {
		*io_state &= ~IO_STATE_DATA_SENT;
		*io_state &= ~IO_STATE_STATUS_SENT;
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    174d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	}
	if (*io_state & IO_STATE_STATUS_DEFERRED) {
    1750:	a8 08                	test   $0x8,%al
    1752:	0f 84 1b ff ff ff    	je     1673 <stm_target_cleanup+0x33>
		*io_state &= ~IO_STATE_STATUS_DEFERRED;
    1758:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    175e:	83 e0 f7             	and    $0xfffffff7,%eax
    1761:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->status_deferred_mf[index]);
    1767:	8b 94 be a0 05 00 00 	mov    0x5a0(%esi,%edi,4),%edx
    176e:	89 c8                	mov    %ecx,%eax
    1770:	e8 fc ff ff ff       	call   1771 <stm_target_cleanup+0x131>
    1775:	e9 f9 fe ff ff       	jmp    1673 <stm_target_cleanup+0x33>
    177a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	*io_state &= ~IO_STATE_INCOMPLETE;
	/*  *io_state &= ~IO_STATE_AUTO_REPOST;*/
	*io_state &= ~IO_STATE_ABORTED;
	*io_state &= ~IO_STATE_POSTED;
	if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == IO_STATE_AUTO_REPOST)
		*io_state = IO_STATE_POSTED;
    1780:	c7 83 a0 00 00 00 01 	movl   $0x1,0xa0(%ebx)
    1787:	00 00 00 
	else if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == 0)
		stm_cmd_buf_post(priv, index);
	TRACE_EXIT();
}
    178a:	83 c4 04             	add    $0x4,%esp
    178d:	5b                   	pop    %ebx
    178e:	5e                   	pop    %esi
    178f:	5f                   	pop    %edi
    1790:	5d                   	pop    %ebp
    1791:	c3                   	ret    
    1792:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    1798:	83 c4 04             	add    $0x4,%esp
	*io_state &= ~IO_STATE_ABORTED;
	*io_state &= ~IO_STATE_POSTED;
	if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == IO_STATE_AUTO_REPOST)
		*io_state = IO_STATE_POSTED;
	else if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == 0)
		stm_cmd_buf_post(priv, index);
    179b:	89 fa                	mov    %edi,%edx
	TRACE_EXIT();
}
    179d:	5b                   	pop    %ebx
	*io_state &= ~IO_STATE_ABORTED;
	*io_state &= ~IO_STATE_POSTED;
	if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == IO_STATE_AUTO_REPOST)
		*io_state = IO_STATE_POSTED;
	else if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == 0)
		stm_cmd_buf_post(priv, index);
    179e:	89 f0                	mov    %esi,%eax
	TRACE_EXIT();
}
    17a0:	5e                   	pop    %esi
    17a1:	5f                   	pop    %edi
    17a2:	5d                   	pop    %ebp
	*io_state &= ~IO_STATE_ABORTED;
	*io_state &= ~IO_STATE_POSTED;
	if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == IO_STATE_AUTO_REPOST)
		*io_state = IO_STATE_POSTED;
	else if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == 0)
		stm_cmd_buf_post(priv, index);
    17a3:	e9 88 fc ff ff       	jmp    1430 <stm_cmd_buf_post>
    17a8:	90                   	nop
    17a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000017b0 <stm_do_config_action.constprop.51>:

	return 0;
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_do_config_action(MPT_STM_PRIV *priv, int action, int type,
    17b0:	55                   	push   %ebp
    17b1:	89 e5                	mov    %esp,%ebp
    17b3:	57                   	push   %edi
    17b4:	56                   	push   %esi
    17b5:	53                   	push   %ebx
    17b6:	83 ec 24             	sub    $0x24,%esp
    17b9:	e8 fc ff ff ff       	call   17ba <stm_do_config_action.constprop.51+0xa>
    17be:	89 c3                	mov    %eax,%ebx
    17c0:	8b 45 08             	mov    0x8(%ebp),%eax
    17c3:	89 55 e8             	mov    %edx,-0x18(%ebp)
    17c6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    17c9:	89 45 dc             	mov    %eax,-0x24(%ebp)
    17cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    17cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    17d2:	8b 45 10             	mov    0x10(%ebp),%eax
    17d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
				int number, int address, int length, int sleep)
{
	MPT_ADAPTER		*ioc = priv->ioc;
    17d8:	8b 03                	mov    (%ebx),%eax
    17da:	89 45 ec             	mov    %eax,-0x14(%ebp)
	MPT_STM_SIMPLE	*sge_simple;
	dma_addr_t		dma_addr;
	int ret;

	TRACE_ENTRY();
	if (priv->in_reset) {
    17dd:	8b 43 78             	mov    0x78(%ebx),%eax
    17e0:	85 c0                	test   %eax,%eax
    17e2:	0f 85 b1 01 00 00    	jne    1999 <stm_do_config_action.constprop.51+0x1e9>
	}

	/*
	 *  get a message frame, and send the config action request
	 */
	mf = priv->config_mf;
    17e8:	8b 93 84 00 00 00    	mov    0x84(%ebx),%edx
	if (mf == NULL) {
    17ee:	85 d2                	test   %edx,%edx
    17f0:	0f 84 4a 01 00 00    	je     1940 <stm_do_config_action.constprop.51+0x190>
			priv->config_mf = mf;
		}
	}

	req = (Config_t *)mf;
	memset(req, 0, sizeof(*req));
    17f6:	f6 c2 01             	test   $0x1,%dl
    17f9:	89 d7                	mov    %edx,%edi
    17fb:	be 28 00 00 00       	mov    $0x28,%esi
    1800:	0f 85 6a 01 00 00    	jne    1970 <stm_do_config_action.constprop.51+0x1c0>
    1806:	f7 c7 02 00 00 00    	test   $0x2,%edi
    180c:	0f 85 76 01 00 00    	jne    1988 <stm_do_config_action.constprop.51+0x1d8>
    1812:	89 f1                	mov    %esi,%ecx
    1814:	31 c0                	xor    %eax,%eax
    1816:	c1 e9 02             	shr    $0x2,%ecx
    1819:	f7 c6 02 00 00 00    	test   $0x2,%esi
    181f:	f3 ab                	rep stos %eax,%es:(%edi)
    1821:	0f 85 c9 00 00 00    	jne    18f0 <stm_do_config_action.constprop.51+0x140>
    1827:	83 e6 01             	and    $0x1,%esi
    182a:	0f 85 b8 00 00 00    	jne    18e8 <stm_do_config_action.constprop.51+0x138>

	req->Function = MPI_FUNCTION_CONFIG;
	req->Action = (u8)action;
    1830:	8b 7d e8             	mov    -0x18(%ebp),%edi
	}

	req = (Config_t *)mf;
	memset(req, 0, sizeof(*req));

	req->Function = MPI_FUNCTION_CONFIG;
    1833:	c6 42 03 04          	movb   $0x4,0x3(%edx)
	req->Action = (u8)action;
	if (action == MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT ||
	    action == MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM) {
    1837:	83 ff 04             	cmp    $0x4,%edi

	req = (Config_t *)mf;
	memset(req, 0, sizeof(*req));

	req->Function = MPI_FUNCTION_CONFIG;
	req->Action = (u8)action;
    183a:	89 f8                	mov    %edi,%eax
	if (action == MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT ||
	    action == MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM) {
    183c:	0f 94 c1             	sete   %cl
	req = (Config_t *)mf;
	memset(req, 0, sizeof(*req));

	req->Function = MPI_FUNCTION_CONFIG;
	req->Action = (u8)action;
	if (action == MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT ||
    183f:	83 ff 02             	cmp    $0x2,%edi

	req = (Config_t *)mf;
	memset(req, 0, sizeof(*req));

	req->Function = MPI_FUNCTION_CONFIG;
	req->Action = (u8)action;
    1842:	88 02                	mov    %al,(%edx)
	if (action == MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT ||
    1844:	0f 94 c0             	sete   %al
    1847:	08 c8                	or     %cl,%al
    1849:	0f 85 b9 00 00 00    	jne    1908 <stm_do_config_action.constprop.51+0x158>
	    action == MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM) {
		req->Header = *(ConfigPageHeader_t *)priv->hw->config_buf;
	} else {
		if (type > MPI_CONFIG_PAGETYPE_EXTENDED) {
    184f:	83 7d e0 0f          	cmpl   $0xf,-0x20(%ebp)
    1853:	0f 8e c7 00 00 00    	jle    1920 <stm_do_config_action.constprop.51+0x170>
			req->Header.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
			req->ExtPageType = (u8)type;
    1859:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
			req->ExtPageLength = cpu_to_le16(length);
    185d:	0f b7 7d f0          	movzwl -0x10(%ebp),%edi
	if (action == MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT ||
	    action == MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM) {
		req->Header = *(ConfigPageHeader_t *)priv->hw->config_buf;
	} else {
		if (type > MPI_CONFIG_PAGETYPE_EXTENDED) {
			req->Header.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
    1861:	c6 42 17 0f          	movb   $0xf,0x17(%edx)
			req->ExtPageType = (u8)type;
    1865:	88 4a 06             	mov    %cl,0x6(%edx)
			req->ExtPageLength = cpu_to_le16(length);
    1868:	66 89 7a 04          	mov    %di,0x4(%edx)
		} else {
			req->Header.PageType = (u8)type;
		}
		req->Header.PageNumber = (u8)number;
    186c:	0f b6 4d dc          	movzbl -0x24(%ebp),%ecx
    1870:	88 4a 16             	mov    %cl,0x16(%edx)
		req->Header.PageLength = (u8)length;
    1873:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    1877:	88 4a 15             	mov    %cl,0x15(%edx)
	}
	req->PageAddress = cpu_to_le32(address);
	if (length) {
    187a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
			req->Header.PageType = (u8)type;
		}
		req->Header.PageNumber = (u8)number;
		req->Header.PageLength = (u8)length;
	}
	req->PageAddress = cpu_to_le32(address);
    187d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (length) {
    1880:	85 c9                	test   %ecx,%ecx
			req->Header.PageType = (u8)type;
		}
		req->Header.PageNumber = (u8)number;
		req->Header.PageLength = (u8)length;
	}
	req->PageAddress = cpu_to_le32(address);
    1882:	89 72 18             	mov    %esi,0x18(%edx)
	if (length) {
    1885:	74 2c                	je     18b3 <stm_do_config_action.constprop.51+0x103>
		sge_simple = (MPT_STM_SIMPLE *)&req->PageBufferSGE;
		sge_simple->FlagsLength = cpu_to_le32((length * 4) |
    1887:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    188a:	c1 e1 02             	shl    $0x2,%ecx
						      MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_SIMPLE_ELEMENT |
									MPI_SGE_FLAGS_LAST_ELEMENT |
									MPI_SGE_FLAGS_END_OF_BUFFER |
									MPI_SGE_FLAGS_END_OF_LIST |
									MPI_SGE_FLAGS_MPT_STM_ADDRESSING));
		if (action == MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT ||
    188d:	84 c0                	test   %al,%al
    188f:	0f 85 9b 00 00 00    	jne    1930 <stm_do_config_action.constprop.51+0x180>
		req->Header.PageLength = (u8)length;
	}
	req->PageAddress = cpu_to_le32(address);
	if (length) {
		sge_simple = (MPT_STM_SIMPLE *)&req->PageBufferSGE;
		sge_simple->FlagsLength = cpu_to_le32((length * 4) |
    1895:	81 c9 00 00 00 d3    	or     $0xd3000000,%ecx
    189b:	89 4a 1c             	mov    %ecx,0x1c(%edx)
		if (action == MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT ||
		    action == MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM) {
			sge_simple->FlagsLength |=
				cpu_to_le32(MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_HOST_TO_IOC));
		}
		dma_addr = priv->hw_dma + ((u8 *)priv->hw->config_buf - (u8 *)priv->hw);
    189e:	8b 73 24             	mov    0x24(%ebx),%esi
    18a1:	8b 7b 28             	mov    0x28(%ebx),%edi
    18a4:	81 c6 00 18 02 00    	add    $0x21800,%esi
    18aa:	83 d7 00             	adc    $0x0,%edi
		stm_set_dma_addr(sge_simple->Address, dma_addr);
    18ad:	89 72 20             	mov    %esi,0x20(%edx)
    18b0:	89 7a 24             	mov    %edi,0x24(%edx)
	}

#if 1
	priv->config_pending = 1;

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    18b3:	89 d1                	mov    %edx,%ecx
    18b5:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    18bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
		dma_addr = priv->hw_dma + ((u8 *)priv->hw->config_buf - (u8 *)priv->hw);
		stm_set_dma_addr(sge_simple->Address, dma_addr);
	}

#if 1
	priv->config_pending = 1;
    18bf:	c7 43 74 01 00 00 00 	movl   $0x1,0x74(%ebx)

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    18c6:	e8 fc ff ff ff       	call   18c7 <stm_do_config_action.constprop.51+0x117>
					   (u16 *)&priv->config_rep, 10, sleep);
#endif
	TRACE_EXIT_RES(ret);

	return ret;
}
    18cb:	83 c4 24             	add    $0x24,%esp
#if 1
	priv->config_pending = 1;

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);

	ret = stm_wait_for(priv, &priv->config_pending, 10, sleep);
    18ce:	89 d8                	mov    %ebx,%eax
    18d0:	8d 53 74             	lea    0x74(%ebx),%edx
    18d3:	b9 0a 00 00 00       	mov    $0xa,%ecx
					   (u16 *)&priv->config_rep, 10, sleep);
#endif
	TRACE_EXIT_RES(ret);

	return ret;
}
    18d8:	5b                   	pop    %ebx
    18d9:	5e                   	pop    %esi
    18da:	5f                   	pop    %edi
    18db:	5d                   	pop    %ebp
#if 1
	priv->config_pending = 1;

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);

	ret = stm_wait_for(priv, &priv->config_pending, 10, sleep);
    18dc:	e9 ff ef ff ff       	jmp    8e0 <stm_wait_for.constprop.52>
    18e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			priv->config_mf = mf;
		}
	}

	req = (Config_t *)mf;
	memset(req, 0, sizeof(*req));
    18e8:	c6 07 00             	movb   $0x0,(%edi)
    18eb:	e9 40 ff ff ff       	jmp    1830 <stm_do_config_action.constprop.51+0x80>
    18f0:	31 c0                	xor    %eax,%eax
    18f2:	83 c7 02             	add    $0x2,%edi
    18f5:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    18f9:	83 e6 01             	and    $0x1,%esi
    18fc:	0f 84 2e ff ff ff    	je     1830 <stm_do_config_action.constprop.51+0x80>
    1902:	eb e4                	jmp    18e8 <stm_do_config_action.constprop.51+0x138>
    1904:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	req->Function = MPI_FUNCTION_CONFIG;
	req->Action = (u8)action;
	if (action == MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT ||
	    action == MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM) {
		req->Header = *(ConfigPageHeader_t *)priv->hw->config_buf;
    1908:	8b 4b 20             	mov    0x20(%ebx),%ecx
    190b:	8b 89 00 18 02 00    	mov    0x21800(%ecx),%ecx
    1911:	89 4a 14             	mov    %ecx,0x14(%edx)
    1914:	e9 61 ff ff ff       	jmp    187a <stm_do_config_action.constprop.51+0xca>
    1919:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (type > MPI_CONFIG_PAGETYPE_EXTENDED) {
			req->Header.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;
			req->ExtPageType = (u8)type;
			req->ExtPageLength = cpu_to_le16(length);
		} else {
			req->Header.PageType = (u8)type;
    1920:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    1924:	88 4a 17             	mov    %cl,0x17(%edx)
    1927:	e9 40 ff ff ff       	jmp    186c <stm_do_config_action.constprop.51+0xbc>
    192c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
									MPI_SGE_FLAGS_END_OF_BUFFER |
									MPI_SGE_FLAGS_END_OF_LIST |
									MPI_SGE_FLAGS_MPT_STM_ADDRESSING));
		if (action == MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT ||
		    action == MPI_CONFIG_ACTION_PAGE_WRITE_NVRAM) {
			sge_simple->FlagsLength |=
    1930:	81 c9 00 00 00 d7    	or     $0xd7000000,%ecx
    1936:	89 4a 1c             	mov    %ecx,0x1c(%edx)
    1939:	e9 60 ff ff ff       	jmp    189e <stm_do_config_action.constprop.51+0xee>
    193e:	66 90                	xchg   %ax,%ax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    1940:	8b 55 ec             	mov    -0x14(%ebp),%edx
    1943:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    194a:	e8 fc ff ff ff       	call   194b <stm_do_config_action.constprop.51+0x19b>

	sBUG_ON(mf == NULL);
    194f:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    1951:	89 c2                	mov    %eax,%edx

	sBUG_ON(mf == NULL);
    1953:	74 6c                	je     19c1 <stm_do_config_action.constprop.51+0x211>
			priv->config_mf = mf;
		}
	}

	req = (Config_t *)mf;
	memset(req, 0, sizeof(*req));
    1955:	f6 c2 01             	test   $0x1,%dl
    1958:	89 d7                	mov    %edx,%edi
			return -1;
		} else {
			TRACE_DBG(
				  "%s in stm_do_config_action, got mf index %d",
				  ioc->name, MF_TO_INDEX(mf));
			priv->config_mf = mf;
    195a:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
		}
	}

	req = (Config_t *)mf;
	memset(req, 0, sizeof(*req));
    1960:	be 28 00 00 00       	mov    $0x28,%esi
    1965:	0f 84 9b fe ff ff    	je     1806 <stm_do_config_action.constprop.51+0x56>
    196b:	90                   	nop
    196c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1970:	8d 7a 01             	lea    0x1(%edx),%edi
    1973:	66 be 27 00          	mov    $0x27,%si
    1977:	f7 c7 02 00 00 00    	test   $0x2,%edi
    197d:	c6 02 00             	movb   $0x0,(%edx)
    1980:	0f 84 8c fe ff ff    	je     1812 <stm_do_config_action.constprop.51+0x62>
    1986:	66 90                	xchg   %ax,%ax
    1988:	31 c0                	xor    %eax,%eax
    198a:	83 c7 02             	add    $0x2,%edi
    198d:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    1991:	83 ee 02             	sub    $0x2,%esi
    1994:	e9 79 fe ff ff       	jmp    1812 <stm_do_config_action.constprop.51+0x62>
	dma_addr_t		dma_addr;
	int ret;

	TRACE_ENTRY();
	if (priv->in_reset) {
		printk(KERN_ERR MYNAM ":%s reset while doing config action %x\n",
    1999:	8b 45 e8             	mov    -0x18(%ebp),%eax
    199c:	c7 04 24 90 03 00 00 	movl   $0x390,(%esp)
    19a3:	89 44 24 08          	mov    %eax,0x8(%esp)
		       ioc->name, action);
    19a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    19aa:	83 c0 08             	add    $0x8,%eax
    19ad:	89 44 24 04          	mov    %eax,0x4(%esp)
	dma_addr_t		dma_addr;
	int ret;

	TRACE_ENTRY();
	if (priv->in_reset) {
		printk(KERN_ERR MYNAM ":%s reset while doing config action %x\n",
    19b1:	e8 fc ff ff ff       	call   19b2 <stm_do_config_action.constprop.51+0x202>
					   (u16 *)&priv->config_rep, 10, sleep);
#endif
	TRACE_EXIT_RES(ret);

	return ret;
}
    19b6:	83 c4 24             	add    $0x24,%esp
    19b9:	83 c8 ff             	or     $0xffffffff,%eax
    19bc:	5b                   	pop    %ebx
    19bd:	5e                   	pop    %esi
    19be:	5f                   	pop    %edi
    19bf:	5d                   	pop    %ebp
    19c0:	c3                   	ret    
    19c1:	e8 11 00 00 00       	call   19d7 <stm_get_config_page.constprop.50+0x7>
    19c6:	8d 76 00             	lea    0x0(%esi),%esi
    19c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000019d0 <stm_get_config_page.constprop.50>:
	TRACE_EXIT();
	return 0;
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_get_config_page(MPT_STM_PRIV *priv, int type, int number,
    19d0:	55                   	push   %ebp
    19d1:	89 e5                	mov    %esp,%ebp
    19d3:	57                   	push   %edi
    19d4:	56                   	push   %esi
    19d5:	53                   	push   %ebx
    19d6:	83 ec 20             	sub    $0x20,%esp
    19d9:	e8 fc ff ff ff       	call   19da <stm_get_config_page.constprop.50+0xa>
    19de:	89 c3                	mov    %eax,%ebx
			       int address, int sleep)
{
	MPT_ADAPTER		*ioc = priv->ioc;
    19e0:	8b 00                	mov    (%eax),%eax
	TRACE_EXIT();
	return 0;
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_get_config_page(MPT_STM_PRIV *priv, int type, int number,
    19e2:	89 d6                	mov    %edx,%esi
	int			i;
	int			length;

	TRACE_ENTRY();
	rep = &priv->config_rep;
	memset(rep, 0, sizeof(*rep));
    19e4:	8d 93 88 00 00 00    	lea    0x88(%ebx),%edx
    19ea:	f6 c2 01             	test   $0x1,%dl
	TRACE_EXIT();
	return 0;
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_get_config_page(MPT_STM_PRIV *priv, int type, int number,
    19ed:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	int			i;
	int			length;

	TRACE_ENTRY();
	rep = &priv->config_rep;
	memset(rep, 0, sizeof(*rep));
    19f0:	b9 18 00 00 00       	mov    $0x18,%ecx

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_get_config_page(MPT_STM_PRIV *priv, int type, int number,
			       int address, int sleep)
{
	MPT_ADAPTER		*ioc = priv->ioc;
    19f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int			i;
	int			length;

	TRACE_ENTRY();
	rep = &priv->config_rep;
	memset(rep, 0, sizeof(*rep));
    19f8:	0f 85 1a 01 00 00    	jne    1b18 <stm_get_config_page.constprop.50+0x148>
    19fe:	f6 c2 02             	test   $0x2,%dl
    1a01:	0f 85 29 01 00 00    	jne    1b30 <stm_get_config_page.constprop.50+0x160>
    1a07:	89 cf                	mov    %ecx,%edi
    1a09:	31 c0                	xor    %eax,%eax
    1a0b:	83 e7 fc             	and    $0xfffffffc,%edi
    1a0e:	c7 04 02 00 00 00 00 	movl   $0x0,(%edx,%eax,1)
    1a15:	83 c0 04             	add    $0x4,%eax
    1a18:	39 f8                	cmp    %edi,%eax
    1a1a:	72 f2                	jb     1a0e <stm_get_config_page.constprop.50+0x3e>
    1a1c:	01 c2                	add    %eax,%edx
    1a1e:	f6 c1 02             	test   $0x2,%cl
    1a21:	74 09                	je     1a2c <stm_get_config_page.constprop.50+0x5c>
    1a23:	31 ff                	xor    %edi,%edi
    1a25:	83 c2 02             	add    $0x2,%edx
    1a28:	66 89 7a fe          	mov    %di,-0x2(%edx)
    1a2c:	83 e1 01             	and    $0x1,%ecx
    1a2f:	74 03                	je     1a34 <stm_get_config_page.constprop.50+0x64>
    1a31:	c6 02 00             	movb   $0x0,(%edx)

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_HEADER,
    1a34:	8b 45 08             	mov    0x8(%ebp),%eax
    1a37:	31 d2                	xor    %edx,%edx
    1a39:	89 f1                	mov    %esi,%ecx
    1a3b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    1a42:	00 
    1a43:	89 44 24 04          	mov    %eax,0x4(%esp)
    1a47:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1a4a:	89 04 24             	mov    %eax,(%esp)
    1a4d:	89 d8                	mov    %ebx,%eax
    1a4f:	e8 5c fd ff ff       	call   17b0 <stm_do_config_action.constprop.51>
				 type, number, address, 0, sleep);
	if (i) {
    1a54:	85 c0                	test   %eax,%eax
		if (!priv->in_reset)
    1a56:	8b 43 78             	mov    0x78(%ebx),%eax
	rep = &priv->config_rep;
	memset(rep, 0, sizeof(*rep));

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_HEADER,
				 type, number, address, 0, sleep);
	if (i) {
    1a59:	74 15                	je     1a70 <stm_get_config_page.constprop.50+0xa0>
		if (!priv->in_reset)
    1a5b:	85 c0                	test   %eax,%eax
    1a5d:	0f 84 94 01 00 00    	je     1bf7 <stm_get_config_page.constprop.50+0x227>
			       ioc->name, ioc_status, length);
			printk(KERN_ERR MYNAM
			       ":%s   type = %d, number = %d, address = %x\n",
			       ioc->name, type, number, address);
		}
		return -1;
    1a63:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
#endif
	TRACE_EXIT();

	return 0;
}
    1a68:	83 c4 20             	add    $0x20,%esp
    1a6b:	5b                   	pop    %ebx
    1a6c:	5e                   	pop    %esi
    1a6d:	5f                   	pop    %edi
    1a6e:	5d                   	pop    %ebp
    1a6f:	c3                   	ret    
			printk(KERN_ERR MYNAM
			       ":%s timed out getting config page header\n", ioc->name);
		return -1;
	}

	if (priv->in_reset) {
    1a70:	85 c0                	test   %eax,%eax
    1a72:	0f 85 61 01 00 00    	jne    1bd9 <stm_get_config_page.constprop.50+0x209>
		printk(KERN_ERR MYNAM
		       ":%s reset while getting config page header\n", ioc->name);
		return -1;
	}

	ioc_status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
    1a78:	0f b7 93 96 00 00 00 	movzwl 0x96(%ebx),%edx
    1a7f:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
	if (type > MPI_CONFIG_PAGETYPE_EXTENDED)
    1a85:	83 fe 0f             	cmp    $0xf,%esi
    1a88:	7e 2e                	jle    1ab8 <stm_get_config_page.constprop.50+0xe8>
		length = le16_to_cpu(rep->ExtPageLength);
    1a8a:	0f b7 bb 8c 00 00 00 	movzwl 0x8c(%ebx),%edi
	else
		length = rep->Header.PageLength;
	if (ioc_status != MPI_IOCSTATUS_SUCCESS || length == 0) {
    1a91:	85 ff                	test   %edi,%edi
    1a93:	75 2e                	jne    1ac3 <stm_get_config_page.constprop.50+0xf3>
		if (ioc_status != MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {
    1a95:	83 fa 22             	cmp    $0x22,%edx
    1a98:	74 c9                	je     1a63 <stm_get_config_page.constprop.50+0x93>
			printk(KERN_ERR MYNAM
			       ":%s failed to get config page header\n", ioc->name);
    1a9a:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    1a9d:	89 55 e8             	mov    %edx,-0x18(%ebp)
		length = le16_to_cpu(rep->ExtPageLength);
	else
		length = rep->Header.PageLength;
	if (ioc_status != MPI_IOCSTATUS_SUCCESS || length == 0) {
		if (ioc_status != MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {
			printk(KERN_ERR MYNAM
    1aa0:	c7 04 24 30 04 00 00 	movl   $0x430,(%esp)
			       ":%s failed to get config page header\n", ioc->name);
    1aa7:	83 c3 08             	add    $0x8,%ebx
		length = le16_to_cpu(rep->ExtPageLength);
	else
		length = rep->Header.PageLength;
	if (ioc_status != MPI_IOCSTATUS_SUCCESS || length == 0) {
		if (ioc_status != MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {
			printk(KERN_ERR MYNAM
    1aaa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    1aae:	e9 df 00 00 00       	jmp    1b92 <stm_get_config_page.constprop.50+0x1c2>
    1ab3:	90                   	nop
    1ab4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	ioc_status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
	if (type > MPI_CONFIG_PAGETYPE_EXTENDED)
		length = le16_to_cpu(rep->ExtPageLength);
	else
		length = rep->Header.PageLength;
    1ab8:	0f b6 bb 9d 00 00 00 	movzbl 0x9d(%ebx),%edi
	if (ioc_status != MPI_IOCSTATUS_SUCCESS || length == 0) {
    1abf:	85 ff                	test   %edi,%edi
    1ac1:	74 d2                	je     1a95 <stm_get_config_page.constprop.50+0xc5>
    1ac3:	85 d2                	test   %edx,%edx
    1ac5:	75 ce                	jne    1a95 <stm_get_config_page.constprop.50+0xc5>
			       ioc->name, type, number, address);
		}
		return -1;
	}

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_READ_CURRENT,
    1ac7:	8b 45 08             	mov    0x8(%ebp),%eax
    1aca:	89 f1                	mov    %esi,%ecx
    1acc:	ba 01 00 00 00       	mov    $0x1,%edx
    1ad1:	89 7c 24 08          	mov    %edi,0x8(%esp)
    1ad5:	89 44 24 04          	mov    %eax,0x4(%esp)
    1ad9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1adc:	89 04 24             	mov    %eax,(%esp)
    1adf:	89 d8                	mov    %ebx,%eax
    1ae1:	e8 ca fc ff ff       	call   17b0 <stm_do_config_action.constprop.51>
				 type, number, address, length, sleep);
	if (i) {
    1ae6:	85 c0                	test   %eax,%eax
		if (!priv->in_reset) {
    1ae8:	8b 43 78             	mov    0x78(%ebx),%eax
		return -1;
	}

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_READ_CURRENT,
				 type, number, address, length, sleep);
	if (i) {
    1aeb:	74 5b                	je     1b48 <stm_get_config_page.constprop.50+0x178>
		if (!priv->in_reset) {
    1aed:	85 c0                	test   %eax,%eax
    1aef:	0f 85 6e ff ff ff    	jne    1a63 <stm_get_config_page.constprop.50+0x93>
			printk(KERN_ERR MYNAM
			       ":%s timed out getting config page = %d\n", ioc->name, type);
    1af5:	8b 45 ec             	mov    -0x14(%ebp),%eax

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_READ_CURRENT,
				 type, number, address, length, sleep);
	if (i) {
		if (!priv->in_reset) {
			printk(KERN_ERR MYNAM
    1af8:	89 74 24 08          	mov    %esi,0x8(%esp)
    1afc:	c7 04 24 cc 04 00 00 	movl   $0x4cc,(%esp)
			       ":%s timed out getting config page = %d\n", ioc->name, type);
    1b03:	83 c0 08             	add    $0x8,%eax
    1b06:	89 44 24 04          	mov    %eax,0x4(%esp)

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_READ_CURRENT,
				 type, number, address, length, sleep);
	if (i) {
		if (!priv->in_reset) {
			printk(KERN_ERR MYNAM
    1b0a:	e8 fc ff ff ff       	call   1b0b <stm_get_config_page.constprop.50+0x13b>
			       ":%s timed out getting config page = %d\n", ioc->name, type);
		}
		return -1;
    1b0f:	83 c8 ff             	or     $0xffffffff,%eax
    1b12:	e9 51 ff ff ff       	jmp    1a68 <stm_get_config_page.constprop.50+0x98>
    1b17:	90                   	nop
	int			i;
	int			length;

	TRACE_ENTRY();
	rep = &priv->config_rep;
	memset(rep, 0, sizeof(*rep));
    1b18:	8d 93 89 00 00 00    	lea    0x89(%ebx),%edx
    1b1e:	b1 17                	mov    $0x17,%cl
    1b20:	f6 c2 02             	test   $0x2,%dl
    1b23:	c6 83 88 00 00 00 00 	movb   $0x0,0x88(%ebx)
    1b2a:	0f 84 d7 fe ff ff    	je     1a07 <stm_get_config_page.constprop.50+0x37>
    1b30:	31 c0                	xor    %eax,%eax
    1b32:	83 c2 02             	add    $0x2,%edx
    1b35:	66 89 42 fe          	mov    %ax,-0x2(%edx)
    1b39:	83 e9 02             	sub    $0x2,%ecx
    1b3c:	e9 c6 fe ff ff       	jmp    1a07 <stm_get_config_page.constprop.50+0x37>
    1b41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			       ":%s timed out getting config page = %d\n", ioc->name, type);
		}
		return -1;
	}

	if (priv->in_reset) {
    1b48:	85 c0                	test   %eax,%eax
    1b4a:	0f 85 c5 00 00 00    	jne    1c15 <stm_get_config_page.constprop.50+0x245>
		printk(KERN_ERR MYNAM
		       ":%s reset while getting config page\n", ioc->name);
		return -1;
	}

	ioc_status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
    1b50:	0f b7 93 96 00 00 00 	movzwl 0x96(%ebx),%edx
	if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
    1b57:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
    1b5d:	0f 84 05 ff ff ff    	je     1a68 <stm_get_config_page.constprop.50+0x98>
		if ((type == 6 && number == 0) || (type == 18 && number == 0)) {
    1b63:	83 fe 12             	cmp    $0x12,%esi
    1b66:	0f 94 c1             	sete   %cl
    1b69:	83 fe 06             	cmp    $0x6,%esi
    1b6c:	0f 94 c0             	sete   %al
    1b6f:	08 c1                	or     %al,%cl
    1b71:	74 0b                	je     1b7e <stm_get_config_page.constprop.50+0x1ae>
    1b73:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1b76:	85 c0                	test   %eax,%eax
    1b78:	0f 84 e5 fe ff ff    	je     1a63 <stm_get_config_page.constprop.50+0x93>
			/* no error messages, please! */
		} else {
			printk(KERN_ERR MYNAM
			       ":%s failed to get config page\n", ioc->name);
    1b7e:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    1b81:	89 55 e8             	mov    %edx,-0x18(%ebp)
	ioc_status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
	if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
		if ((type == 6 && number == 0) || (type == 18 && number == 0)) {
			/* no error messages, please! */
		} else {
			printk(KERN_ERR MYNAM
    1b84:	c7 04 24 30 05 00 00 	movl   $0x530,(%esp)
			       ":%s failed to get config page\n", ioc->name);
    1b8b:	83 c3 08             	add    $0x8,%ebx
	ioc_status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
	if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
		if ((type == 6 && number == 0) || (type == 18 && number == 0)) {
			/* no error messages, please! */
		} else {
			printk(KERN_ERR MYNAM
    1b8e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    1b92:	e8 fc ff ff ff       	call   1b93 <stm_get_config_page.constprop.50+0x1c3>
			       ":%s failed to get config page\n", ioc->name);
			printk(KERN_ERR MYNAM
    1b97:	8b 55 e8             	mov    -0x18(%ebp),%edx
    1b9a:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    1b9e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    1ba2:	c7 04 24 60 04 00 00 	movl   $0x460,(%esp)
    1ba9:	89 54 24 08          	mov    %edx,0x8(%esp)
    1bad:	e8 fc ff ff ff       	call   1bae <stm_get_config_page.constprop.50+0x1de>
			       ":%s   IOCStatus = %04x, PageLength = %x\n",
			       ioc->name, ioc_status, length);
			printk(KERN_ERR MYNAM
    1bb2:	8b 45 08             	mov    0x8(%ebp),%eax
    1bb5:	89 74 24 08          	mov    %esi,0x8(%esp)
    1bb9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    1bbd:	c7 04 24 94 04 00 00 	movl   $0x494,(%esp)
    1bc4:	89 44 24 10          	mov    %eax,0x10(%esp)
    1bc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1bcb:	89 44 24 0c          	mov    %eax,0xc(%esp)
    1bcf:	e8 fc ff ff ff       	call   1bd0 <stm_get_config_page.constprop.50+0x200>
    1bd4:	e9 8a fe ff ff       	jmp    1a63 <stm_get_config_page.constprop.50+0x93>
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
		       ":%s reset while getting config page header\n", ioc->name);
    1bd9:	8b 45 ec             	mov    -0x14(%ebp),%eax
			       ":%s timed out getting config page header\n", ioc->name);
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
    1bdc:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
		       ":%s reset while getting config page header\n", ioc->name);
    1be3:	83 c0 08             	add    $0x8,%eax
    1be6:	89 44 24 04          	mov    %eax,0x4(%esp)
			       ":%s timed out getting config page header\n", ioc->name);
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
    1bea:	e8 fc ff ff ff       	call   1beb <stm_get_config_page.constprop.50+0x21b>
		       ":%s reset while getting config page header\n", ioc->name);
		return -1;
    1bef:	83 c8 ff             	or     $0xffffffff,%eax
    1bf2:	e9 71 fe ff ff       	jmp    1a68 <stm_get_config_page.constprop.50+0x98>
	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_HEADER,
				 type, number, address, 0, sleep);
	if (i) {
		if (!priv->in_reset)
			printk(KERN_ERR MYNAM
			       ":%s timed out getting config page header\n", ioc->name);
    1bf7:	8b 45 ec             	mov    -0x14(%ebp),%eax

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_HEADER,
				 type, number, address, 0, sleep);
	if (i) {
		if (!priv->in_reset)
			printk(KERN_ERR MYNAM
    1bfa:	c7 04 24 c4 03 00 00 	movl   $0x3c4,(%esp)
			       ":%s timed out getting config page header\n", ioc->name);
    1c01:	83 c0 08             	add    $0x8,%eax
    1c04:	89 44 24 04          	mov    %eax,0x4(%esp)

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_HEADER,
				 type, number, address, 0, sleep);
	if (i) {
		if (!priv->in_reset)
			printk(KERN_ERR MYNAM
    1c08:	e8 fc ff ff ff       	call   1c09 <stm_get_config_page.constprop.50+0x239>
			       ":%s timed out getting config page header\n", ioc->name);
		return -1;
    1c0d:	83 c8 ff             	or     $0xffffffff,%eax
    1c10:	e9 53 fe ff ff       	jmp    1a68 <stm_get_config_page.constprop.50+0x98>
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
		       ":%s reset while getting config page\n", ioc->name);
    1c15:	8b 45 ec             	mov    -0x14(%ebp),%eax
		}
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
    1c18:	c7 04 24 00 05 00 00 	movl   $0x500,(%esp)
		       ":%s reset while getting config page\n", ioc->name);
    1c1f:	83 c0 08             	add    $0x8,%eax
    1c22:	89 44 24 04          	mov    %eax,0x4(%esp)
		}
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
    1c26:	e8 fc ff ff ff       	call   1c27 <stm_get_config_page.constprop.50+0x257>
		       ":%s reset while getting config page\n", ioc->name);
		return -1;
    1c2b:	83 c8 ff             	or     $0xffffffff,%eax
    1c2e:	e9 35 fe ff ff       	jmp    1a68 <stm_get_config_page.constprop.50+0x98>
    1c33:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    1c39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001c40 <mptstm_probe>:
}

static int _mpt_ada_nums;

static int mptstm_probe(struct pci_dev *pdev, const struct pci_device_id *id)
{
    1c40:	55                   	push   %ebp
    1c41:	89 e5                	mov    %esp,%ebp
    1c43:	57                   	push   %edi
    1c44:	56                   	push   %esi
    1c45:	53                   	push   %ebx
    1c46:	83 ec 2c             	sub    $0x2c,%esp
    1c49:	e8 fc ff ff ff       	call   1c4a <mptstm_probe+0xa>
			int index = kmalloc_index(size);

			if (!index)
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(kmalloc_caches[index],
    1c4e:	b9 50 14 00 00       	mov    $0x1450,%ecx
    1c53:	ba d0 00 00 00       	mov    $0xd0,%edx
 * driver-specific data.  They are really just a wrapper around
 * the generic device structure functions of these calls.
 */
static inline void *pci_get_drvdata(struct pci_dev *pdev)
{
	return dev_get_drvdata(&pdev->dev);
    1c58:	8b b0 bc 00 00 00    	mov    0xbc(%eax),%esi
    1c5e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1c61:	a1 34 00 00 00       	mov    0x34,%eax
    1c66:	e8 fc ff ff ff       	call   1c67 <mptstm_probe+0x27>
	MPT_STM_PRIV		*priv;
	int				max_aliases;

	TRACE_ENTRY();
	priv = kmalloc(sizeof(*priv), GFP_KERNEL);
	if (priv == NULL) {
    1c6b:	85 c0                	test   %eax,%eax
    1c6d:	89 c3                	mov    %eax,%ebx
    1c6f:	0f 84 9c 04 00 00    	je     2111 <mptstm_probe+0x4d1>
		printk(KERN_ERR MYNAM
		       ":%s failed to allocate private structure\n", ioc->name);
		return -ENOMEM;
	}
	memset(priv, 0, sizeof(*priv));
    1c75:	a8 01                	test   $0x1,%al
    1c77:	89 c7                	mov    %eax,%edi
    1c79:	ba 50 14 00 00       	mov    $0x1450,%edx
    1c7e:	0f 85 84 03 00 00    	jne    2008 <mptstm_probe+0x3c8>
    1c84:	f7 c7 02 00 00 00    	test   $0x2,%edi
    1c8a:	0f 85 90 03 00 00    	jne    2020 <mptstm_probe+0x3e0>
    1c90:	89 d1                	mov    %edx,%ecx
    1c92:	31 c0                	xor    %eax,%eax
    1c94:	c1 e9 02             	shr    $0x2,%ecx
    1c97:	f6 c2 02             	test   $0x2,%dl
    1c9a:	f3 ab                	rep stos %eax,%es:(%edi)
    1c9c:	0f 85 5e 02 00 00    	jne    1f00 <mptstm_probe+0x2c0>
    1ca2:	83 e2 01             	and    $0x1,%edx
    1ca5:	0f 85 67 02 00 00    	jne    1f12 <mptstm_probe+0x2d2>
	if (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_TARGET)
    1cab:	f6 86 6e 03 00 00 04 	testb  $0x4,0x36e(%esi)
    1cb2:	74 07                	je     1cbb <mptstm_probe+0x7b>
		priv->enable_target_mode = 1;
    1cb4:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)

	priv->ioc = ioc;

	priv->num_sge_chain = ioc->req_sz / sizeof(MPT_STM_SIMPLE);
    1cbb:	b9 ab aa aa aa       	mov    $0xaaaaaaab,%ecx
	}
	memset(priv, 0, sizeof(*priv));
	if (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_TARGET)
		priv->enable_target_mode = 1;

	priv->ioc = ioc;
    1cc0:	89 33                	mov    %esi,(%ebx)

	priv->num_sge_chain = ioc->req_sz / sizeof(MPT_STM_SIMPLE);
    1cc2:	89 c8                	mov    %ecx,%eax
    1cc4:	f7 a6 14 01 00 00    	mull   0x114(%esi)
    1cca:	c1 ea 03             	shr    $0x3,%edx
    1ccd:	89 53 0c             	mov    %edx,0xc(%ebx)
	priv->num_sge_target_assist = (ioc->req_sz -
    1cd0:	8b 86 14 01 00 00    	mov    0x114(%esi),%eax
				       offsetof(TargetAssistRequest_t, SGL)) / sizeof(MPT_STM_SIMPLE);

	priv->num_cmd_buffers = NUM_CMD_BUFFERS;
    1cd6:	c7 43 14 80 00 00 00 	movl   $0x80,0x14(%ebx)
		priv->enable_target_mode = 1;

	priv->ioc = ioc;

	priv->num_sge_chain = ioc->req_sz / sizeof(MPT_STM_SIMPLE);
	priv->num_sge_target_assist = (ioc->req_sz -
    1cdd:	8d 50 e0             	lea    -0x20(%eax),%edx
				       offsetof(TargetAssistRequest_t, SGL)) / sizeof(MPT_STM_SIMPLE);
    1ce0:	89 d0                	mov    %edx,%eax
    1ce2:	f7 e1                	mul    %ecx
    1ce4:	c1 ea 03             	shr    $0x3,%edx
    1ce7:	89 53 10             	mov    %edx,0x10(%ebx)

	priv->num_cmd_buffers = NUM_CMD_BUFFERS;
	if (priv->num_cmd_buffers > ioc->pfacts[0].MaxPostedCmdBuffers)
    1cea:	0f b7 86 70 03 00 00 	movzwl 0x370(%esi),%eax
    1cf1:	83 f8 7f             	cmp    $0x7f,%eax
    1cf4:	0f 8e fe 01 00 00    	jle    1ef8 <mptstm_probe+0x2b8>
    1cfa:	b8 80 00 00 00       	mov    $0x80,%eax
		priv->num_cmd_buffers = ioc->pfacts[0].MaxPostedCmdBuffers;
	if (priv->num_cmd_buffers > ioc->req_depth - 16)
    1cff:	8b be 10 01 00 00    	mov    0x110(%esi),%edi
    1d05:	8d 57 f0             	lea    -0x10(%edi),%edx
    1d08:	39 c2                	cmp    %eax,%edx
    1d0a:	7d 03                	jge    1d0f <mptstm_probe+0xcf>
		priv->num_cmd_buffers = ioc->req_depth - 16;
    1d0c:	89 53 14             	mov    %edx,0x14(%ebx)
	priv->num_els_buffers = NUM_ELS_BUFFERS;

	priv->poll_enabled = 1;

	priv->hw = pci_alloc_consistent(ioc->pcidev, sizeof(*priv->hw),
    1d0f:	8d 43 24             	lea    0x24(%ebx),%eax
	priv->num_cmd_buffers = NUM_CMD_BUFFERS;
	if (priv->num_cmd_buffers > ioc->pfacts[0].MaxPostedCmdBuffers)
		priv->num_cmd_buffers = ioc->pfacts[0].MaxPostedCmdBuffers;
	if (priv->num_cmd_buffers > ioc->req_depth - 16)
		priv->num_cmd_buffers = ioc->req_depth - 16;
	priv->num_els_buffers = NUM_ELS_BUFFERS;
    1d12:	c7 43 18 40 00 00 00 	movl   $0x40,0x18(%ebx)

	priv->poll_enabled = 1;

	priv->hw = pci_alloc_consistent(ioc->pcidev, sizeof(*priv->hw),
    1d19:	89 c1                	mov    %eax,%ecx
		priv->num_cmd_buffers = ioc->pfacts[0].MaxPostedCmdBuffers;
	if (priv->num_cmd_buffers > ioc->req_depth - 16)
		priv->num_cmd_buffers = ioc->req_depth - 16;
	priv->num_els_buffers = NUM_ELS_BUFFERS;

	priv->poll_enabled = 1;
    1d1b:	c7 43 7c 01 00 00 00 	movl   $0x1,0x7c(%ebx)

	priv->hw = pci_alloc_consistent(ioc->pcidev, sizeof(*priv->hw),
    1d22:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1d25:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax

static inline void *
pci_alloc_consistent(struct pci_dev *hwdev, size_t size,
		     dma_addr_t *dma_handle)
{
	return dma_alloc_coherent(hwdev == NULL ? NULL : &hwdev->dev, size, dma_handle, GFP_ATOMIC);
    1d2b:	85 c0                	test   %eax,%eax
    1d2d:	0f 84 1d 02 00 00    	je     1f50 <mptstm_probe+0x310>
    1d33:	8d 78 64             	lea    0x64(%eax),%edi
extern struct dma_map_ops *dma_ops;

static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
    1d36:	a1 00 00 00 00       	mov    0x0,%eax
	struct dma_map_ops *ops = get_dma_ops(dev);
	void *memory;

	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM | __GFP_DMA32);

	if (dma_alloc_from_coherent(dev, size, dma_handle, &memory))
    1d3b:	ba 80 20 02 00       	mov    $0x22080,%edx
extern struct dma_map_ops *dma_ops;

static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
    1d40:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct dma_map_ops *ops = get_dma_ops(dev);
	void *memory;

	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM | __GFP_DMA32);

	if (dma_alloc_from_coherent(dev, size, dma_handle, &memory))
    1d43:	8d 45 f0             	lea    -0x10(%ebp),%eax
    1d46:	89 04 24             	mov    %eax,(%esp)
    1d49:	89 f8                	mov    %edi,%eax
    1d4b:	e8 fc ff ff ff       	call   1d4c <mptstm_probe+0x10c>
    1d50:	85 c0                	test   %eax,%eax
    1d52:	0f 85 28 02 00 00    	jne    1f80 <mptstm_probe+0x340>
}

#define dma_alloc_coherent(d,s,h,f)	dma_alloc_attrs(d,s,h,f,NULL)

static inline void *
dma_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,
    1d58:	8b 87 1c 01 00 00    	mov    0x11c(%edi),%eax
		(dma_direction == DMA_FROM_DEVICE));
}

static inline int is_device_dma_capable(struct device *dev)
{
	return dev->dma_mask != NULL && *dev->dma_mask != DMA_MASK_NONE;
    1d5e:	85 c0                	test   %eax,%eax
    1d60:	0f 84 c2 01 00 00    	je     1f28 <mptstm_probe+0x2e8>
    1d66:	8b 50 04             	mov    0x4(%eax),%edx
    1d69:	0b 10                	or     (%eax),%edx
    1d6b:	0f 84 b7 01 00 00    	je     1f28 <mptstm_probe+0x2e8>
		dev = &x86_dma_fallback_dev;

	if (!is_device_dma_capable(dev))
		return NULL;

	if (!ops->alloc)
    1d71:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1d74:	8b 00                	mov    (%eax),%eax
    1d76:	85 c0                	test   %eax,%eax
    1d78:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1d7b:	0f 84 a7 01 00 00    	je     1f28 <mptstm_probe+0x2e8>
						    gfp_t gfp)
{
	unsigned long dma_mask = 0;

	dma_mask = dev->coherent_dma_mask;
	if (!dma_mask)
    1d81:	8b 87 20 01 00 00    	mov    0x120(%edi),%eax
		return NULL;

	if (!ops->alloc)
		return NULL;

	memory = ops->alloc(dev, size, dma_handle,
    1d87:	ba 80 20 02 00       	mov    $0x22080,%edx
    1d8c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    1d8f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    1d96:	00 
						    gfp_t gfp)
{
	unsigned long dma_mask = 0;

	dma_mask = dev->coherent_dma_mask;
	if (!dma_mask)
    1d97:	83 e8 01             	sub    $0x1,%eax
    1d9a:	3d ff ff ff 00       	cmp    $0xffffff,%eax
    1d9f:	19 c0                	sbb    %eax,%eax
    1da1:	f7 d0                	not    %eax
    1da3:	83 c0 21             	add    $0x21,%eax
		return NULL;

	if (!ops->alloc)
		return NULL;

	memory = ops->alloc(dev, size, dma_handle,
    1da6:	89 04 24             	mov    %eax,(%esp)
    1da9:	89 f8                	mov    %edi,%eax
    1dab:	8b 7d e8             	mov    -0x18(%ebp),%edi
    1dae:	ff d7                	call   *%edi
					&priv->hw_dma);
	if (priv->hw == NULL) {
    1db0:	85 c0                	test   %eax,%eax
		priv->num_cmd_buffers = ioc->req_depth - 16;
	priv->num_els_buffers = NUM_ELS_BUFFERS;

	priv->poll_enabled = 1;

	priv->hw = pci_alloc_consistent(ioc->pcidev, sizeof(*priv->hw),
    1db2:	89 43 20             	mov    %eax,0x20(%ebx)
					&priv->hw_dma);
	if (priv->hw == NULL) {
    1db5:	0f 84 74 01 00 00    	je     1f2f <mptstm_probe+0x2ef>
		printk(KERN_ERR MYNAM
		       ":%s failed to allocate hardware structure\n", ioc->name);
		kfree(priv);
		return -1;
	}
	memset(priv->hw, 0, sizeof(*priv->hw));
    1dbb:	31 d2                	xor    %edx,%edx
    1dbd:	b9 80 20 02 00       	mov    $0x22080,%ecx
    1dc2:	e8 fc ff ff ff       	call   1dc3 <mptstm_probe+0x183>
	printk(KERN_INFO ":%s priv = %p, priv->hw = %p, priv->hw_dma = %llx\n",
    1dc7:	8b 43 24             	mov    0x24(%ebx),%eax
    1dca:	8b 53 28             	mov    0x28(%ebx),%edx
    1dcd:	89 44 24 10          	mov    %eax,0x10(%esp)
    1dd1:	89 54 24 14          	mov    %edx,0x14(%esp)
    1dd5:	8b 43 20             	mov    0x20(%ebx),%eax
    1dd8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    1ddc:	c7 04 24 c8 05 00 00 	movl   $0x5c8,(%esp)
    1de3:	89 44 24 0c          	mov    %eax,0xc(%esp)
	       ioc->name, priv, priv->hw, (u64)priv->hw_dma);
    1de7:	8d 46 08             	lea    0x8(%esi),%eax
    1dea:	89 44 24 04          	mov    %eax,0x4(%esp)
		       ":%s failed to allocate hardware structure\n", ioc->name);
		kfree(priv);
		return -1;
	}
	memset(priv->hw, 0, sizeof(*priv->hw));
	printk(KERN_INFO ":%s priv = %p, priv->hw = %p, priv->hw_dma = %llx\n",
    1dee:	e8 fc ff ff ff       	call   1def <mptstm_probe+0x1af>
	       ioc->name, priv, priv->hw, (u64)priv->hw_dma);

	mpt_stm_priv[ioc->id] = priv;
    1df3:	8b 06                	mov    (%esi),%eax
    1df5:	89 1c 85 20 00 00 00 	mov    %ebx,0x20(,%eax,4)

	max_aliases = 0;
	if (IsScsi(priv))
    1dfc:	8b 03                	mov    (%ebx),%eax
    1dfe:	0f b6 80 69 03 00 00 	movzbl 0x369(%eax),%eax
    1e05:	3c 01                	cmp    $0x1,%al
    1e07:	74 08                	je     1e11 <mptstm_probe+0x1d1>
		max_aliases = 14;
	if (IsFc(priv)) {
    1e09:	3c 10                	cmp    $0x10,%al
    1e0b:	0f 84 97 01 00 00    	je     1fa8 <mptstm_probe+0x368>
	}

	if (num_aliases < max_aliases)
		priv->num_aliases = num_aliases;
	else
		priv->num_aliases = max_aliases;
    1e11:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
    1e18:	a1 2c 00 00 00       	mov    0x2c,%eax
    1e1d:	b9 28 04 00 00       	mov    $0x428,%ecx
    1e22:	ba d0 00 00 00       	mov    $0xd0,%edx
    1e27:	e8 fc ff ff ff       	call   1e28 <mptstm_probe+0x1e8>
		goto out;

	tgt = kmalloc(sizeof(*tgt), GFP_KERNEL);
	TRACE_MEM("kmalloc(GFP_KERNEL) for tgt (%zd), %p",
		  sizeof(*tgt), tgt);
	if (tgt == NULL) {
    1e2c:	85 c0                	test   %eax,%eax
    1e2e:	89 c3                	mov    %eax,%ebx
    1e30:	0f 84 02 02 00 00    	je     2038 <mptstm_probe+0x3f8>
		TRACE(TRACE_OUT_OF_MEM, "%s",
		      "Allocation of tgt failed");
		ret = -ENOMEM;
		goto out;
	}
	memset(tgt, 0, sizeof(*tgt));
    1e36:	f6 c3 01             	test   $0x1,%bl
    1e39:	89 df                	mov    %ebx,%edi
    1e3b:	ba 28 04 00 00       	mov    $0x428,%edx
    1e40:	0f 85 52 02 00 00    	jne    2098 <mptstm_probe+0x458>
    1e46:	f7 c7 02 00 00 00    	test   $0x2,%edi
    1e4c:	0f 85 2e 02 00 00    	jne    2080 <mptstm_probe+0x440>
    1e52:	89 d1                	mov    %edx,%ecx
    1e54:	31 c0                	xor    %eax,%eax
    1e56:	c1 e9 02             	shr    $0x2,%ecx
    1e59:	f6 c2 02             	test   $0x2,%dl
    1e5c:	f3 ab                	rep stos %eax,%es:(%edi)
    1e5e:	0f 85 2c 01 00 00    	jne    1f90 <mptstm_probe+0x350>
    1e64:	83 e2 01             	and    $0x1,%edx
    1e67:	0f 85 1b 01 00 00    	jne    1f88 <mptstm_probe+0x348>
	tgt->priv = mpt_stm_priv[ioc->id];
    1e6d:	8b 06                	mov    (%esi),%eax
	/* tgt->priv->scsi_port_config = MPI_SCSIPORTPAGE1_TARGCONFIG_INIT_TARG; */
	tgt->priv->scsi_port_config = MPI_SCSIPORTPAGE1_TARGCONFIG_TARG_ONLY;
	/* tgt->priv->scsi_id_config = 0x7; */
	tgt->priv->scsi_id_config = 0;
	atomic_set(&tgt->sess_count, 0);
	init_waitqueue_head(&tgt->waitQ);
    1e6f:	b9 0e 00 00 00       	mov    $0xe,%ecx
    1e74:	ba e4 00 00 00       	mov    $0xe4,%edx
		ret = -ENOMEM;
		goto out;
	}
	memset(tgt, 0, sizeof(*tgt));
	tgt->priv = mpt_stm_priv[ioc->id];
	tgt->target_enable = 0;
    1e79:	c7 83 24 04 00 00 00 	movl   $0x0,0x424(%ebx)
    1e80:	00 00 00 
		      "Allocation of tgt failed");
		ret = -ENOMEM;
		goto out;
	}
	memset(tgt, 0, sizeof(*tgt));
	tgt->priv = mpt_stm_priv[ioc->id];
    1e83:	8b 04 85 20 00 00 00 	mov    0x20(,%eax,4),%eax
    1e8a:	89 43 04             	mov    %eax,0x4(%ebx)
	tgt->target_enable = 0;
	tgt->priv->port_id = 1;
    1e8d:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
	/* tgt->priv->scsi_port_config = MPI_SCSIPORTPAGE1_TARGCONFIG_INIT_TARG; */
	tgt->priv->scsi_port_config = MPI_SCSIPORTPAGE1_TARGCONFIG_TARG_ONLY;
    1e94:	8b 43 04             	mov    0x4(%ebx),%eax
    1e97:	c7 40 40 01 00 00 00 	movl   $0x1,0x40(%eax)
	/* tgt->priv->scsi_id_config = 0x7; */
	tgt->priv->scsi_id_config = 0;
    1e9e:	8b 43 04             	mov    0x4(%ebx),%eax
    1ea1:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	atomic_set(&tgt->sess_count, 0);
	init_waitqueue_head(&tgt->waitQ);
    1ea8:	8d 43 18             	lea    0x18(%ebx),%eax
    1eab:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    1eb2:	e8 fc ff ff ff       	call   1eb3 <mptstm_probe+0x273>

	tgt->scst_tgt = scst_register_target(&tgt_template, MYNAM);
    1eb7:	ba f0 00 00 00       	mov    $0xf0,%edx
    1ebc:	b8 20 00 00 00       	mov    $0x20,%eax
    1ec1:	e8 fc ff ff ff       	call   1ec2 <mptstm_probe+0x282>
	if (tgt->scst_tgt == NULL) {
    1ec6:	85 c0                	test   %eax,%eax
	/* tgt->priv->scsi_id_config = 0x7; */
	tgt->priv->scsi_id_config = 0;
	atomic_set(&tgt->sess_count, 0);
	init_waitqueue_head(&tgt->waitQ);

	tgt->scst_tgt = scst_register_target(&tgt_template, MYNAM);
    1ec8:	89 03                	mov    %eax,(%ebx)
	if (tgt->scst_tgt == NULL) {
    1eca:	0f 84 fc 01 00 00    	je     20cc <mptstm_probe+0x48c>
	return tgt->tgt_priv;
}

static inline void scst_tgt_set_tgt_priv(struct scst_tgt *tgt, void *val)
{
	tgt->tgt_priv = val;
    1ed0:	89 58 34             	mov    %ebx,0x34(%eax)
		goto out;
	}
#endif

	scst_tgt_set_tgt_priv(tgt->scst_tgt, tgt);
	mpt_stm_priv[ioc->id]->tgt = tgt;
    1ed3:	8b 06                	mov    (%esi),%eax
	_mpt_ada_nums++;
    1ed5:	83 05 10 00 00 00 01 	addl   $0x1,0x10
		goto out;
	}
#endif

	scst_tgt_set_tgt_priv(tgt->scst_tgt, tgt);
	mpt_stm_priv[ioc->id]->tgt = tgt;
    1edc:	8b 04 85 20 00 00 00 	mov    0x20(,%eax,4),%eax
    1ee3:	89 98 0c 0c 00 00    	mov    %ebx,0xc0c(%eax)
	_mpt_ada_nums++;
    1ee9:	31 c0                	xor    %eax,%eax
out:

	TRACE_EXIT_RES(ret);

	return ret;
}
    1eeb:	83 c4 2c             	add    $0x2c,%esp
    1eee:	5b                   	pop    %ebx
    1eef:	5e                   	pop    %esi
    1ef0:	5f                   	pop    %edi
    1ef1:	5d                   	pop    %ebp
    1ef2:	c3                   	ret    
    1ef3:	90                   	nop
    1ef4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	priv->num_sge_target_assist = (ioc->req_sz -
				       offsetof(TargetAssistRequest_t, SGL)) / sizeof(MPT_STM_SIMPLE);

	priv->num_cmd_buffers = NUM_CMD_BUFFERS;
	if (priv->num_cmd_buffers > ioc->pfacts[0].MaxPostedCmdBuffers)
		priv->num_cmd_buffers = ioc->pfacts[0].MaxPostedCmdBuffers;
    1ef8:	89 43 14             	mov    %eax,0x14(%ebx)
    1efb:	e9 ff fd ff ff       	jmp    1cff <mptstm_probe+0xbf>
	if (priv == NULL) {
		printk(KERN_ERR MYNAM
		       ":%s failed to allocate private structure\n", ioc->name);
		return -ENOMEM;
	}
	memset(priv, 0, sizeof(*priv));
    1f00:	31 c0                	xor    %eax,%eax
    1f02:	83 c7 02             	add    $0x2,%edi
    1f05:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    1f09:	83 e2 01             	and    $0x1,%edx
    1f0c:	0f 84 99 fd ff ff    	je     1cab <mptstm_probe+0x6b>
    1f12:	c6 07 00             	movb   $0x0,(%edi)
	if (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_TARGET)
    1f15:	f6 86 6e 03 00 00 04 	testb  $0x4,0x36e(%esi)
    1f1c:	0f 84 99 fd ff ff    	je     1cbb <mptstm_probe+0x7b>
    1f22:	e9 8d fd ff ff       	jmp    1cb4 <mptstm_probe+0x74>
    1f27:	90                   	nop
		priv->num_cmd_buffers = ioc->req_depth - 16;
	priv->num_els_buffers = NUM_ELS_BUFFERS;

	priv->poll_enabled = 1;

	priv->hw = pci_alloc_consistent(ioc->pcidev, sizeof(*priv->hw),
    1f28:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
					&priv->hw_dma);
	if (priv->hw == NULL) {
		printk(KERN_ERR MYNAM
		       ":%s failed to allocate hardware structure\n", ioc->name);
    1f2f:	83 c6 08             	add    $0x8,%esi
    1f32:	89 74 24 04          	mov    %esi,0x4(%esp)
	priv->poll_enabled = 1;

	priv->hw = pci_alloc_consistent(ioc->pcidev, sizeof(*priv->hw),
					&priv->hw_dma);
	if (priv->hw == NULL) {
		printk(KERN_ERR MYNAM
    1f36:	c7 04 24 90 05 00 00 	movl   $0x590,(%esp)
    1f3d:	e8 fc ff ff ff       	call   1f3e <mptstm_probe+0x2fe>
		       ":%s failed to allocate hardware structure\n", ioc->name);
		kfree(priv);
    1f42:	89 d8                	mov    %ebx,%eax
    1f44:	e8 fc ff ff ff       	call   1f45 <mptstm_probe+0x305>
		return -1;
    1f49:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1f4e:	eb 9b                	jmp    1eeb <mptstm_probe+0x2ab>
extern struct dma_map_ops *dma_ops;

static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
    1f50:	a1 00 00 00 00       	mov    0x0,%eax
	struct dma_map_ops *ops = get_dma_ops(dev);
	void *memory;

	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM | __GFP_DMA32);

	if (dma_alloc_from_coherent(dev, size, dma_handle, &memory))
    1f55:	ba 80 20 02 00       	mov    $0x22080,%edx
		return memory;

	if (!dev)
		dev = &x86_dma_fallback_dev;
    1f5a:	bf 00 00 00 00       	mov    $0x0,%edi
	struct dma_map_ops *ops = get_dma_ops(dev);
	void *memory;

	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM | __GFP_DMA32);

	if (dma_alloc_from_coherent(dev, size, dma_handle, &memory))
    1f5f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
extern struct dma_map_ops *dma_ops;

static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
    1f62:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct dma_map_ops *ops = get_dma_ops(dev);
	void *memory;

	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM | __GFP_DMA32);

	if (dma_alloc_from_coherent(dev, size, dma_handle, &memory))
    1f65:	8d 45 f0             	lea    -0x10(%ebp),%eax
    1f68:	89 04 24             	mov    %eax,(%esp)
    1f6b:	31 c0                	xor    %eax,%eax
    1f6d:	e8 fc ff ff ff       	call   1f6e <mptstm_probe+0x32e>
    1f72:	85 c0                	test   %eax,%eax
    1f74:	0f 84 de fd ff ff    	je     1d58 <mptstm_probe+0x118>
    1f7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		return memory;
    1f80:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1f83:	e9 28 fe ff ff       	jmp    1db0 <mptstm_probe+0x170>
		TRACE(TRACE_OUT_OF_MEM, "%s",
		      "Allocation of tgt failed");
		ret = -ENOMEM;
		goto out;
	}
	memset(tgt, 0, sizeof(*tgt));
    1f88:	c6 07 00             	movb   $0x0,(%edi)
    1f8b:	e9 dd fe ff ff       	jmp    1e6d <mptstm_probe+0x22d>
    1f90:	31 c0                	xor    %eax,%eax
    1f92:	83 c7 02             	add    $0x2,%edi
    1f95:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    1f99:	83 e2 01             	and    $0x1,%edx
    1f9c:	0f 84 cb fe ff ff    	je     1e6d <mptstm_probe+0x22d>
    1fa2:	eb e4                	jmp    1f88 <mptstm_probe+0x348>
    1fa4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	max_aliases = 0;
	if (IsScsi(priv))
		max_aliases = 14;
	if (IsFc(priv)) {
		memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    1fa8:	8b 43 20             	mov    0x20(%ebx),%eax
    1fab:	ba 00 04 00 00       	mov    $0x400,%edx
    1fb0:	8d b8 00 18 02 00    	lea    0x21800(%eax),%edi
    1fb6:	f7 c7 01 00 00 00    	test   $0x1,%edi
    1fbc:	0f 85 e3 00 00 00    	jne    20a5 <mptstm_probe+0x465>
    1fc2:	f7 c7 02 00 00 00    	test   $0x2,%edi
    1fc8:	0f 85 ed 00 00 00    	jne    20bb <mptstm_probe+0x47b>
    1fce:	89 d1                	mov    %edx,%ecx
    1fd0:	31 c0                	xor    %eax,%eax
    1fd2:	c1 e9 02             	shr    $0x2,%ecx
    1fd5:	f6 c2 02             	test   $0x2,%dl
    1fd8:	f3 ab                	rep stos %eax,%es:(%edi)
    1fda:	74 09                	je     1fe5 <mptstm_probe+0x3a5>
    1fdc:	31 c0                	xor    %eax,%eax
    1fde:	83 c7 02             	add    $0x2,%edi
    1fe1:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    1fe5:	83 e2 01             	and    $0x1,%edx
    1fe8:	74 03                	je     1fed <mptstm_probe+0x3ad>
    1fea:	c6 07 00             	movb   $0x0,(%edi)
		if (!stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_FC_PORT, 0, 0,
    1fed:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    1ff4:	31 c9                	xor    %ecx,%ecx
    1ff6:	ba 05 00 00 00       	mov    $0x5,%edx
    1ffb:	89 d8                	mov    %ebx,%eax
    1ffd:	e8 ce f9 ff ff       	call   19d0 <stm_get_config_page.constprop.50>
    2002:	e9 0a fe ff ff       	jmp    1e11 <mptstm_probe+0x1d1>
    2007:	90                   	nop
	if (priv == NULL) {
		printk(KERN_ERR MYNAM
		       ":%s failed to allocate private structure\n", ioc->name);
		return -ENOMEM;
	}
	memset(priv, 0, sizeof(*priv));
    2008:	8d 78 01             	lea    0x1(%eax),%edi
    200b:	b2 4f                	mov    $0x4f,%dl
    200d:	f7 c7 02 00 00 00    	test   $0x2,%edi
    2013:	c6 00 00             	movb   $0x0,(%eax)
    2016:	0f 84 74 fc ff ff    	je     1c90 <mptstm_probe+0x50>
    201c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    2020:	31 c0                	xor    %eax,%eax
    2022:	83 c7 02             	add    $0x2,%edi
    2025:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    2029:	83 ea 02             	sub    $0x2,%edx
    202c:	e9 5f fc ff ff       	jmp    1c90 <mptstm_probe+0x50>
    2031:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	tgt = kmalloc(sizeof(*tgt), GFP_KERNEL);
	TRACE_MEM("kmalloc(GFP_KERNEL) for tgt (%zd), %p",
		  sizeof(*tgt), tgt);
	if (tgt == NULL) {
		TRACE(TRACE_OUT_OF_MEM, "%s",
    2038:	c7 44 24 18 c8 00 00 	movl   $0xc8,0x18(%esp)
    203f:	00 
    2040:	c7 44 24 14 e1 00 00 	movl   $0xe1,0x14(%esp)
    2047:	00 
    2048:	c7 44 24 10 74 01 00 	movl   $0x174,0x10(%esp)
    204f:	00 
    2050:	c7 44 24 0c 42 03 00 	movl   $0x342,0xc(%esp)
    2057:	00 
    2058:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    205f:	00 
    2060:	c7 44 24 04 a5 00 00 	movl   $0xa5,0x4(%esp)
    2067:	00 
    2068:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
    206f:	e8 fc ff ff ff       	call   2070 <mptstm_probe+0x430>
		      "Allocation of tgt failed");
		ret = -ENOMEM;
    2074:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    2079:	e9 6d fe ff ff       	jmp    1eeb <mptstm_probe+0x2ab>
    207e:	66 90                	xchg   %ax,%ax
		goto out;
	}
	memset(tgt, 0, sizeof(*tgt));
    2080:	31 c9                	xor    %ecx,%ecx
    2082:	83 c7 02             	add    $0x2,%edi
    2085:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    2089:	83 ea 02             	sub    $0x2,%edx
    208c:	e9 c1 fd ff ff       	jmp    1e52 <mptstm_probe+0x212>
    2091:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    2098:	c6 03 00             	movb   $0x0,(%ebx)
    209b:	8d 7b 01             	lea    0x1(%ebx),%edi
    209e:	b2 27                	mov    $0x27,%dl
    20a0:	e9 a1 fd ff ff       	jmp    1e46 <mptstm_probe+0x206>

	max_aliases = 0;
	if (IsScsi(priv))
		max_aliases = 14;
	if (IsFc(priv)) {
		memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    20a5:	c6 80 00 18 02 00 00 	movb   $0x0,0x21800(%eax)
    20ac:	8d b8 01 18 02 00    	lea    0x21801(%eax),%edi
    20b2:	66 ba ff 03          	mov    $0x3ff,%dx
    20b6:	e9 07 ff ff ff       	jmp    1fc2 <mptstm_probe+0x382>
    20bb:	31 c0                	xor    %eax,%eax
    20bd:	83 c7 02             	add    $0x2,%edi
    20c0:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    20c4:	83 ea 02             	sub    $0x2,%edx
    20c7:	e9 02 ff ff ff       	jmp    1fce <mptstm_probe+0x38e>
	atomic_set(&tgt->sess_count, 0);
	init_waitqueue_head(&tgt->waitQ);

	tgt->scst_tgt = scst_register_target(&tgt_template, MYNAM);
	if (tgt->scst_tgt == NULL) {
		PRINT_ERROR(MYNAM ": scst_register_target() failed for host %p",
    20cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    20cf:	c7 44 24 14 00 06 00 	movl   $0x600,0x14(%esp)
    20d6:	00 
    20d7:	c7 44 24 10 86 01 00 	movl   $0x186,0x10(%esp)
    20de:	00 
    20df:	c7 44 24 0c 42 03 00 	movl   $0x342,0xc(%esp)
    20e6:	00 
    20e7:	89 44 24 18          	mov    %eax,0x18(%esp)
    20eb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    20f2:	00 
    20f3:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
    20fa:	00 
    20fb:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
    2102:	e8 fc ff ff ff       	call   2103 <mptstm_probe+0x4c3>
			    pdev);

		ret = -ENODEV;
    2107:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
		goto out;
    210c:	e9 da fd ff ff       	jmp    1eeb <mptstm_probe+0x2ab>

	TRACE_ENTRY();
	priv = kmalloc(sizeof(*priv), GFP_KERNEL);
	if (priv == NULL) {
		printk(KERN_ERR MYNAM
		       ":%s failed to allocate private structure\n", ioc->name);
    2111:	83 c6 08             	add    $0x8,%esi
    2114:	89 74 24 04          	mov    %esi,0x4(%esp)
	int				max_aliases;

	TRACE_ENTRY();
	priv = kmalloc(sizeof(*priv), GFP_KERNEL);
	if (priv == NULL) {
		printk(KERN_ERR MYNAM
    2118:	c7 04 24 5c 05 00 00 	movl   $0x55c,(%esp)
    211f:	e8 fc ff ff ff       	call   2120 <mptstm_probe+0x4e0>
		       ":%s failed to allocate private structure\n", ioc->name);
		return -ENOMEM;
    2124:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
    2129:	e9 bd fd ff ff       	jmp    1eeb <mptstm_probe+0x2ab>
    212e:	66 90                	xchg   %ax,%ax

00002130 <stm_set_config_page.constprop.47>:

	return 0;
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_set_config_page(MPT_STM_PRIV *priv, int type, int number,
    2130:	55                   	push   %ebp
    2131:	89 e5                	mov    %esp,%ebp
    2133:	57                   	push   %edi
    2134:	56                   	push   %esi
    2135:	53                   	push   %ebx
    2136:	83 ec 20             	sub    $0x20,%esp
    2139:	e8 fc ff ff ff       	call   213a <stm_set_config_page.constprop.47+0xa>
    213e:	89 c3                	mov    %eax,%ebx
			       int address, int sleep)
{
	MPT_ADAPTER		*ioc = priv->ioc;
    2140:	8b 00                	mov    (%eax),%eax

	return 0;
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_set_config_page(MPT_STM_PRIV *priv, int type, int number,
    2142:	89 d6                	mov    %edx,%esi
	int			i;
	int			length;

	TRACE_ENTRY();
	rep = &priv->config_rep;
	memset(rep, 0, sizeof(*rep));
    2144:	8d 93 88 00 00 00    	lea    0x88(%ebx),%edx
    214a:	f6 c2 01             	test   $0x1,%dl

	return 0;
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_set_config_page(MPT_STM_PRIV *priv, int type, int number,
    214d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	int			i;
	int			length;

	TRACE_ENTRY();
	rep = &priv->config_rep;
	memset(rep, 0, sizeof(*rep));
    2150:	b9 18 00 00 00       	mov    $0x18,%ecx

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_set_config_page(MPT_STM_PRIV *priv, int type, int number,
			       int address, int sleep)
{
	MPT_ADAPTER		*ioc = priv->ioc;
    2155:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int			i;
	int			length;

	TRACE_ENTRY();
	rep = &priv->config_rep;
	memset(rep, 0, sizeof(*rep));
    2158:	0f 85 6a 01 00 00    	jne    22c8 <stm_set_config_page.constprop.47+0x198>
    215e:	f6 c2 02             	test   $0x2,%dl
    2161:	0f 85 79 01 00 00    	jne    22e0 <stm_set_config_page.constprop.47+0x1b0>
    2167:	89 cf                	mov    %ecx,%edi
    2169:	31 c0                	xor    %eax,%eax
    216b:	83 e7 fc             	and    $0xfffffffc,%edi
    216e:	c7 04 02 00 00 00 00 	movl   $0x0,(%edx,%eax,1)
    2175:	83 c0 04             	add    $0x4,%eax
    2178:	39 f8                	cmp    %edi,%eax
    217a:	72 f2                	jb     216e <stm_set_config_page.constprop.47+0x3e>
    217c:	01 c2                	add    %eax,%edx
    217e:	f6 c1 02             	test   $0x2,%cl
    2181:	74 09                	je     218c <stm_set_config_page.constprop.47+0x5c>
    2183:	31 c0                	xor    %eax,%eax
    2185:	83 c2 02             	add    $0x2,%edx
    2188:	66 89 42 fe          	mov    %ax,-0x2(%edx)
    218c:	83 e1 01             	and    $0x1,%ecx
    218f:	74 03                	je     2194 <stm_set_config_page.constprop.47+0x64>
    2191:	c6 02 00             	movb   $0x0,(%edx)

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_HEADER,
    2194:	8b 45 08             	mov    0x8(%ebp),%eax
    2197:	31 d2                	xor    %edx,%edx
    2199:	89 f1                	mov    %esi,%ecx
    219b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    21a2:	00 
    21a3:	89 44 24 04          	mov    %eax,0x4(%esp)
    21a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    21aa:	89 04 24             	mov    %eax,(%esp)
    21ad:	89 d8                	mov    %ebx,%eax
    21af:	e8 fc f5 ff ff       	call   17b0 <stm_do_config_action.constprop.51>
				 type, number, address, 0, sleep);
	if (i) {
    21b4:	85 c0                	test   %eax,%eax
		if (!priv->in_reset) {
    21b6:	8b 43 78             	mov    0x78(%ebx),%eax
	rep = &priv->config_rep;
	memset(rep, 0, sizeof(*rep));

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_HEADER,
				 type, number, address, 0, sleep);
	if (i) {
    21b9:	74 15                	je     21d0 <stm_set_config_page.constprop.47+0xa0>
		if (!priv->in_reset) {
    21bb:	85 c0                	test   %eax,%eax
    21bd:	0f 84 ec 01 00 00    	je     23af <stm_set_config_page.constprop.47+0x27f>
		       ":%s   type = %d, number = %d, address = %x\n",
		       ioc->name, type, number, address);
		printk(KERN_ERR MYNAM
		       ":%s   Header = %08x\n",
		       ioc->name, le32_to_cpu(*(u32 *)priv->hw->config_buf));
		return -1;
    21c3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
#endif
	TRACE_EXIT();

	return 0;
}
    21c8:	83 c4 20             	add    $0x20,%esp
    21cb:	5b                   	pop    %ebx
    21cc:	5e                   	pop    %esi
    21cd:	5f                   	pop    %edi
    21ce:	5d                   	pop    %ebp
    21cf:	c3                   	ret    
			       ":%s timed out getting config page header\n", ioc->name);
		}
		return -1;
	}

	if (priv->in_reset) {
    21d0:	85 c0                	test   %eax,%eax
    21d2:	0f 85 b9 01 00 00    	jne    2391 <stm_set_config_page.constprop.47+0x261>
		printk(KERN_ERR MYNAM
		       ":%s reset while getting config page header\n", ioc->name);
		return -1;
	}

	ioc_status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
    21d8:	0f b7 93 96 00 00 00 	movzwl 0x96(%ebx),%edx
    21df:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
	if (type > MPI_CONFIG_PAGETYPE_EXTENDED)
    21e5:	83 fe 0f             	cmp    $0xf,%esi
    21e8:	7e 6e                	jle    2258 <stm_set_config_page.constprop.47+0x128>
		length = le16_to_cpu(rep->ExtPageLength);
    21ea:	0f b7 bb 8c 00 00 00 	movzwl 0x8c(%ebx),%edi
	else
		length = rep->Header.PageLength;
	if (ioc_status != MPI_IOCSTATUS_SUCCESS || length == 0) {
    21f1:	85 ff                	test   %edi,%edi
    21f3:	75 6e                	jne    2263 <stm_set_config_page.constprop.47+0x133>
		if (ioc_status != MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {
    21f5:	83 fa 22             	cmp    $0x22,%edx
    21f8:	74 c9                	je     21c3 <stm_set_config_page.constprop.47+0x93>
			printk(KERN_ERR MYNAM
			       ":%s failed to get config page header\n", ioc->name);
    21fa:	8b 5d ec             	mov    -0x14(%ebp),%ebx
		length = le16_to_cpu(rep->ExtPageLength);
	else
		length = rep->Header.PageLength;
	if (ioc_status != MPI_IOCSTATUS_SUCCESS || length == 0) {
		if (ioc_status != MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {
			printk(KERN_ERR MYNAM
    21fd:	c7 04 24 30 04 00 00 	movl   $0x430,(%esp)
    2204:	89 55 e8             	mov    %edx,-0x18(%ebp)
			       ":%s failed to get config page header\n", ioc->name);
    2207:	83 c3 08             	add    $0x8,%ebx
		length = le16_to_cpu(rep->ExtPageLength);
	else
		length = rep->Header.PageLength;
	if (ioc_status != MPI_IOCSTATUS_SUCCESS || length == 0) {
		if (ioc_status != MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {
			printk(KERN_ERR MYNAM
    220a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    220e:	e8 fc ff ff ff       	call   220f <stm_set_config_page.constprop.47+0xdf>
			       ":%s failed to get config page header\n", ioc->name);
			printk(KERN_ERR MYNAM
    2213:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2216:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    221a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    221e:	c7 04 24 60 04 00 00 	movl   $0x460,(%esp)
    2225:	89 54 24 08          	mov    %edx,0x8(%esp)
    2229:	e8 fc ff ff ff       	call   222a <stm_set_config_page.constprop.47+0xfa>
			       ":%s   IOCStatus = %04x, PageLength = %x\n",
			       ioc->name, ioc_status, length);
			printk(KERN_ERR MYNAM
    222e:	8b 45 08             	mov    0x8(%ebp),%eax
    2231:	89 74 24 08          	mov    %esi,0x8(%esp)
    2235:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    2239:	c7 04 24 94 04 00 00 	movl   $0x494,(%esp)
    2240:	89 44 24 10          	mov    %eax,0x10(%esp)
    2244:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2247:	89 44 24 0c          	mov    %eax,0xc(%esp)
    224b:	e8 fc ff ff ff       	call   224c <stm_set_config_page.constprop.47+0x11c>
			       ":%s   type = %d, number = %d, address = %x\n",
			       ioc->name, type, number, address);
		}
		return -1;
    2250:	83 c8 ff             	or     $0xffffffff,%eax
    2253:	e9 70 ff ff ff       	jmp    21c8 <stm_set_config_page.constprop.47+0x98>

	ioc_status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
	if (type > MPI_CONFIG_PAGETYPE_EXTENDED)
		length = le16_to_cpu(rep->ExtPageLength);
	else
		length = rep->Header.PageLength;
    2258:	0f b6 bb 9d 00 00 00 	movzbl 0x9d(%ebx),%edi
	if (ioc_status != MPI_IOCSTATUS_SUCCESS || length == 0) {
    225f:	85 ff                	test   %edi,%edi
    2261:	74 92                	je     21f5 <stm_set_config_page.constprop.47+0xc5>
    2263:	85 d2                	test   %edx,%edx
    2265:	75 8e                	jne    21f5 <stm_set_config_page.constprop.47+0xc5>
			       ioc->name, type, number, address);
		}
		return -1;
	}

	*(ConfigPageHeader_t *)priv->hw->config_buf = rep->Header;
    2267:	8b 43 20             	mov    0x20(%ebx),%eax

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT,
    226a:	89 f1                	mov    %esi,%ecx
			       ioc->name, type, number, address);
		}
		return -1;
	}

	*(ConfigPageHeader_t *)priv->hw->config_buf = rep->Header;
    226c:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
    2272:	89 90 00 18 02 00    	mov    %edx,0x21800(%eax)

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT,
    2278:	8b 45 08             	mov    0x8(%ebp),%eax
    227b:	ba 02 00 00 00       	mov    $0x2,%edx
    2280:	89 7c 24 08          	mov    %edi,0x8(%esp)
    2284:	89 44 24 04          	mov    %eax,0x4(%esp)
    2288:	8b 45 f0             	mov    -0x10(%ebp),%eax
    228b:	89 04 24             	mov    %eax,(%esp)
    228e:	89 d8                	mov    %ebx,%eax
    2290:	e8 1b f5 ff ff       	call   17b0 <stm_do_config_action.constprop.51>
				 type, number, address, length, sleep);
	if (i) {
    2295:	85 c0                	test   %eax,%eax
		if (!priv->in_reset)
    2297:	8b 43 78             	mov    0x78(%ebx),%eax

	*(ConfigPageHeader_t *)priv->hw->config_buf = rep->Header;

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT,
				 type, number, address, length, sleep);
	if (i) {
    229a:	74 5c                	je     22f8 <stm_set_config_page.constprop.47+0x1c8>
		if (!priv->in_reset)
    229c:	85 c0                	test   %eax,%eax
    229e:	0f 85 1f ff ff ff    	jne    21c3 <stm_set_config_page.constprop.47+0x93>
			printk(KERN_ERR MYNAM
			       ":%s timed out setting config page\n", ioc->name);
    22a4:	8b 45 ec             	mov    -0x14(%ebp),%eax

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT,
				 type, number, address, length, sleep);
	if (i) {
		if (!priv->in_reset)
			printk(KERN_ERR MYNAM
    22a7:	c7 04 24 44 06 00 00 	movl   $0x644,(%esp)
			       ":%s timed out setting config page\n", ioc->name);
    22ae:	83 c0 08             	add    $0x8,%eax
    22b1:	89 44 24 04          	mov    %eax,0x4(%esp)

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT,
				 type, number, address, length, sleep);
	if (i) {
		if (!priv->in_reset)
			printk(KERN_ERR MYNAM
    22b5:	e8 fc ff ff ff       	call   22b6 <stm_set_config_page.constprop.47+0x186>
			       ":%s timed out setting config page\n", ioc->name);
		return -1;
    22ba:	83 c8 ff             	or     $0xffffffff,%eax
    22bd:	e9 06 ff ff ff       	jmp    21c8 <stm_set_config_page.constprop.47+0x98>
    22c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int			i;
	int			length;

	TRACE_ENTRY();
	rep = &priv->config_rep;
	memset(rep, 0, sizeof(*rep));
    22c8:	8d 93 89 00 00 00    	lea    0x89(%ebx),%edx
    22ce:	b1 17                	mov    $0x17,%cl
    22d0:	f6 c2 02             	test   $0x2,%dl
    22d3:	c6 83 88 00 00 00 00 	movb   $0x0,0x88(%ebx)
    22da:	0f 84 87 fe ff ff    	je     2167 <stm_set_config_page.constprop.47+0x37>
    22e0:	31 ff                	xor    %edi,%edi
    22e2:	83 c2 02             	add    $0x2,%edx
    22e5:	66 89 7a fe          	mov    %di,-0x2(%edx)
    22e9:	83 e9 02             	sub    $0x2,%ecx
    22ec:	e9 76 fe ff ff       	jmp    2167 <stm_set_config_page.constprop.47+0x37>
    22f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			printk(KERN_ERR MYNAM
			       ":%s timed out setting config page\n", ioc->name);
		return -1;
	}

	if (priv->in_reset) {
    22f8:	85 c0                	test   %eax,%eax
    22fa:	0f 85 cd 00 00 00    	jne    23cd <stm_set_config_page.constprop.47+0x29d>
		printk(KERN_ERR MYNAM
		       ":%s reset while setting config page\n", ioc->name);
		return -1;
	}

	ioc_status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
    2300:	0f b7 93 96 00 00 00 	movzwl 0x96(%ebx),%edx
	if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
    2307:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
    230d:	0f 84 b5 fe ff ff    	je     21c8 <stm_set_config_page.constprop.47+0x98>
		printk(KERN_ERR MYNAM
		       ":%s failed to set config page\n", ioc->name);
    2313:	8b 45 ec             	mov    -0x14(%ebp),%eax
		return -1;
	}

	ioc_status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
	if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
		printk(KERN_ERR MYNAM
    2316:	c7 04 24 a4 06 00 00 	movl   $0x6a4,(%esp)
    231d:	89 55 e8             	mov    %edx,-0x18(%ebp)
		       ":%s failed to set config page\n", ioc->name);
    2320:	83 c0 08             	add    $0x8,%eax
		return -1;
	}

	ioc_status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
	if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
		printk(KERN_ERR MYNAM
    2323:	89 44 24 04          	mov    %eax,0x4(%esp)
    2327:	89 45 ec             	mov    %eax,-0x14(%ebp)
    232a:	e8 fc ff ff ff       	call   232b <stm_set_config_page.constprop.47+0x1fb>
		       ":%s failed to set config page\n", ioc->name);
		printk(KERN_ERR MYNAM
    232f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2332:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    2336:	8b 7d ec             	mov    -0x14(%ebp),%edi
    2339:	c7 04 24 60 04 00 00 	movl   $0x460,(%esp)
    2340:	89 54 24 08          	mov    %edx,0x8(%esp)
    2344:	89 7c 24 04          	mov    %edi,0x4(%esp)
    2348:	e8 fc ff ff ff       	call   2349 <stm_set_config_page.constprop.47+0x219>
		       ":%s   IOCStatus = %04x, PageLength = %x\n",
		       ioc->name, ioc_status, length);
		printk(KERN_ERR MYNAM
    234d:	8b 45 08             	mov    0x8(%ebp),%eax
    2350:	89 74 24 08          	mov    %esi,0x8(%esp)
    2354:	89 7c 24 04          	mov    %edi,0x4(%esp)
    2358:	c7 04 24 94 04 00 00 	movl   $0x494,(%esp)
    235f:	89 44 24 10          	mov    %eax,0x10(%esp)
    2363:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2366:	89 44 24 0c          	mov    %eax,0xc(%esp)
    236a:	e8 fc ff ff ff       	call   236b <stm_set_config_page.constprop.47+0x23b>
		       ":%s   type = %d, number = %d, address = %x\n",
		       ioc->name, type, number, address);
		printk(KERN_ERR MYNAM
    236f:	8b 43 20             	mov    0x20(%ebx),%eax
    2372:	8b 80 00 18 02 00    	mov    0x21800(%eax),%eax
    2378:	89 7c 24 04          	mov    %edi,0x4(%esp)
    237c:	c7 04 24 d0 06 00 00 	movl   $0x6d0,(%esp)
    2383:	89 44 24 08          	mov    %eax,0x8(%esp)
    2387:	e8 fc ff ff ff       	call   2388 <stm_set_config_page.constprop.47+0x258>
    238c:	e9 32 fe ff ff       	jmp    21c3 <stm_set_config_page.constprop.47+0x93>
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
		       ":%s reset while getting config page header\n", ioc->name);
    2391:	8b 45 ec             	mov    -0x14(%ebp),%eax
		}
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
    2394:	c7 04 24 f8 03 00 00 	movl   $0x3f8,(%esp)
		       ":%s reset while getting config page header\n", ioc->name);
    239b:	83 c0 08             	add    $0x8,%eax
    239e:	89 44 24 04          	mov    %eax,0x4(%esp)
		}
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
    23a2:	e8 fc ff ff ff       	call   23a3 <stm_set_config_page.constprop.47+0x273>
		       ":%s reset while getting config page header\n", ioc->name);
		return -1;
    23a7:	83 c8 ff             	or     $0xffffffff,%eax
    23aa:	e9 19 fe ff ff       	jmp    21c8 <stm_set_config_page.constprop.47+0x98>
	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_HEADER,
				 type, number, address, 0, sleep);
	if (i) {
		if (!priv->in_reset) {
			printk(KERN_ERR MYNAM
			       ":%s timed out getting config page header\n", ioc->name);
    23af:	8b 45 ec             	mov    -0x14(%ebp),%eax

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_HEADER,
				 type, number, address, 0, sleep);
	if (i) {
		if (!priv->in_reset) {
			printk(KERN_ERR MYNAM
    23b2:	c7 04 24 c4 03 00 00 	movl   $0x3c4,(%esp)
			       ":%s timed out getting config page header\n", ioc->name);
    23b9:	83 c0 08             	add    $0x8,%eax
    23bc:	89 44 24 04          	mov    %eax,0x4(%esp)

	i = stm_do_config_action(priv, MPI_CONFIG_ACTION_PAGE_HEADER,
				 type, number, address, 0, sleep);
	if (i) {
		if (!priv->in_reset) {
			printk(KERN_ERR MYNAM
    23c0:	e8 fc ff ff ff       	call   23c1 <stm_set_config_page.constprop.47+0x291>
			       ":%s timed out getting config page header\n", ioc->name);
		}
		return -1;
    23c5:	83 c8 ff             	or     $0xffffffff,%eax
    23c8:	e9 fb fd ff ff       	jmp    21c8 <stm_set_config_page.constprop.47+0x98>
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
		       ":%s reset while setting config page\n", ioc->name);
    23cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
			       ":%s timed out setting config page\n", ioc->name);
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
    23d0:	c7 04 24 74 06 00 00 	movl   $0x674,(%esp)
		       ":%s reset while setting config page\n", ioc->name);
    23d7:	83 c0 08             	add    $0x8,%eax
    23da:	89 44 24 04          	mov    %eax,0x4(%esp)
			       ":%s timed out setting config page\n", ioc->name);
		return -1;
	}

	if (priv->in_reset) {
		printk(KERN_ERR MYNAM
    23de:	e8 fc ff ff ff       	call   23df <stm_set_config_page.constprop.47+0x2af>
		       ":%s reset while setting config page\n", ioc->name);
		return -1;
    23e3:	83 c8 ff             	or     $0xffffffff,%eax
    23e6:	e9 dd fd ff ff       	jmp    21c8 <stm_set_config_page.constprop.47+0x98>
    23eb:	90                   	nop
    23ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000023f0 <stm_link_service_reply>:
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_link_service_reply(MPT_ADAPTER *ioc,
				   LinkServiceBufferPostReply_t *rep)
{
    23f0:	55                   	push   %ebp
    23f1:	89 e5                	mov    %esp,%ebp
    23f3:	57                   	push   %edi
    23f4:	56                   	push   %esi
    23f5:	53                   	push   %ebx
    23f6:	83 ec 30             	sub    $0x30,%esp
    23f9:	e8 fc ff ff ff       	call   23fa <stm_link_service_reply+0xa>
	int			ox_id;
	int			rx_id;
	u32			offset;

	TRACE_ENTRY();
	index = le32_to_cpu(rep->TransactionContext);
    23fe:	8b 4a 18             	mov    0x18(%edx),%ecx

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_link_service_reply(MPT_ADAPTER *ioc,
				   LinkServiceBufferPostReply_t *rep)
{
	MPT_STM_PRIV	*priv = mpt_stm_priv[ioc->id];
    2401:	8b 00                	mov    (%eax),%eax
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_link_service_reply(MPT_ADAPTER *ioc,
				   LinkServiceBufferPostReply_t *rep)
{
    2403:	89 d3                	mov    %edx,%ebx
	TRACE_ENTRY();
	index = le32_to_cpu(rep->TransactionContext);
	fc_els_buf = &priv->hw->fc_link_serv_buf[index];

	rctl =
		(le32_to_cpu(rep->Rctl_Did) & MPI_FC_RCTL_MASK) >> MPI_FC_RCTL_SHIFT;
    2405:	0f b6 52 1f          	movzbl 0x1f(%edx),%edx
	int			ox_id;
	int			rx_id;
	u32			offset;

	TRACE_ENTRY();
	index = le32_to_cpu(rep->TransactionContext);
    2409:	89 ce                	mov    %ecx,%esi

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_link_service_reply(MPT_ADAPTER *ioc,
				   LinkServiceBufferPostReply_t *rep)
{
	MPT_STM_PRIV	*priv = mpt_stm_priv[ioc->id];
    240b:	8b 04 85 20 00 00 00 	mov    0x20(,%eax,4),%eax
	int			rx_id;
	u32			offset;

	TRACE_ENTRY();
	index = le32_to_cpu(rep->TransactionContext);
	fc_els_buf = &priv->hw->fc_link_serv_buf[index];
    2412:	8d be f0 03 00 00    	lea    0x3f0(%esi),%edi
	wwnnh = le32_to_cpu(rep->Wwn.NodeNameHigh);
	wwnnl = le32_to_cpu(rep->Wwn.NodeNameLow);
	wwpnh = le32_to_cpu(rep->Wwn.PortNameHigh);
	wwpnl = le32_to_cpu(rep->Wwn.PortNameLow);

	ox_id = le16_to_cpu(rep->Oxid);
    2418:	0f b7 73 2e          	movzwl 0x2e(%ebx),%esi
	int			rx_id;
	u32			offset;

	TRACE_ENTRY();
	index = le32_to_cpu(rep->TransactionContext);
	fc_els_buf = &priv->hw->fc_link_serv_buf[index];
    241c:	c1 e7 07             	shl    $0x7,%edi
	int			ox_id;
	int			rx_id;
	u32			offset;

	TRACE_ENTRY();
	index = le32_to_cpu(rep->TransactionContext);
    241f:	89 4d ec             	mov    %ecx,-0x14(%ebp)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_link_service_reply(MPT_ADAPTER *ioc,
				   LinkServiceBufferPostReply_t *rep)
{
	MPT_STM_PRIV	*priv = mpt_stm_priv[ioc->id];
    2422:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int			rx_id;
	u32			offset;

	TRACE_ENTRY();
	index = le32_to_cpu(rep->TransactionContext);
	fc_els_buf = &priv->hw->fc_link_serv_buf[index];
    2425:	8b 48 20             	mov    0x20(%eax),%ecx

	rctl =
		(le32_to_cpu(rep->Rctl_Did) & MPI_FC_RCTL_MASK) >> MPI_FC_RCTL_SHIFT;
	type =
		(le32_to_cpu(rep->Type_Fctl) & MPI_FC_TYPE_MASK) >> MPI_FC_TYPE_SHIFT;
    2428:	0f b6 43 27          	movzbl 0x27(%ebx),%eax
	wwnnh = le32_to_cpu(rep->Wwn.NodeNameHigh);
	wwnnl = le32_to_cpu(rep->Wwn.NodeNameLow);
	wwpnh = le32_to_cpu(rep->Wwn.PortNameHigh);
	wwpnl = le32_to_cpu(rep->Wwn.PortNameLow);

	ox_id = le16_to_cpu(rep->Oxid);
    242c:	66 89 75 dc          	mov    %si,-0x24(%ebp)
	rx_id = le16_to_cpu(rep->Rxid);
    2430:	0f b7 73 2c          	movzwl 0x2c(%ebx),%esi
	int			rx_id;
	u32			offset;

	TRACE_ENTRY();
	index = le32_to_cpu(rep->TransactionContext);
	fc_els_buf = &priv->hw->fc_link_serv_buf[index];
    2434:	01 cf                	add    %ecx,%edi
	rx_id = le16_to_cpu(rep->Rxid);

	/*
	 *  if this is a received PRLI/PRLO, respond by sending our own PRLI/PRLO
	 */
	if (rctl == ELS && type == 0x01) {
    2436:	83 f8 01             	cmp    $0x1,%eax
	wwnnl = le32_to_cpu(rep->Wwn.NodeNameLow);
	wwpnh = le32_to_cpu(rep->Wwn.PortNameHigh);
	wwpnl = le32_to_cpu(rep->Wwn.PortNameLow);

	ox_id = le16_to_cpu(rep->Oxid);
	rx_id = le16_to_cpu(rep->Rxid);
    2439:	66 89 75 d8          	mov    %si,-0x28(%ebp)

	/*
	 *  if this is a received PRLI/PRLO, respond by sending our own PRLI/PRLO
	 */
	if (rctl == ELS && type == 0x01) {
    243d:	75 39                	jne    2478 <stm_link_service_reply+0x88>
    243f:	83 fa 22             	cmp    $0x22,%edx
    2442:	75 34                	jne    2478 <stm_link_service_reply+0x88>
    2444:	8b 07                	mov    (%edi),%eax
    2446:	0f c8                	bswap  %eax
		command = (be32_to_cpu(fc_els_buf->fc_els[0]) >> 24) & 0xff;
    2448:	c1 e8 18             	shr    $0x18,%eax
		switch (command) {
    244b:	83 f8 21             	cmp    $0x21,%eax
    244e:	0f 84 54 03 00 00    	je     27a8 <stm_link_service_reply+0x3b8>
    2454:	83 f8 61             	cmp    $0x61,%eax
    2457:	74 09                	je     2462 <stm_link_service_reply+0x72>
    2459:	83 f8 20             	cmp    $0x20,%eax
    245c:	0f 84 96 03 00 00    	je     27f8 <stm_link_service_reply+0x408>
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif

	stm_link_serv_buf_post(priv, index);
    2462:	8b 55 ec             	mov    -0x14(%ebp),%edx
    2465:	8b 45 f0             	mov    -0x10(%ebp),%eax
	TRACE_EXIT();
}
    2468:	83 c4 30             	add    $0x30,%esp
    246b:	5b                   	pop    %ebx
    246c:	5e                   	pop    %esi
    246d:	5f                   	pop    %edi
    246e:	5d                   	pop    %ebp
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif

	stm_link_serv_buf_post(priv, index);
    246f:	e9 8c e6 ff ff       	jmp    b00 <stm_link_serv_buf_post>
    2474:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	/*
	 *  if this is a received ABTS, respond by aborting the I/O and then
	 *  accepting it
	 */
	if (rctl == ABTS && type == 0x00) {
    2478:	85 c0                	test   %eax,%eax
    247a:	0f 84 d8 01 00 00    	je     2658 <stm_link_service_reply+0x268>
	/*
	 *  if this is a received SRR, respond by aborting any current TargetAssist
	 *  or TargetStatusSend commands, accepting the SRR, and retransmitting the
	 *  requested data or status
	 */
	if (rctl == FC4LS && type == 0x08) {
    2480:	83 f8 08             	cmp    $0x8,%eax
    2483:	75 dd                	jne    2462 <stm_link_service_reply+0x72>
    2485:	83 fa 32             	cmp    $0x32,%edx
    2488:	75 d8                	jne    2462 <stm_link_service_reply+0x72>
		priv->els_state[index] = FC4LS;
    248a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    248d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2490:	05 a8 00 00 00       	add    $0xa8,%eax
    2495:	c7 04 82 32 00 00 00 	movl   $0x32,(%edx,%eax,4)
    249c:	8b 07                	mov    (%edi),%eax
    249e:	0f c8                	bswap  %eax
		command = (be32_to_cpu(fc_els_buf->fc_els[0]) >> 24) & 0xff;
    24a0:	c1 e8 18             	shr    $0x18,%eax
		switch (command) {
    24a3:	83 f8 14             	cmp    $0x14,%eax
    24a6:	0f 85 ac 03 00 00    	jne    2858 <stm_link_service_reply+0x468>
    24ac:	8b 77 04             	mov    0x4(%edi),%esi
			rx_id = be32_to_cpu(fc_els_buf->fc_els[1]) & 0xffff;
			/*
			 *  if the rx_id is out of range, reject this SRR with
			 *  "invalid OX_ID/RX_ID combination"
			 */
			if (rx_id >= priv->num_cmd_buffers) {
    24af:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24b2:	0f ce                	bswap  %esi
		command = (be32_to_cpu(fc_els_buf->fc_els[0]) >> 24) & 0xff;
		switch (command) {
		case SRR:
			TRACE_DBG("%s: SRR to %06x from %06x (wwn %08x%08x)",
				  ioc->name, did, sid, wwpnh, wwpnl);
			rx_id = be32_to_cpu(fc_els_buf->fc_els[1]) & 0xffff;
    24b4:	0f b7 d6             	movzwl %si,%edx
			/*
			 *  if the rx_id is out of range, reject this SRR with
			 *  "invalid OX_ID/RX_ID combination"
			 */
			if (rx_id >= priv->num_cmd_buffers) {
    24b7:	3b 50 14             	cmp    0x14(%eax),%edx
		command = (be32_to_cpu(fc_els_buf->fc_els[0]) >> 24) & 0xff;
		switch (command) {
		case SRR:
			TRACE_DBG("%s: SRR to %06x from %06x (wwn %08x%08x)",
				  ioc->name, did, sid, wwpnh, wwpnl);
			rx_id = be32_to_cpu(fc_els_buf->fc_els[1]) & 0xffff;
    24ba:	89 55 d8             	mov    %edx,-0x28(%ebp)
			/*
			 *  if the rx_id is out of range, reject this SRR with
			 *  "invalid OX_ID/RX_ID combination"
			 */
			if (rx_id >= priv->num_cmd_buffers) {
    24bd:	0f 8d bd 03 00 00    	jge    2880 <stm_link_service_reply+0x490>
    24c3:	8b 47 0c             	mov    0xc(%edi),%eax
    24c6:	0f c8                	bswap  %eax
				fc_els_buf->fc_els[0] = cpu_to_be32(0x01000000);
				fc_els_buf->fc_els[1] = cpu_to_be32(0x00090300);
				stm_send_els(priv, rep, index, 8);
				return;
			}
			i = (be32_to_cpu(fc_els_buf->fc_els[3]) >> 24) & 0xff;
    24c8:	c1 e8 18             	shr    $0x18,%eax
			/*
			 *  if the IU to retransmit is not a recognized IU, reject
			 *  this SRR with "logical error"
			 */
			if (i != 1 && i != 5 && i != 7) {
    24cb:	89 c2                	mov    %eax,%edx
    24cd:	83 e2 fb             	and    $0xfffffffb,%edx
    24d0:	83 fa 01             	cmp    $0x1,%edx
    24d3:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    24d6:	74 09                	je     24e1 <stm_link_service_reply+0xf1>
    24d8:	83 f8 07             	cmp    $0x7,%eax
    24db:	0f 85 06 04 00 00    	jne    28e7 <stm_link_service_reply+0x4f7>
				fc_els_buf->fc_els[0] = cpu_to_be32(0x01000000);
				fc_els_buf->fc_els[1] = cpu_to_be32(0x00030000);
				stm_send_els(priv, rep, index, 8);
				return;
			}
			offset = be32_to_cpu(fc_els_buf->fc_els[2]);
    24e1:	8b 57 08             	mov    0x8(%edi),%edx
    24e4:	8b 75 d8             	mov    -0x28(%ebp),%esi
    24e7:	0f ca                	bswap  %edx
    24e9:	89 55 d0             	mov    %edx,-0x30(%ebp)
    24ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
    24ef:	8d 14 b2             	lea    (%edx,%esi,4),%edx
    24f2:	89 55 dc             	mov    %edx,-0x24(%ebp)

	TRACE_ENTRY();
	fc_els_buf = &priv->hw->fc_link_serv_buf[index];
	io_state = priv->io_state + rx_id;

	if (*io_state & IO_STATE_ABORTED) {
    24f5:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
    24fb:	83 e2 40             	and    $0x40,%edx
    24fe:	0f 85 c4 03 00 00    	jne    28c8 <stm_link_service_reply+0x4d8>
		fc_els_buf->fc_els[0] = cpu_to_be32(0x02000000);
		stm_send_els(priv, rep, index, 4);
		return;
	}

	if (*io_state & IO_STATE_POSTED) {
    2504:	8b 55 dc             	mov    -0x24(%ebp),%edx
    2507:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
    250d:	83 e2 01             	and    $0x1,%edx
    2510:	0f 85 e3 03 00 00    	jne    28f9 <stm_link_service_reply+0x509>
	TRACE_DBG("%s index %d: r_ctl = %x, io_state = %x",
		  ioc->name, rx_id, r_ctl, *io_state);
	TRACE_DBG("%s reply_word = %x, alias = %d, lun = %d, tag = %x",
		  ioc->name, cmd->reply_word, cmd->alias, cmd->lun, cmd->tag);

	if (*io_state & (IO_STATE_DATA_SENT | IO_STATE_STATUS_SENT)) {
    2516:	8b 55 dc             	mov    -0x24(%ebp),%edx
    2519:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
    251f:	83 e2 06             	and    $0x6,%edx
    2522:	0f 84 08 01 00 00    	je     2630 <stm_link_service_reply+0x240>
		 *  if we get here, the firmware thinks a request is active,
		 *  so it should be aborted
		 */
		TRACE_DBG("%s index %d needs to be aborted",
			  ioc->name, rx_id);
		if (*io_state & IO_STATE_DATA_SENT) {
    2528:	8b 55 dc             	mov    -0x24(%ebp),%edx
    252b:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
    2531:	83 e2 02             	and    $0x2,%edx
    2534:	0f 84 d1 03 00 00    	je     290b <stm_link_service_reply+0x51b>
			TargetAssistRequest_t	*req;

			req = (TargetAssistRequest_t *)priv->current_mf[rx_id];
    253a:	8b 75 d8             	mov    -0x28(%ebp),%esi
    253d:	8b 55 f0             	mov    -0x10(%ebp),%edx
			msg_context = le32_to_cpu(req->MsgContext);
			rel_off = le32_to_cpu(req->RelativeOffset);
			dat_len = le32_to_cpu(req->DataLength);
			TRACE_DBG("%s SRR offset = %x, TA offset = %x, TA length = %x",
				  ioc->name, offset, rel_off, dat_len);
			if (r_ctl == 1 || r_ctl == 5) {
    2540:	83 7d d4 01          	cmpl   $0x1,-0x2c(%ebp)
		TRACE_DBG("%s index %d needs to be aborted",
			  ioc->name, rx_id);
		if (*io_state & IO_STATE_DATA_SENT) {
			TargetAssistRequest_t	*req;

			req = (TargetAssistRequest_t *)priv->current_mf[rx_id];
    2544:	8b 94 b2 a0 03 00 00 	mov    0x3a0(%edx,%esi,4),%edx
			msg_context = le32_to_cpu(req->MsgContext);
    254b:	8b 72 08             	mov    0x8(%edx),%esi
    254e:	89 75 cc             	mov    %esi,-0x34(%ebp)
			rel_off = le32_to_cpu(req->RelativeOffset);
    2551:	8b 72 18             	mov    0x18(%edx),%esi
			dat_len = le32_to_cpu(req->DataLength);
    2554:	8b 52 1c             	mov    0x1c(%edx),%edx
			TRACE_DBG("%s SRR offset = %x, TA offset = %x, TA length = %x",
				  ioc->name, offset, rel_off, dat_len);
			if (r_ctl == 1 || r_ctl == 5) {
    2557:	0f 85 e1 03 00 00    	jne    293e <stm_link_service_reply+0x54e>
				if (offset < rel_off && (offset % block_size) == 0) {
    255d:	39 75 d0             	cmp    %esi,-0x30(%ebp)
    2560:	0f 83 2d 04 00 00    	jae    2993 <stm_link_service_reply+0x5a3>
    2566:	f7 45 d0 ff 01 00 00 	testl  $0x1ff,-0x30(%ebp)
    256d:	0f 85 bd 00 00 00    	jne    2630 <stm_link_service_reply+0x240>
					TRACE_DBG("%s request can be reissued",
						  ioc->name);
					adjust = rel_off + dat_len - offset;
					*io_state |= IO_STATE_INCOMPLETE;
    2573:	8b 75 dc             	mov    -0x24(%ebp),%esi
    2576:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    257c:	83 c8 10             	or     $0x10,%eax
    257f:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
					*io_state |= IO_STATE_REDO_COMMAND;
    2585:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    258b:	80 cc 10             	or     $0x10,%ah
    258e:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
					*io_state |= IO_STATE_REISSUE_REQUEST;
    2594:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    259a:	80 cc 02             	or     $0x2,%ah
    259d:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
		fc_els_buf->fc_els[1] = cpu_to_be32(0x00090300);
		stm_send_els(priv, rep, index, 8);
		return;
	}

	cmd = priv->hw->cmd_buf + rx_id;
    25a3:	69 75 d8 f0 03 00 00 	imul   $0x3f0,-0x28(%ebp),%esi
				TRACE_DBG("%s request cannot be reissued",
					  ioc->name);
			}
		}
		if (need_abort) {
			stm_target_mode_abort_request(priv, cmd->reply_word, msg_context,
    25aa:	8b 84 31 e0 03 00 00 	mov    0x3e0(%ecx,%esi,1),%eax
    25b1:	89 45 d8             	mov    %eax,-0x28(%ebp)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_target_mode_abort_request(MPT_STM_PRIV *priv, u32 reply_word,
					 u32 msg_context, int index)
{
	MPT_ADAPTER		*ioc = priv->ioc;
    25b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    25b7:	8b 30                	mov    (%eax),%esi
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    25b9:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    25c0:	89 f2                	mov    %esi,%edx
    25c2:	e8 fc ff ff ff       	call   25c3 <stm_link_service_reply+0x1d3>

	sBUG_ON(mf == NULL);
    25c7:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    25c9:	89 c1                	mov    %eax,%ecx

	sBUG_ON(mf == NULL);
    25cb:	0f 84 19 04 00 00    	je     29ea <stm_link_service_reply+0x5fa>
	MPT_ADAPTER		*ioc = priv->ioc;
	TargetModeAbort_t	*req;

	TRACE_ENTRY();
	req = (TargetModeAbort_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
    25d1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	req->AbortType = TARGET_MODE_ABORT_TYPE_EXACT_IO_REQUEST;
	req->Function = MPI_FUNCTION_TARGET_MODE_ABORT;
	req->ReplyWord = cpu_to_le32(reply_word);
	req->MsgContextToAbort = cpu_to_le32(msg_context);

	priv->io_state[index] |= IO_STATE_REQUEST_ABORTED;
    25d7:	8b 55 dc             	mov    -0x24(%ebp),%edx

	TRACE_ENTRY();
	req = (TargetModeAbort_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));

	req->AbortType = TARGET_MODE_ABORT_TYPE_EXACT_IO_REQUEST;
    25da:	c6 00 03             	movb   $0x3,(%eax)
	req->Function = MPI_FUNCTION_TARGET_MODE_ABORT;
    25dd:	c6 40 03 0d          	movb   $0xd,0x3(%eax)
	MPT_ADAPTER		*ioc = priv->ioc;
	TargetModeAbort_t	*req;

	TRACE_ENTRY();
	req = (TargetModeAbort_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
    25e1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    25e8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	req->AbortType = TARGET_MODE_ABORT_TYPE_EXACT_IO_REQUEST;
	req->Function = MPI_FUNCTION_TARGET_MODE_ABORT;
	req->ReplyWord = cpu_to_le32(reply_word);
    25ef:	8b 45 d8             	mov    -0x28(%ebp),%eax
    25f2:	89 41 0c             	mov    %eax,0xc(%ecx)
	req->MsgContextToAbort = cpu_to_le32(msg_context);
    25f5:	8b 45 cc             	mov    -0x34(%ebp),%eax
    25f8:	89 41 10             	mov    %eax,0x10(%ecx)

	priv->io_state[index] |= IO_STATE_REQUEST_ABORTED;
    25fb:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
    2601:	80 cc 01             	or     $0x1,%ah
    2604:	89 82 a0 00 00 00    	mov    %eax,0xa0(%edx)

	if (IsScsi(priv)) {
    260a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    260d:	8b 00                	mov    (%eax),%eax
    260f:	80 b8 69 03 00 00 01 	cmpb   $0x1,0x369(%eax)
		mpt_send_handshake_request(stm_context, _IOC_ID,
    2616:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
	req->ReplyWord = cpu_to_le32(reply_word);
	req->MsgContextToAbort = cpu_to_le32(msg_context);

	priv->io_state[index] |= IO_STATE_REQUEST_ABORTED;

	if (IsScsi(priv)) {
    261d:	0f 84 9d 03 00 00    	je     29c0 <stm_link_service_reply+0x5d0>
		mpt_send_handshake_request(stm_context, _IOC_ID,
					   sizeof(*req), (u32 *)req _HS_SLEEP);
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    2623:	89 f2                	mov    %esi,%edx
    2625:	e8 fc ff ff ff       	call   2626 <stm_link_service_reply+0x236>
    262a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			stm_target_mode_abort_request(priv, cmd->reply_word, msg_context,
						      rx_id);
		}
	}

	if (*io_state & IO_STATE_REISSUE_REQUEST) {
    2630:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2633:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    2639:	f6 c4 02             	test   $0x2,%ah
    263c:	0f 85 86 02 00 00    	jne    28c8 <stm_link_service_reply+0x4d8>
	} else {
		/*
		 *  we can't continue the I/O, so reject this SRR with "unable to
		 *  supply requested data"
		 */
		fc_els_buf->fc_els[0] = cpu_to_be32(0x01000000);
    2642:	c7 07 01 00 00 00    	movl   $0x1,(%edi)
		fc_els_buf->fc_els[1] = cpu_to_be32(0x00092a00);
    2648:	c7 47 04 00 09 2a 00 	movl   $0x2a0900,0x4(%edi)
    264f:	e9 11 02 00 00       	jmp    2865 <stm_link_service_reply+0x475>
    2654:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	/*
	 *  if this is a received ABTS, respond by aborting the I/O and then
	 *  accepting it
	 */
	if (rctl == ABTS && type == 0x00) {
    2658:	81 fa 81 00 00 00    	cmp    $0x81,%edx
    265e:	0f 85 1c fe ff ff    	jne    2480 <stm_link_service_reply+0x90>
		TRACE_DBG("%s: ABTS to %06x from %06x (wwn %08x%08x)",
			  ioc->name, did, sid, wwpnh, wwpnl);
		fc_els_buf->fc_els[0] = cpu_to_be32(0x00000000);
		fc_els_buf->fc_els[1] = cpu_to_be32((ox_id << 16) | (rx_id << 0));
    2664:	8b 75 dc             	mov    -0x24(%ebp),%esi
	wwnnl = le32_to_cpu(rep->Wwn.NodeNameLow);
	wwpnh = le32_to_cpu(rep->Wwn.PortNameHigh);
	wwpnl = le32_to_cpu(rep->Wwn.PortNameLow);

	ox_id = le16_to_cpu(rep->Oxid);
	rx_id = le16_to_cpu(rep->Rxid);
    2667:	0f b7 4d d8          	movzwl -0x28(%ebp),%ecx
			  ioc->name, did, sid, wwpnh, wwpnl);
		fc_els_buf->fc_els[0] = cpu_to_be32(0x00000000);
		fc_els_buf->fc_els[1] = cpu_to_be32((ox_id << 16) | (rx_id << 0));
		fc_els_buf->fc_els[2] = cpu_to_be32(0x0000ffff);
		rep->Rctl_Did += cpu_to_le32((BA_ACC - ABTS) << MPI_FC_RCTL_SHIFT);
		priv->els_state[index] = ABTS;
    266b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    266e:	8b 45 ec             	mov    -0x14(%ebp),%eax
	 */
	if (rctl == ABTS && type == 0x00) {
		TRACE_DBG("%s: ABTS to %06x from %06x (wwn %08x%08x)",
			  ioc->name, did, sid, wwpnh, wwpnl);
		fc_els_buf->fc_els[0] = cpu_to_be32(0x00000000);
		fc_els_buf->fc_els[1] = cpu_to_be32((ox_id << 16) | (rx_id << 0));
    2671:	c1 e6 10             	shl    $0x10,%esi
    2674:	09 ce                	or     %ecx,%esi
	 *  accepting it
	 */
	if (rctl == ABTS && type == 0x00) {
		TRACE_DBG("%s: ABTS to %06x from %06x (wwn %08x%08x)",
			  ioc->name, did, sid, wwpnh, wwpnl);
		fc_els_buf->fc_els[0] = cpu_to_be32(0x00000000);
    2676:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    267c:	0f ce                	bswap  %esi
		fc_els_buf->fc_els[1] = cpu_to_be32((ox_id << 16) | (rx_id << 0));
		fc_els_buf->fc_els[2] = cpu_to_be32(0x0000ffff);
    267e:	c7 47 08 00 00 ff ff 	movl   $0xffff0000,0x8(%edi)
		rep->Rctl_Did += cpu_to_le32((BA_ACC - ABTS) << MPI_FC_RCTL_SHIFT);
		priv->els_state[index] = ABTS;
    2685:	05 a8 00 00 00       	add    $0xa8,%eax
	 */
	if (rctl == ABTS && type == 0x00) {
		TRACE_DBG("%s: ABTS to %06x from %06x (wwn %08x%08x)",
			  ioc->name, did, sid, wwpnh, wwpnl);
		fc_els_buf->fc_els[0] = cpu_to_be32(0x00000000);
		fc_els_buf->fc_els[1] = cpu_to_be32((ox_id << 16) | (rx_id << 0));
    268a:	89 77 04             	mov    %esi,0x4(%edi)
    268d:	8d 34 8a             	lea    (%edx,%ecx,4),%esi
		fc_els_buf->fc_els[2] = cpu_to_be32(0x0000ffff);
		rep->Rctl_Did += cpu_to_le32((BA_ACC - ABTS) << MPI_FC_RCTL_SHIFT);
    2690:	81 43 1c 00 00 00 03 	addl   $0x3000000,0x1c(%ebx)
		priv->els_state[index] = ABTS;
    2697:	c7 04 82 81 00 00 00 	movl   $0x81,(%edx,%eax,4)
	CMD			*cmd;

	TRACE_ENTRY();
	io_state = priv->io_state + rx_id;

	if (*io_state & IO_STATE_ABORTED)
    269e:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    26a4:	a8 40                	test   $0x40,%al
    26a6:	0f 85 de 00 00 00    	jne    278a <stm_link_service_reply+0x39a>
		return;

	if (*io_state & IO_STATE_POSTED)
    26ac:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    26b2:	a8 01                	test   $0x1,%al
    26b4:	0f 85 d0 00 00 00    	jne    278a <stm_link_service_reply+0x39a>

	/*
	 *  if we are processing an SRR, there could be some other flags set
	 *  in io_state that we need to get rid of; ABTS overrides SRR
	 */
	*io_state &= ~IO_STATE_REQUEST_ABORTED;
    26ba:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
		return;

	if (*io_state & IO_STATE_POSTED)
		return;

	cmd = priv->hw->cmd_buf + rx_id;
    26c0:	69 c9 f0 03 00 00    	imul   $0x3f0,%ecx,%ecx
    26c6:	03 4a 20             	add    0x20(%edx),%ecx

	/*
	 *  if we are processing an SRR, there could be some other flags set
	 *  in io_state that we need to get rid of; ABTS overrides SRR
	 */
	*io_state &= ~IO_STATE_REQUEST_ABORTED;
    26c9:	80 e4 fe             	and    $0xfe,%ah
    26cc:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	*io_state &= ~IO_STATE_REISSUE_REQUEST;
    26d2:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    26d8:	80 e4 fd             	and    $0xfd,%ah
    26db:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	*io_state &= ~IO_STATE_ADJUST_OFFSET;
    26e1:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    26e7:	80 e4 fb             	and    $0xfb,%ah
    26ea:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	*io_state &= ~IO_STATE_CONVERT_TA_TO_TSS;
    26f0:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    26f6:	80 e4 f7             	and    $0xf7,%ah
    26f9:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	*io_state &= ~IO_STATE_REDO_COMMAND;
    26ff:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    2705:	80 e4 ef             	and    $0xef,%ah
    2708:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	/*
	 *  if we get here, the firmware thinks a command is active,
	 *  so it should be aborted
	 */
	TRACE_DBG("%s index %d needs to be aborted", ioc->name, rx_id);
	stm_target_mode_abort_command(priv, cmd->reply_word, rx_id);
    270e:	8b 81 e0 03 00 00    	mov    0x3e0(%ecx),%eax

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_target_mode_abort_command(MPT_STM_PRIV *priv, u32 reply_word,
					 int index)
{
	MPT_ADAPTER		*ioc = priv->ioc;
    2714:	8b 3a                	mov    (%edx),%edi
	/*
	 *  if we get here, the firmware thinks a command is active,
	 *  so it should be aborted
	 */
	TRACE_DBG("%s index %d needs to be aborted", ioc->name, rx_id);
	stm_target_mode_abort_command(priv, cmd->reply_word, rx_id);
    2716:	89 45 dc             	mov    %eax,-0x24(%ebp)
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    2719:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    2720:	89 fa                	mov    %edi,%edx
    2722:	e8 fc ff ff ff       	call   2723 <stm_link_service_reply+0x333>

	sBUG_ON(mf == NULL);
    2727:	85 c0                	test   %eax,%eax
    2729:	0f 84 bb 02 00 00    	je     29ea <stm_link_service_reply+0x5fa>
	req = (TargetModeAbort_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));

	req->AbortType = TARGET_MODE_ABORT_TYPE_EXACT_IO;
	req->Function = MPI_FUNCTION_TARGET_MODE_ABORT;
	req->ReplyWord = cpu_to_le32(reply_word);
    272f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
	MPT_ADAPTER		*ioc = priv->ioc;
	TargetModeAbort_t	*req;

	TRACE_ENTRY();
	req = (TargetModeAbort_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
    2732:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    2738:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    273f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	req->AbortType = TARGET_MODE_ABORT_TYPE_EXACT_IO;
	req->Function = MPI_FUNCTION_TARGET_MODE_ABORT;
	req->ReplyWord = cpu_to_le32(reply_word);
    2746:	89 48 0c             	mov    %ecx,0xc(%eax)

	priv->io_state[index] |= IO_STATE_ABORTED;

	if (IsScsi(priv)) {
    2749:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	MPT_ADAPTER		*ioc = priv->ioc;
	TargetModeAbort_t	*req;

	TRACE_ENTRY();
	req = (TargetModeAbort_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
    274c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

	req->AbortType = TARGET_MODE_ABORT_TYPE_EXACT_IO;
    2753:	c6 00 02             	movb   $0x2,(%eax)
	req->Function = MPI_FUNCTION_TARGET_MODE_ABORT;
    2756:	c6 40 03 0d          	movb   $0xd,0x3(%eax)
	req->ReplyWord = cpu_to_le32(reply_word);

	priv->io_state[index] |= IO_STATE_ABORTED;
    275a:	8b 96 a0 00 00 00    	mov    0xa0(%esi),%edx
    2760:	83 ca 40             	or     $0x40,%edx
    2763:	89 96 a0 00 00 00    	mov    %edx,0xa0(%esi)

	if (IsScsi(priv)) {
    2769:	8b 11                	mov    (%ecx),%edx
		mpt_send_handshake_request(stm_context, _IOC_ID,
    276b:	0f b6 35 14 00 00 00 	movzbl 0x14,%esi
	req->Function = MPI_FUNCTION_TARGET_MODE_ABORT;
	req->ReplyWord = cpu_to_le32(reply_word);

	priv->io_state[index] |= IO_STATE_ABORTED;

	if (IsScsi(priv)) {
    2772:	80 ba 69 03 00 00 01 	cmpb   $0x1,0x369(%edx)
    2779:	0f 84 29 01 00 00    	je     28a8 <stm_link_service_reply+0x4b8>
		mpt_send_handshake_request(stm_context, _IOC_ID,
					   sizeof(*req), (u32 *)req _HS_SLEEP);
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    277f:	89 c1                	mov    %eax,%ecx
    2781:	89 fa                	mov    %edi,%edx
    2783:	89 f0                	mov    %esi,%eax
    2785:	e8 fc ff ff ff       	call   2786 <stm_link_service_reply+0x396>
		fc_els_buf->fc_els[1] = cpu_to_be32((ox_id << 16) | (rx_id << 0));
		fc_els_buf->fc_els[2] = cpu_to_be32(0x0000ffff);
		rep->Rctl_Did += cpu_to_le32((BA_ACC - ABTS) << MPI_FC_RCTL_SHIFT);
		priv->els_state[index] = ABTS;
		stmapp_abts_process(priv, rx_id, rep, index);
		stm_send_els(priv, rep, index, 12);
    278a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    278d:	89 da                	mov    %ebx,%edx
    278f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2792:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
    2799:	e8 52 e4 ff ff       	call   bf0 <stm_send_els>
	}
#endif

	stm_link_serv_buf_post(priv, index);
	TRACE_EXIT();
}
    279e:	83 c4 30             	add    $0x30,%esp
    27a1:	5b                   	pop    %ebx
    27a2:	5e                   	pop    %esi
    27a3:	5f                   	pop    %edi
    27a4:	5d                   	pop    %ebp
    27a5:	c3                   	ret    
    27a6:	66 90                	xchg   %ax,%ax
			fc_els_buf->fc_els[0] = cpu_to_be32(0x02100014);
			fc_els_buf->fc_els[1] = cpu_to_be32(0x08000100);
			fc_els_buf->fc_els[2] = cpu_to_be32(0x00000000);
			fc_els_buf->fc_els[3] = cpu_to_be32(0x00000000);
			fc_els_buf->fc_els[4] = cpu_to_be32(0x00000000);
			priv->els_state[index] = PRLO;
    27a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
			stm_send_els(priv, rep, index, 20);
    27ab:	89 da                	mov    %ebx,%edx
			return;

		case PRLO:
			TRACE_DBG("%s: PRLO to %06x from %06x (wwn %08x%08x)",
				  ioc->name, did, sid, wwpnh, wwpnl);
			fc_els_buf->fc_els[0] = cpu_to_be32(0x02100014);
    27ad:	c7 07 02 10 00 14    	movl   $0x14001002,(%edi)
			fc_els_buf->fc_els[1] = cpu_to_be32(0x08000100);
    27b3:	c7 47 04 08 00 01 00 	movl   $0x10008,0x4(%edi)
			fc_els_buf->fc_els[2] = cpu_to_be32(0x00000000);
    27ba:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
			fc_els_buf->fc_els[3] = cpu_to_be32(0x00000000);
    27c1:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
			fc_els_buf->fc_els[4] = cpu_to_be32(0x00000000);
			priv->els_state[index] = PRLO;
    27c8:	89 c8                	mov    %ecx,%eax
				  ioc->name, did, sid, wwpnh, wwpnl);
			fc_els_buf->fc_els[0] = cpu_to_be32(0x02100014);
			fc_els_buf->fc_els[1] = cpu_to_be32(0x08000100);
			fc_els_buf->fc_els[2] = cpu_to_be32(0x00000000);
			fc_els_buf->fc_els[3] = cpu_to_be32(0x00000000);
			fc_els_buf->fc_els[4] = cpu_to_be32(0x00000000);
    27ca:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
			priv->els_state[index] = PRLO;
    27d1:	8b 7d f0             	mov    -0x10(%ebp),%edi
    27d4:	05 a8 00 00 00       	add    $0xa8,%eax
    27d9:	c7 04 87 21 00 00 00 	movl   $0x21,(%edi,%eax,4)
			stm_send_els(priv, rep, index, 20);
    27e0:	89 f8                	mov    %edi,%eax
    27e2:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
    27e9:	e8 02 e4 ff ff       	call   bf0 <stm_send_els>
	}
#endif

	stm_link_serv_buf_post(priv, index);
	TRACE_EXIT();
}
    27ee:	83 c4 30             	add    $0x30,%esp
    27f1:	5b                   	pop    %ebx
    27f2:	5e                   	pop    %esi
    27f3:	5f                   	pop    %edi
    27f4:	5d                   	pop    %ebp
    27f5:	c3                   	ret    
    27f6:	66 90                	xchg   %ax,%ax
			fc_els_buf->fc_els[0] = cpu_to_be32(0x02100014);
			fc_els_buf->fc_els[1] = cpu_to_be32(0x08002100);
			fc_els_buf->fc_els[2] = cpu_to_be32(0x00000000);
			fc_els_buf->fc_els[3] = cpu_to_be32(0x00000000);
			fc_els_buf->fc_els[4] = cpu_to_be32(0x00000012);
			if (priv->fcp2_capable)
    27f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
		switch (command) {
		case PRLI:
			TRACE_DBG("%s: PRLI to %06x from %06x (wwn %08x%08x)",
				  ioc->name, did, sid, wwpnh, wwpnl);
			i = be32_to_cpu(fc_els_buf->fc_els[4]);
			fc_els_buf->fc_els[0] = cpu_to_be32(0x02100014);
    27fb:	c7 07 02 10 00 14    	movl   $0x14001002,(%edi)
			fc_els_buf->fc_els[1] = cpu_to_be32(0x08002100);
    2801:	c7 47 04 08 00 21 00 	movl   $0x210008,0x4(%edi)
			fc_els_buf->fc_els[2] = cpu_to_be32(0x00000000);
    2808:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
			fc_els_buf->fc_els[3] = cpu_to_be32(0x00000000);
    280f:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
			fc_els_buf->fc_els[4] = cpu_to_be32(0x00000012);
    2816:	c7 47 10 00 00 00 12 	movl   $0x12000000,0x10(%edi)
			if (priv->fcp2_capable)
    281d:	8b 40 08             	mov    0x8(%eax),%eax
    2820:	85 c0                	test   %eax,%eax
    2822:	74 07                	je     282b <stm_link_service_reply+0x43b>
				fc_els_buf->fc_els[4] |= cpu_to_be32(0x100);
    2824:	c7 47 10 00 00 01 12 	movl   $0x12010000,0x10(%edi)
			priv->els_state[index] = PRLI;
    282b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
			stm_send_els(priv, rep, index, 20);
    282e:	89 da                	mov    %ebx,%edx
			fc_els_buf->fc_els[2] = cpu_to_be32(0x00000000);
			fc_els_buf->fc_els[3] = cpu_to_be32(0x00000000);
			fc_els_buf->fc_els[4] = cpu_to_be32(0x00000012);
			if (priv->fcp2_capable)
				fc_els_buf->fc_els[4] |= cpu_to_be32(0x100);
			priv->els_state[index] = PRLI;
    2830:	8b 7d f0             	mov    -0x10(%ebp),%edi
    2833:	89 c8                	mov    %ecx,%eax
    2835:	05 a8 00 00 00       	add    $0xa8,%eax
    283a:	c7 04 87 20 00 00 00 	movl   $0x20,(%edi,%eax,4)
			stm_send_els(priv, rep, index, 20);
    2841:	89 f8                	mov    %edi,%eax
    2843:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
    284a:	e8 a1 e3 ff ff       	call   bf0 <stm_send_els>
	}
#endif

	stm_link_serv_buf_post(priv, index);
	TRACE_EXIT();
}
    284f:	83 c4 30             	add    $0x30,%esp
    2852:	5b                   	pop    %ebx
    2853:	5e                   	pop    %esi
    2854:	5f                   	pop    %edi
    2855:	5d                   	pop    %ebp
    2856:	c3                   	ret    
    2857:	90                   	nop
				  ioc->name, command, did, sid, wwpnh, wwpnl);
			/*
			 *  the only FC4LS we recognize is SRR; all others get
			 *  rejected with "command not supported"
			 */
			fc_els_buf->fc_els[0] = cpu_to_be32(0x01000000);
    2858:	c7 07 01 00 00 00    	movl   $0x1,(%edi)
			fc_els_buf->fc_els[1] = cpu_to_be32(0x000b0000);
    285e:	c7 47 04 00 0b 00 00 	movl   $0xb00,0x4(%edi)
			stm_send_els(priv, rep, index, 8);
    2865:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2868:	89 da                	mov    %ebx,%edx
    286a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    286d:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    2874:	e8 77 e3 ff ff       	call   bf0 <stm_send_els>
			return;
    2879:	e9 20 ff ff ff       	jmp    279e <stm_link_service_reply+0x3ae>
    287e:	66 90                	xchg   %ax,%ax
			 *  "invalid OX_ID/RX_ID combination"
			 */
			if (rx_id >= priv->num_cmd_buffers) {
				fc_els_buf->fc_els[0] = cpu_to_be32(0x01000000);
				fc_els_buf->fc_els[1] = cpu_to_be32(0x00090300);
				stm_send_els(priv, rep, index, 8);
    2880:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2883:	89 da                	mov    %ebx,%edx
			/*
			 *  if the rx_id is out of range, reject this SRR with
			 *  "invalid OX_ID/RX_ID combination"
			 */
			if (rx_id >= priv->num_cmd_buffers) {
				fc_els_buf->fc_els[0] = cpu_to_be32(0x01000000);
    2885:	c7 07 01 00 00 00    	movl   $0x1,(%edi)
				fc_els_buf->fc_els[1] = cpu_to_be32(0x00090300);
    288b:	c7 47 04 00 09 03 00 	movl   $0x30900,0x4(%edi)
				stm_send_els(priv, rep, index, 8);
    2892:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    2899:	e8 52 e3 ff ff       	call   bf0 <stm_send_els>
				return;
    289e:	e9 fb fe ff ff       	jmp    279e <stm_link_service_reply+0x3ae>
    28a3:	90                   	nop
    28a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	req->ReplyWord = cpu_to_le32(reply_word);

	priv->io_state[index] |= IO_STATE_ABORTED;

	if (IsScsi(priv)) {
		mpt_send_handshake_request(stm_context, _IOC_ID,
    28a8:	89 04 24             	mov    %eax,(%esp)
    28ab:	b9 14 00 00 00       	mov    $0x14,%ecx
    28b0:	89 fa                	mov    %edi,%edx
    28b2:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    28b9:	00 
    28ba:	89 f0                	mov    %esi,%eax
    28bc:	e8 fc ff ff ff       	call   28bd <stm_link_service_reply+0x4cd>
    28c1:	e9 c4 fe ff ff       	jmp    278a <stm_link_service_reply+0x39a>
    28c6:	66 90                	xchg   %ax,%ax
	if (*io_state & IO_STATE_REISSUE_REQUEST) {
		/*
		 *  if we can continue this I/O, accept this SRR
		 */
		fc_els_buf->fc_els[0] = cpu_to_be32(0x02000000);
		stm_send_els(priv, rep, index, 4);
    28c8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    28cb:	89 da                	mov    %ebx,%edx
    28cd:	8b 45 f0             	mov    -0x10(%ebp),%eax

	if (*io_state & IO_STATE_REISSUE_REQUEST) {
		/*
		 *  if we can continue this I/O, accept this SRR
		 */
		fc_els_buf->fc_els[0] = cpu_to_be32(0x02000000);
    28d0:	c7 07 02 00 00 00    	movl   $0x2,(%edi)
		stm_send_els(priv, rep, index, 4);
    28d6:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    28dd:	e8 0e e3 ff ff       	call   bf0 <stm_send_els>
    28e2:	e9 b7 fe ff ff       	jmp    279e <stm_link_service_reply+0x3ae>
			/*
			 *  if the IU to retransmit is not a recognized IU, reject
			 *  this SRR with "logical error"
			 */
			if (i != 1 && i != 5 && i != 7) {
				fc_els_buf->fc_els[0] = cpu_to_be32(0x01000000);
    28e7:	c7 07 01 00 00 00    	movl   $0x1,(%edi)
				fc_els_buf->fc_els[1] = cpu_to_be32(0x00030000);
    28ed:	c7 47 04 00 03 00 00 	movl   $0x300,0x4(%edi)
    28f4:	e9 6c ff ff ff       	jmp    2865 <stm_link_service_reply+0x475>
	if (*io_state & IO_STATE_POSTED) {
		/*
		 *  the firmware should prevent this from happening, but if it does,
		 *  reject this SRR with "invalid OX_ID/RX_ID combination"
		 */
		fc_els_buf->fc_els[0] = cpu_to_be32(0x01000000);
    28f9:	c7 07 01 00 00 00    	movl   $0x1,(%edi)
		fc_els_buf->fc_els[1] = cpu_to_be32(0x00090300);
    28ff:	c7 47 04 00 09 03 00 	movl   $0x30900,0x4(%edi)
    2906:	e9 5a ff ff ff       	jmp    2865 <stm_link_service_reply+0x475>
			}
		} else {
			TargetStatusSendRequest_t	*req;

			req = (TargetStatusSendRequest_t *)priv->current_mf[rx_id];
			msg_context = le32_to_cpu(req->MsgContext);
    290b:	8b 75 f0             	mov    -0x10(%ebp),%esi
			if (r_ctl == 7) {
    290e:	83 f8 07             	cmp    $0x7,%eax
			}
		} else {
			TargetStatusSendRequest_t	*req;

			req = (TargetStatusSendRequest_t *)priv->current_mf[rx_id];
			msg_context = le32_to_cpu(req->MsgContext);
    2911:	8b 55 d8             	mov    -0x28(%ebp),%edx
    2914:	8b 94 96 a0 03 00 00 	mov    0x3a0(%esi,%edx,4),%edx
    291b:	8b 72 08             	mov    0x8(%edx),%esi
    291e:	89 75 cc             	mov    %esi,-0x34(%ebp)
			if (r_ctl == 7) {
    2921:	0f 85 09 fd ff ff    	jne    2630 <stm_link_service_reply+0x240>
				TRACE_DBG("%s request can be reissued",
					  ioc->name);
				*io_state |= IO_STATE_REISSUE_REQUEST;
    2927:	8b 75 dc             	mov    -0x24(%ebp),%esi
    292a:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    2930:	80 cc 02             	or     $0x2,%ah
    2933:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
    2939:	e9 65 fc ff ff       	jmp    25a3 <stm_link_service_reply+0x1b3>
						}
					}
					*io_state |= IO_STATE_REISSUE_REQUEST;
					need_abort = 1;
				}
			} else if (r_ctl == 7) {
    293e:	83 f8 07             	cmp    $0x7,%eax
    2941:	0f 85 e9 fc ff ff    	jne    2630 <stm_link_service_reply+0x240>
				if (*io_state & IO_STATE_STATUS_SENT) {
    2947:	8b 45 dc             	mov    -0x24(%ebp),%eax
#endif
	FC_ELS		*fc_els_buf;
	volatile int	*io_state;
	u32		msg_context;
	CMD		*cmd;
	int		need_abort = 0;
    294a:	31 d2                	xor    %edx,%edx
					}
					*io_state |= IO_STATE_REISSUE_REQUEST;
					need_abort = 1;
				}
			} else if (r_ctl == 7) {
				if (*io_state & IO_STATE_STATUS_SENT) {
    294c:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    2952:	a8 04                	test   $0x4,%al
    2954:	74 23                	je     2979 <stm_link_service_reply+0x589>
					TRACE_DBG("%s request can be reissued",
						  ioc->name);
					*io_state |= IO_STATE_CONVERT_TA_TO_TSS;
    2956:	8b 75 dc             	mov    -0x24(%ebp),%esi
					*io_state |= IO_STATE_REISSUE_REQUEST;
					need_abort = 1;
    2959:	b2 01                	mov    $0x1,%dl
				}
			} else if (r_ctl == 7) {
				if (*io_state & IO_STATE_STATUS_SENT) {
					TRACE_DBG("%s request can be reissued",
						  ioc->name);
					*io_state |= IO_STATE_CONVERT_TA_TO_TSS;
    295b:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    2961:	80 cc 08             	or     $0x8,%ah
    2964:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
					*io_state |= IO_STATE_REISSUE_REQUEST;
    296a:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    2970:	80 cc 02             	or     $0x2,%ah
    2973:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
					need_abort = 1;
				}
				if (*io_state & IO_STATE_STATUS_DEFERRED) {
    2979:	8b 45 dc             	mov    -0x24(%ebp),%eax
    297c:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    2982:	a8 08                	test   $0x8,%al
    2984:	75 a1                	jne    2927 <stm_link_service_reply+0x537>
			} else {
				TRACE_DBG("%s request cannot be reissued",
					  ioc->name);
			}
		}
		if (need_abort) {
    2986:	85 d2                	test   %edx,%edx
    2988:	0f 84 a2 fc ff ff    	je     2630 <stm_link_service_reply+0x240>
    298e:	e9 10 fc ff ff       	jmp    25a3 <stm_link_service_reply+0x1b3>
					*io_state |= IO_STATE_INCOMPLETE;
					*io_state |= IO_STATE_REDO_COMMAND;
					*io_state |= IO_STATE_REISSUE_REQUEST;
					need_abort = 1;
				}
				if (offset >= rel_off && offset <= rel_off + dat_len) {
    2993:	01 f2                	add    %esi,%edx
    2995:	39 55 d0             	cmp    %edx,-0x30(%ebp)
    2998:	0f 87 92 fc ff ff    	ja     2630 <stm_link_service_reply+0x240>
					TRACE_DBG("%s request can be reissued",
						  ioc->name);
					if (offset != rel_off) {
    299e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    29a1:	39 f0                	cmp    %esi,%eax
    29a3:	74 82                	je     2927 <stm_link_service_reply+0x537>
						if (offset != rel_off + dat_len) {
							/*cmd->offset = offset;*/
							*io_state |= IO_STATE_ADJUST_OFFSET;
    29a5:	8b 75 dc             	mov    -0x24(%ebp),%esi
				}
				if (offset >= rel_off && offset <= rel_off + dat_len) {
					TRACE_DBG("%s request can be reissued",
						  ioc->name);
					if (offset != rel_off) {
						if (offset != rel_off + dat_len) {
    29a8:	39 d0                	cmp    %edx,%eax
							/*cmd->offset = offset;*/
							*io_state |= IO_STATE_ADJUST_OFFSET;
    29aa:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
				}
				if (offset >= rel_off && offset <= rel_off + dat_len) {
					TRACE_DBG("%s request can be reissued",
						  ioc->name);
					if (offset != rel_off) {
						if (offset != rel_off + dat_len) {
    29b0:	74 2a                	je     29dc <stm_link_service_reply+0x5ec>
							/*cmd->offset = offset;*/
							*io_state |= IO_STATE_ADJUST_OFFSET;
    29b2:	80 cc 04             	or     $0x4,%ah
    29b5:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
    29bb:	e9 67 ff ff ff       	jmp    2927 <stm_link_service_reply+0x537>
	req->MsgContextToAbort = cpu_to_le32(msg_context);

	priv->io_state[index] |= IO_STATE_REQUEST_ABORTED;

	if (IsScsi(priv)) {
		mpt_send_handshake_request(stm_context, _IOC_ID,
    29c0:	89 0c 24             	mov    %ecx,(%esp)
    29c3:	89 f2                	mov    %esi,%edx
    29c5:	b9 14 00 00 00       	mov    $0x14,%ecx
    29ca:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    29d1:	00 
    29d2:	e8 fc ff ff ff       	call   29d3 <stm_link_service_reply+0x5e3>
    29d7:	e9 54 fc ff ff       	jmp    2630 <stm_link_service_reply+0x240>
					if (offset != rel_off) {
						if (offset != rel_off + dat_len) {
							/*cmd->offset = offset;*/
							*io_state |= IO_STATE_ADJUST_OFFSET;
						} else {
							*io_state |= IO_STATE_CONVERT_TA_TO_TSS;
    29dc:	80 cc 08             	or     $0x8,%ah
    29df:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
    29e5:	e9 3d ff ff ff       	jmp    2927 <stm_link_service_reply+0x537>
    29ea:	e8 11 00 00 00       	call   2a00 <mpt_send_target_data+0x10>
    29ef:	90                   	nop

000029f0 <mpt_send_target_data>:
/*
 * calling mpt_send_target_data
 *
 */
static void mpt_send_target_data(struct mpt_prm *prm, int flags)
{
    29f0:	55                   	push   %ebp
    29f1:	89 e5                	mov    %esp,%ebp
    29f3:	57                   	push   %edi
    29f4:	56                   	push   %esi
    29f5:	53                   	push   %ebx
    29f6:	83 ec 34             	sub    $0x34,%esp
    29f9:	e8 fc ff ff ff       	call   29fa <mpt_send_target_data+0xa>
    29fe:	89 c3                	mov    %eax,%ebx
	u32 reply_word;
	int index, lun, tag, length, offset;
	MPT_SGL *sgl;

	TRACE_ENTRY();
	priv = prm->tgt->priv;
    2a00:	8b 00                	mov    (%eax),%eax
	unsigned int bufflen = prm->bufflen;
	int i;

	TRACE_ENTRY();
	TRACE_DBG("bufflen %d, %p", bufflen, prm->buffer);
	sBUG_ON(prm->use_sg == 0);
    2a02:	66 83 7b 06 00       	cmpw   $0x0,0x6(%ebx)
/*
 * calling mpt_send_target_data
 *
 */
static void mpt_send_target_data(struct mpt_prm *prm, int flags)
{
    2a07:	89 55 d8             	mov    %edx,-0x28(%ebp)
 *
 */
static inline void mpt_sge_to_sgl(struct mpt_prm *prm, MPT_STM_PRIV *priv,
				  MPT_SGL *sgl)
{
	unsigned int bufflen = prm->bufflen;
    2a0a:	8b 73 0c             	mov    0xc(%ebx),%esi
	u32 reply_word;
	int index, lun, tag, length, offset;
	MPT_SGL *sgl;

	TRACE_ENTRY();
	priv = prm->tgt->priv;
    2a0d:	8b 40 04             	mov    0x4(%eax),%eax
    2a10:	89 45 ec             	mov    %eax,-0x14(%ebp)
	unsigned int bufflen = prm->bufflen;
	int i;

	TRACE_ENTRY();
	TRACE_DBG("bufflen %d, %p", bufflen, prm->buffer);
	sBUG_ON(prm->use_sg == 0);
    2a13:	0f 84 6c 05 00 00    	je     2f85 <mpt_send_target_data+0x595>

	prm->sg = (struct scatterlist *)prm->buffer;
    2a19:	8b 43 10             	mov    0x10(%ebx),%eax

static inline int
pci_map_sg(struct pci_dev *hwdev, struct scatterlist *sg,
	   int nents, int direction)
{
	return dma_map_sg(hwdev == NULL ? NULL : &hwdev->dev, sg, nents, (enum dma_data_direction)direction);
    2a1c:	31 ff                	xor    %edi,%edi
    2a1e:	89 43 08             	mov    %eax,0x8(%ebx)
	prm->seg_cnt = pci_map_sg(priv->ioc->pcidev, prm->sg, prm->use_sg,
				   scst_to_tgt_dma_dir(prm->data_direction));
    2a21:	8b 43 14             	mov    0x14(%ebx),%eax
    2a24:	e8 fc ff ff ff       	call   2a25 <mpt_send_target_data+0x35>
	TRACE_ENTRY();
	TRACE_DBG("bufflen %d, %p", bufflen, prm->buffer);
	sBUG_ON(prm->use_sg == 0);

	prm->sg = (struct scatterlist *)prm->buffer;
	prm->seg_cnt = pci_map_sg(priv->ioc->pcidev, prm->sg, prm->use_sg,
    2a29:	8b 55 ec             	mov    -0x14(%ebp),%edx
    2a2c:	8b 4b 08             	mov    0x8(%ebx),%ecx
    2a2f:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
				   scst_to_tgt_dma_dir(prm->data_direction));
    2a32:	89 45 e8             	mov    %eax,-0x18(%ebp)
	TRACE_ENTRY();
	TRACE_DBG("bufflen %d, %p", bufflen, prm->buffer);
	sBUG_ON(prm->use_sg == 0);

	prm->sg = (struct scatterlist *)prm->buffer;
	prm->seg_cnt = pci_map_sg(priv->ioc->pcidev, prm->sg, prm->use_sg,
    2a35:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
    2a39:	89 45 f0             	mov    %eax,-0x10(%ebp)
    2a3c:	8b 02                	mov    (%edx),%eax
    2a3e:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    2a44:	85 c0                	test   %eax,%eax
    2a46:	8d 50 64             	lea    0x64(%eax),%edx
{
	struct dma_map_ops *ops = get_dma_ops(dev);
	int i, ents;
	struct scatterlist *s;

	for_each_sg(sg, s, nents, i)
    2a49:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2a4c:	0f 44 d7             	cmove  %edi,%edx
    2a4f:	89 55 e0             	mov    %edx,-0x20(%ebp)
extern struct dma_map_ops *dma_ops;

static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
#ifndef CONFIG_X86_DEV_DMA_OPS
	return dma_ops;
    2a52:	8b 15 00 00 00 00    	mov    0x0,%edx
    2a58:	85 c0                	test   %eax,%eax
    2a5a:	89 55 dc             	mov    %edx,-0x24(%ebp)
    2a5d:	74 31                	je     2a90 <mpt_send_target_data+0xa0>
    2a5f:	89 75 d4             	mov    %esi,-0x2c(%ebp)
    2a62:	8b 75 f0             	mov    -0x10(%ebp),%esi
    2a65:	89 5d d0             	mov    %ebx,-0x30(%ebp)
    2a68:	89 cb                	mov    %ecx,%ebx
    2a6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
#ifdef CONFIG_DEBUG_SG
	BUG_ON(sg->sg_magic != SG_MAGIC);
	BUG_ON(sg_is_chain(sg));
#endif
	return (struct page *)((sg)->page_link & ~0x3);
    2a70:	8b 03                	mov    (%ebx),%eax
    2a72:	83 c7 01             	add    $0x1,%edi
    2a75:	83 e0 fc             	and    $0xfffffffc,%eax
 *   mapping.
 *
 **/
static inline void *sg_virt(struct scatterlist *sg)
{
	return page_address(sg_page(sg)) + sg->offset;
    2a78:	e8 fc ff ff ff       	call   2a79 <mpt_send_target_data+0x89>
    2a7d:	89 d8                	mov    %ebx,%eax
    2a7f:	e8 fc ff ff ff       	call   2a80 <mpt_send_target_data+0x90>
    2a84:	39 fe                	cmp    %edi,%esi
    2a86:	89 c3                	mov    %eax,%ebx
    2a88:	7f e6                	jg     2a70 <mpt_send_target_data+0x80>
    2a8a:	8b 75 d4             	mov    -0x2c(%ebp),%esi
    2a8d:	8b 5d d0             	mov    -0x30(%ebp),%ebx
		kmemcheck_mark_initialized(sg_virt(s), s->length);
	BUG_ON(!valid_dma_direction(dir));
    2a90:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    2a94:	0f 87 e9 04 00 00    	ja     2f83 <mpt_send_target_data+0x593>
	ents = ops->map_sg(dev, sg, nents, dir, attrs);
    2a9a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2a9d:	8b 7d dc             	mov    -0x24(%ebp),%edi
    2aa0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2aa3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    2aa6:	89 04 24             	mov    %eax,(%esp)
    2aa9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2aac:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    2ab3:	00 
    2ab4:	ff 57 18             	call   *0x18(%edi)
    2ab7:	66 89 43 04          	mov    %ax,0x4(%ebx)
				   scst_to_tgt_dma_dir(prm->data_direction));

	pci_dma_sync_sg_for_cpu(priv->ioc->pcidev, prm->sg, prm->use_sg,
			scst_to_tgt_dma_dir(prm->data_direction));
    2abb:	8b 43 14             	mov    0x14(%ebx),%eax
    2abe:	e8 fc ff ff ff       	call   2abf <mpt_send_target_data+0xcf>

	prm->sg = (struct scatterlist *)prm->buffer;
	prm->seg_cnt = pci_map_sg(priv->ioc->pcidev, prm->sg, prm->use_sg,
				   scst_to_tgt_dma_dir(prm->data_direction));

	pci_dma_sync_sg_for_cpu(priv->ioc->pcidev, prm->sg, prm->use_sg,
    2ac3:	0f b7 4b 06          	movzwl 0x6(%ebx),%ecx
			scst_to_tgt_dma_dir(prm->data_direction));
    2ac7:	89 c2                	mov    %eax,%edx

	prm->sg = (struct scatterlist *)prm->buffer;
	prm->seg_cnt = pci_map_sg(priv->ioc->pcidev, prm->sg, prm->use_sg,
				   scst_to_tgt_dma_dir(prm->data_direction));

	pci_dma_sync_sg_for_cpu(priv->ioc->pcidev, prm->sg, prm->use_sg,
    2ac9:	8b 43 08             	mov    0x8(%ebx),%eax
    2acc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    2acf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2ad2:	8b 00                	mov    (%eax),%eax
    2ad4:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax

static inline void
pci_dma_sync_sg_for_cpu(struct pci_dev *hwdev, struct scatterlist *sg,
		int nelems, int direction)
{
	dma_sync_sg_for_cpu(hwdev == NULL ? NULL : &hwdev->dev, sg, nelems, (enum dma_data_direction)direction);
    2ada:	8d 78 64             	lea    0x64(%eax),%edi
    2add:	89 7d f0             	mov    %edi,-0x10(%ebp)
    2ae0:	31 ff                	xor    %edi,%edi
    2ae2:	85 c0                	test   %eax,%eax
    2ae4:	0f 45 7d f0          	cmovne -0x10(%ebp),%edi
dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
		    int nelems, enum dma_data_direction dir)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
    2ae8:	83 fa 02             	cmp    $0x2,%edx
    2aeb:	a1 00 00 00 00       	mov    0x0,%eax
    2af0:	0f 87 88 04 00 00    	ja     2f7e <mpt_send_target_data+0x58e>
	if (ops->sync_sg_for_cpu)
    2af6:	8b 40 28             	mov    0x28(%eax),%eax
    2af9:	85 c0                	test   %eax,%eax
    2afb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    2afe:	74 11                	je     2b11 <mpt_send_target_data+0x121>
		ops->sync_sg_for_cpu(dev, sg, nelems, dir);
    2b00:	89 14 24             	mov    %edx,(%esp)
    2b03:	89 f8                	mov    %edi,%eax
    2b05:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2b08:	8b 7d f0             	mov    -0x10(%ebp),%edi
    2b0b:	ff d7                	call   *%edi
    2b0d:	0f b7 4b 06          	movzwl 0x6(%ebx),%ecx
			scst_to_tgt_dma_dir(prm->data_direction));
	for (i = 0; i < prm->use_sg; i++) {
    2b11:	85 c9                	test   %ecx,%ecx
    2b13:	74 63                	je     2b78 <mpt_send_target_data+0x188>
    2b15:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2b18:	31 d2                	xor    %edx,%edx
    2b1a:	31 c9                	xor    %ecx,%ecx
    2b1c:	89 75 f0             	mov    %esi,-0x10(%ebp)
    2b1f:	05 a4 07 00 00       	add    $0x7a4,%eax
    2b24:	eb 18                	jmp    2b3e <mpt_send_target_data+0x14e>
    2b26:	66 90                	xchg   %ax,%ax
		sgl->sge[i].length = sg_dma_len(&prm->sg[i]);
		sgl->sge[i].address = sg_dma_address(&prm->sg[i]);

		TRACE_DBG("%d, %d", bufflen, prm->sg[i].length);
		if (bufflen < prm->sg[i].length)
    2b28:	8b 30                	mov    (%eax),%esi
    2b2a:	29 75 f0             	sub    %esi,-0x10(%ebp)
	prm->seg_cnt = pci_map_sg(priv->ioc->pcidev, prm->sg, prm->use_sg,
				   scst_to_tgt_dma_dir(prm->data_direction));

	pci_dma_sync_sg_for_cpu(priv->ioc->pcidev, prm->sg, prm->use_sg,
			scst_to_tgt_dma_dir(prm->data_direction));
	for (i = 0; i < prm->use_sg; i++) {
    2b2d:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
    2b31:	83 c1 01             	add    $0x1,%ecx
    2b34:	83 c2 18             	add    $0x18,%edx
    2b37:	83 c0 0c             	add    $0xc,%eax
    2b3a:	39 f9                	cmp    %edi,%ecx
    2b3c:	7d 3a                	jge    2b78 <mpt_send_target_data+0x188>
		sgl->sge[i].length = sg_dma_len(&prm->sg[i]);
    2b3e:	8b 7b 08             	mov    0x8(%ebx),%edi
    2b41:	8b 7c 17 14          	mov    0x14(%edi,%edx,1),%edi
    2b45:	89 38                	mov    %edi,(%eax)
		sgl->sge[i].address = sg_dma_address(&prm->sg[i]);
    2b47:	8b 7b 08             	mov    0x8(%ebx),%edi
    2b4a:	8b 74 17 0c          	mov    0xc(%edi,%edx,1),%esi
    2b4e:	8b 7c 17 10          	mov    0x10(%edi,%edx,1),%edi
    2b52:	89 70 04             	mov    %esi,0x4(%eax)

		TRACE_DBG("%d, %d", bufflen, prm->sg[i].length);
		if (bufflen < prm->sg[i].length)
    2b55:	8b 75 f0             	mov    -0x10(%ebp),%esi

	pci_dma_sync_sg_for_cpu(priv->ioc->pcidev, prm->sg, prm->use_sg,
			scst_to_tgt_dma_dir(prm->data_direction));
	for (i = 0; i < prm->use_sg; i++) {
		sgl->sge[i].length = sg_dma_len(&prm->sg[i]);
		sgl->sge[i].address = sg_dma_address(&prm->sg[i]);
    2b58:	89 78 08             	mov    %edi,0x8(%eax)

		TRACE_DBG("%d, %d", bufflen, prm->sg[i].length);
		if (bufflen < prm->sg[i].length)
    2b5b:	8b 7b 08             	mov    0x8(%ebx),%edi
    2b5e:	39 74 17 08          	cmp    %esi,0x8(%edi,%edx,1)
    2b62:	76 c4                	jbe    2b28 <mpt_send_target_data+0x138>
			sgl->sge[i].length = bufflen;
    2b64:	8b 75 f0             	mov    -0x10(%ebp),%esi
    2b67:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2b6e:	89 30                	mov    %esi,(%eax)
    2b70:	eb bb                	jmp    2b2d <mpt_send_target_data+0x13d>
    2b72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		mpt_dump_sge(&sgl->sge[i], &prm->sg[i]);
		bufflen -= sgl->sge[i].length;
	}
	pci_dma_sync_sg_for_device(priv->ioc->pcidev, prm->sg, prm->use_sg,
			scst_to_tgt_dma_dir(prm->data_direction));
    2b78:	8b 43 14             	mov    0x14(%ebx),%eax

static inline void
pci_dma_sync_sg_for_device(struct pci_dev *hwdev, struct scatterlist *sg,
		int nelems, int direction)
{
	dma_sync_sg_for_device(hwdev == NULL ? NULL : &hwdev->dev, sg, nelems, (enum dma_data_direction)direction);
    2b7b:	31 ff                	xor    %edi,%edi
    2b7d:	e8 fc ff ff ff       	call   2b7e <mpt_send_target_data+0x18e>
		if (bufflen < prm->sg[i].length)
			sgl->sge[i].length = bufflen;
		mpt_dump_sge(&sgl->sge[i], &prm->sg[i]);
		bufflen -= sgl->sge[i].length;
	}
	pci_dma_sync_sg_for_device(priv->ioc->pcidev, prm->sg, prm->use_sg,
    2b82:	8b 73 08             	mov    0x8(%ebx),%esi
    2b85:	8b 55 ec             	mov    -0x14(%ebp),%edx
    2b88:	0f b7 4b 06          	movzwl 0x6(%ebx),%ecx
    2b8c:	89 75 f0             	mov    %esi,-0x10(%ebp)
    2b8f:	8b 32                	mov    (%edx),%esi
    2b91:	8b 96 48 01 00 00    	mov    0x148(%esi),%edx
    2b97:	89 75 d4             	mov    %esi,-0x2c(%ebp)
    2b9a:	85 d2                	test   %edx,%edx
    2b9c:	8d 72 64             	lea    0x64(%edx),%esi
    2b9f:	8b 15 00 00 00 00    	mov    0x0,%edx
    2ba5:	0f 45 fe             	cmovne %esi,%edi
dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
		       int nelems, enum dma_data_direction dir)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
    2ba8:	83 f8 02             	cmp    $0x2,%eax
    2bab:	0f 87 cb 03 00 00    	ja     2f7c <mpt_send_target_data+0x58c>
	if (ops->sync_sg_for_device)
    2bb1:	8b 72 2c             	mov    0x2c(%edx),%esi
    2bb4:	85 f6                	test   %esi,%esi
    2bb6:	74 12                	je     2bca <mpt_send_target_data+0x1da>
		ops->sync_sg_for_device(dev, sg, nelems, dir);
    2bb8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2bbb:	89 04 24             	mov    %eax,(%esp)
    2bbe:	89 f8                	mov    %edi,%eax
    2bc0:	ff d6                	call   *%esi
    2bc2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2bc5:	8b 00                	mov    (%eax),%eax
    2bc7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			scst_to_tgt_dma_dir(prm->data_direction));

	sgl->num_sges = prm->seg_cnt;
    2bca:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
    2bce:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2bd1:	89 81 a0 07 00 00    	mov    %eax,0x7a0(%ecx)
	priv = prm->tgt->priv;
	sgl = &priv->sgl;

	mpt_sge_to_sgl(prm, priv, sgl);

	reply_word = prm->cmd->CMD->reply_word;
    2bd7:	8b 43 24             	mov    0x24(%ebx),%eax
    2bda:	8b 40 0c             	mov    0xc(%eax),%eax
	index = GET_IO_INDEX(reply_word);

	lun = prm->cmd->CMD->lun;
    2bdd:	8b 90 e8 03 00 00    	mov    0x3e8(%eax),%edx
	priv = prm->tgt->priv;
	sgl = &priv->sgl;

	mpt_sge_to_sgl(prm, priv, sgl);

	reply_word = prm->cmd->CMD->reply_word;
    2be3:	8b b0 e0 03 00 00    	mov    0x3e0(%eax),%esi
	index = GET_IO_INDEX(reply_word);

	lun = prm->cmd->CMD->lun;
	tag = prm->cmd->CMD->tag;
    2be9:	8b 80 ec 03 00 00    	mov    0x3ec(%eax),%eax
	mpt_sge_to_sgl(prm, priv, sgl);

	reply_word = prm->cmd->CMD->reply_word;
	index = GET_IO_INDEX(reply_word);

	lun = prm->cmd->CMD->lun;
    2bef:	89 55 f0             	mov    %edx,-0x10(%ebp)
	tag = prm->cmd->CMD->tag;

	if (prm->data_direction == SCST_DATA_READ)
		flags |= TARGET_ASSIST_FLAGS_DATA_DIRECTION;
    2bf2:	8b 55 d8             	mov    -0x28(%ebp),%edx
	sgl = &priv->sgl;

	mpt_sge_to_sgl(prm, priv, sgl);

	reply_word = prm->cmd->CMD->reply_word;
	index = GET_IO_INDEX(reply_word);
    2bf5:	89 f1                	mov    %esi,%ecx

	lun = prm->cmd->CMD->lun;
	tag = prm->cmd->CMD->tag;
    2bf7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	sgl = &priv->sgl;

	mpt_sge_to_sgl(prm, priv, sgl);

	reply_word = prm->cmd->CMD->reply_word;
	index = GET_IO_INDEX(reply_word);
    2bfa:	81 e1 ff 3f 00 00    	and    $0x3fff,%ecx
    2c00:	89 4d e8             	mov    %ecx,-0x18(%ebp)

	lun = prm->cmd->CMD->lun;
	tag = prm->cmd->CMD->tag;

	if (prm->data_direction == SCST_DATA_READ)
		flags |= TARGET_ASSIST_FLAGS_DATA_DIRECTION;
    2c03:	89 d0                	mov    %edx,%eax
    2c05:	83 c8 01             	or     $0x1,%eax
    2c08:	83 7b 14 02          	cmpl   $0x2,0x14(%ebx)
    2c0c:	0f 45 c2             	cmovne %edx,%eax
    2c0f:	89 45 d8             	mov    %eax,-0x28(%ebp)

	length = prm->bufflen;
    2c12:	8b 43 0c             	mov    0xc(%ebx),%eax
    2c15:	8d 1c 8d 00 00 00 00 	lea    0x0(,%ecx,4),%ebx
    2c1c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	}
}

static inline MPT_FRAME_HDR *mpt_msg_frame_alloc(MPT_ADAPTER *ioc, int index)
{
	MPT_STM_PRIV *priv = mpt_stm_priv[ioc->id];
    2c1f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2c22:	8b 00                	mov    (%eax),%eax
    2c24:	8b 3c 85 20 00 00 00 	mov    0x20(,%eax,4),%edi
    2c2b:	01 df                	add    %ebx,%edi
	MPT_FRAME_HDR *mf;

	if (index != -1) {
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
    2c2d:	8b 87 a0 03 00 00    	mov    0x3a0(%edi),%eax
    2c33:	85 c0                	test   %eax,%eax
    2c35:	0f 85 2d 03 00 00    	jne    2f68 <mpt_send_target_data+0x578>
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    2c3b:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    2c42:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    2c45:	e8 fc ff ff ff       	call   2c46 <mpt_send_target_data+0x256>

	sBUG_ON(mf == NULL);
    2c4a:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    2c4c:	89 45 dc             	mov    %eax,-0x24(%ebp)

	sBUG_ON(mf == NULL);
    2c4f:	0f 84 81 03 00 00    	je     2fd6 <mpt_send_target_data+0x5e6>

	if (index != -1)
		priv->current_mf[index] = mf;
    2c55:	8b 45 dc             	mov    -0x24(%ebp),%eax
	int chain_length, i, j, k, init_index, res = 1;
	dma_addr_t dma_addr;

	TRACE_ENTRY();
	req = (TargetAssistRequest_t *)mpt_msg_frame_alloc(ioc, index);
	memset(req, 0, sizeof(*req));
    2c58:	ba 2c 00 00 00       	mov    $0x2c,%edx
    2c5d:	a8 01                	test   $0x1,%al
	mf = mpt_get_msg_frame(stm_context, _IOC_ID);

	sBUG_ON(mf == NULL);

	if (index != -1)
		priv->current_mf[index] = mf;
    2c5f:	89 87 a0 03 00 00    	mov    %eax,0x3a0(%edi)
	int chain_length, i, j, k, init_index, res = 1;
	dma_addr_t dma_addr;

	TRACE_ENTRY();
	req = (TargetAssistRequest_t *)mpt_msg_frame_alloc(ioc, index);
	memset(req, 0, sizeof(*req));
    2c65:	89 c7                	mov    %eax,%edi
    2c67:	0f 85 d5 02 00 00    	jne    2f42 <mpt_send_target_data+0x552>
    2c6d:	f7 c7 02 00 00 00    	test   $0x2,%edi
    2c73:	0f 85 d6 02 00 00    	jne    2f4f <mpt_send_target_data+0x55f>
    2c79:	89 d1                	mov    %edx,%ecx
    2c7b:	31 c0                	xor    %eax,%eax
    2c7d:	c1 e9 02             	shr    $0x2,%ecx
    2c80:	f6 c2 02             	test   $0x2,%dl
    2c83:	f3 ab                	rep stos %eax,%es:(%edi)
    2c85:	0f 85 9a 02 00 00    	jne    2f25 <mpt_send_target_data+0x535>
    2c8b:	83 e2 01             	and    $0x1,%edx
    2c8e:	0f 85 89 02 00 00    	jne    2f1d <mpt_send_target_data+0x52d>

	if (priv->exiting)
    2c94:	8b 7d ec             	mov    -0x14(%ebp),%edi
		flags &= ~TARGET_ASSIST_FLAGS_REPOST_CMD_BUFFER;
    2c97:	8b 4d d8             	mov    -0x28(%ebp),%ecx

	TRACE_ENTRY();
	req = (TargetAssistRequest_t *)mpt_msg_frame_alloc(ioc, index);
	memset(req, 0, sizeof(*req));

	if (priv->exiting)
    2c9a:	8b 97 80 00 00 00    	mov    0x80(%edi),%edx
		flags &= ~TARGET_ASSIST_FLAGS_REPOST_CMD_BUFFER;
    2ca0:	89 c8                	mov    %ecx,%eax
    2ca2:	24 7f                	and    $0x7f,%al
    2ca4:	85 d2                	test   %edx,%edx
    2ca6:	0f 44 c1             	cmove  %ecx,%eax
    2ca9:	01 fb                	add    %edi,%ebx
    2cab:	89 45 d8             	mov    %eax,-0x28(%ebp)

	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
    2cae:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    2cb4:	89 5d d0             	mov    %ebx,-0x30(%ebp)
    2cb7:	a8 80                	test   $0x80,%al
    2cb9:	0f 85 32 01 00 00    	jne    2df1 <mpt_send_target_data+0x401>
		}*/
	}
	TRACE_DBG("flags %x, tag %x, lun %x, offset %x, length %x",
		  flags, tag, lun, offset, length);

	req->StatusCode = 0;
    2cbf:	8b 4d dc             	mov    -0x24(%ebp),%ecx
	req->TargetAssistFlags = (u8)flags;
	req->Function = MPI_FUNCTION_TARGET_ASSIST;
	req->QueueTag = (u16)tag;
    2cc2:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
	}
	TRACE_DBG("flags %x, tag %x, lun %x, offset %x, length %x",
		  flags, tag, lun, offset, length);

	req->StatusCode = 0;
	req->TargetAssistFlags = (u8)flags;
    2cc6:	8b 55 d8             	mov    -0x28(%ebp),%edx
	req->Function = MPI_FUNCTION_TARGET_ASSIST;
	req->QueueTag = (u16)tag;
	req->ReplyWord = cpu_to_le32(reply_word);
    2cc9:	89 71 0c             	mov    %esi,0xc(%ecx)
	req->LUN[0] = (u8)(lun >> 8);
    2ccc:	8b 75 f0             	mov    -0x10(%ebp),%esi
	sge_flags =
		MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_SIMPLE_ELEMENT |
				  MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
	if (flags & TARGET_ASSIST_FLAGS_DATA_DIRECTION)
		sge_flags |= MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_HOST_TO_IOC);
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
    2ccf:	8d 59 20             	lea    0x20(%ecx),%ebx
		  flags, tag, lun, offset, length);

	req->StatusCode = 0;
	req->TargetAssistFlags = (u8)flags;
	req->Function = MPI_FUNCTION_TARGET_ASSIST;
	req->QueueTag = (u16)tag;
    2cd2:	66 89 41 04          	mov    %ax,0x4(%ecx)
		}*/
	}
	TRACE_DBG("flags %x, tag %x, lun %x, offset %x, length %x",
		  flags, tag, lun, offset, length);

	req->StatusCode = 0;
    2cd6:	c6 01 00             	movb   $0x0,(%ecx)
	req->TargetAssistFlags = (u8)flags;
    2cd9:	88 51 01             	mov    %dl,0x1(%ecx)
	req->Function = MPI_FUNCTION_TARGET_ASSIST;
	req->QueueTag = (u16)tag;
	req->ReplyWord = cpu_to_le32(reply_word);
	req->LUN[0] = (u8)(lun >> 8);
    2cdc:	89 f0                	mov    %esi,%eax
    2cde:	c1 f8 08             	sar    $0x8,%eax
    2ce1:	88 41 10             	mov    %al,0x10(%ecx)
	req->LUN[1] = (u8)lun;
    2ce4:	89 f0                	mov    %esi,%eax
    2ce6:	88 41 11             	mov    %al,0x11(%ecx)
	req->RelativeOffset = cpu_to_le32(offset);
	req->DataLength = cpu_to_le32(length);
    2ce9:	8b 45 e0             	mov    -0x20(%ebp),%eax
	TRACE_DBG("flags %x, tag %x, lun %x, offset %x, length %x",
		  flags, tag, lun, offset, length);

	req->StatusCode = 0;
	req->TargetAssistFlags = (u8)flags;
	req->Function = MPI_FUNCTION_TARGET_ASSIST;
    2cec:	c6 41 03 0b          	movb   $0xb,0x3(%ecx)
	req->QueueTag = (u16)tag;
	req->ReplyWord = cpu_to_le32(reply_word);
	req->LUN[0] = (u8)(lun >> 8);
	req->LUN[1] = (u8)lun;
	req->RelativeOffset = cpu_to_le32(offset);
    2cf0:	c7 41 18 00 00 00 00 	movl   $0x0,0x18(%ecx)
	req->DataLength = cpu_to_le32(length);
    2cf7:	89 41 1c             	mov    %eax,0x1c(%ecx)
	sge_flags =
		MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_SIMPLE_ELEMENT |
				  MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
	if (flags & TARGET_ASSIST_FLAGS_DATA_DIRECTION)
    2cfa:	89 d0                	mov    %edx,%eax
    2cfc:	83 e0 01             	and    $0x1,%eax
	req->ReplyWord = cpu_to_le32(reply_word);
	req->LUN[0] = (u8)(lun >> 8);
	req->LUN[1] = (u8)lun;
	req->RelativeOffset = cpu_to_le32(offset);
	req->DataLength = cpu_to_le32(length);
	sge_flags =
    2cff:	83 f8 01             	cmp    $0x1,%eax
    2d02:	19 c0                	sbb    %eax,%eax
    2d04:	89 45 f0             	mov    %eax,-0x10(%ebp)
		MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_SIMPLE_ELEMENT |
				  MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
	if (flags & TARGET_ASSIST_FLAGS_DATA_DIRECTION)
		sge_flags |= MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_HOST_TO_IOC);
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	for (i = 0, j = 0, k = 0; i < (int)sgl->num_sges; i++, j++) {
    2d07:	8b 45 ec             	mov    -0x14(%ebp),%eax
	req->ReplyWord = cpu_to_le32(reply_word);
	req->LUN[0] = (u8)(lun >> 8);
	req->LUN[1] = (u8)lun;
	req->RelativeOffset = cpu_to_le32(offset);
	req->DataLength = cpu_to_le32(length);
	sge_flags =
    2d0a:	81 65 f0 00 00 00 fc 	andl   $0xfc000000,-0x10(%ebp)
    2d11:	81 45 f0 00 00 00 16 	addl   $0x16000000,-0x10(%ebp)
		MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_SIMPLE_ELEMENT |
				  MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
	if (flags & TARGET_ASSIST_FLAGS_DATA_DIRECTION)
		sge_flags |= MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_HOST_TO_IOC);
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	for (i = 0, j = 0, k = 0; i < (int)sgl->num_sges; i++, j++) {
    2d18:	8b 80 a0 07 00 00    	mov    0x7a0(%eax),%eax
    2d1e:	85 c0                	test   %eax,%eax
    2d20:	0f 8e 3a 02 00 00    	jle    2f60 <mpt_send_target_data+0x570>
				sge_chain = (MPT_STM_CHAIN *)(sge_simple - 1);
				sge_chain->Flags =
					(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
						 MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
				dma_addr = priv->hw_dma +
					((u8 *)priv->hw->cmd_buf[index].chain_sge -
    2d26:	69 45 e8 f0 03 00 00 	imul   $0x3f0,-0x18(%ebp),%eax
		MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_SIMPLE_ELEMENT |
				  MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
	if (flags & TARGET_ASSIST_FLAGS_DATA_DIRECTION)
		sge_flags |= MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_HOST_TO_IOC);
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	for (i = 0, j = 0, k = 0; i < (int)sgl->num_sges; i++, j++) {
    2d2d:	31 f6                	xor    %esi,%esi
    2d2f:	8b 7d ec             	mov    -0x14(%ebp),%edi
    2d32:	31 d2                	xor    %edx,%edx
			     int length, int offset)
{
	MPT_ADAPTER *ioc = priv->ioc;
	TargetAssistRequest_t *req;
	MPT_STM_SIMPLE	*sge_simple;
	MPT_STM_CHAIN	*sge_chain = NULL;
    2d34:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_SIMPLE_ELEMENT |
				  MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
	if (flags & TARGET_ASSIST_FLAGS_DATA_DIRECTION)
		sge_flags |= MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_HOST_TO_IOC);
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	for (i = 0, j = 0, k = 0; i < (int)sgl->num_sges; i++, j++) {
    2d3b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				sge_chain = (MPT_STM_CHAIN *)(sge_simple - 1);
				sge_chain->Flags =
					(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
						 MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
				dma_addr = priv->hw_dma +
					((u8 *)priv->hw->cmd_buf[index].chain_sge -
    2d42:	83 e8 80             	sub    $0xffffff80,%eax
    2d45:	8d 8f 98 07 00 00    	lea    0x798(%edi),%ecx
    2d4b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2d4e:	eb 39                	jmp    2d89 <mpt_send_target_data+0x399>
		sge_flags |= MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_HOST_TO_IOC);
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	for (i = 0, j = 0, k = 0; i < (int)sgl->num_sges; i++, j++) {
		if (k == 0) {
			/* still in mf, haven't chained yet -- do we need to? */
			if (j == priv->num_sge_target_assist) {
    2d50:	39 57 10             	cmp    %edx,0x10(%edi)
    2d53:	0f 84 c7 00 00 00    	je     2e20 <mpt_send_target_data+0x430>
				j = 1;
				k++;
			}
		} else {
			/* now in chain, do we need to chain again? */
			if (j == priv->num_sge_chain) {
    2d59:	83 c2 01             	add    $0x1,%edx
    2d5c:	89 d8                	mov    %ebx,%eax
				/* say we've chained */
				j = 1;
				k++;
			}
		}
		sge_simple->FlagsLength = cpu_to_le32(sgl->sge[i].length | sge_flags);
    2d5e:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_SIMPLE_ELEMENT |
				  MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
	if (flags & TARGET_ASSIST_FLAGS_DATA_DIRECTION)
		sge_flags |= MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_HOST_TO_IOC);
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	for (i = 0, j = 0, k = 0; i < (int)sgl->num_sges; i++, j++) {
    2d61:	83 c6 01             	add    $0x1,%esi
    2d64:	83 c1 0c             	add    $0xc,%ecx
				/* say we've chained */
				j = 1;
				k++;
			}
		}
		sge_simple->FlagsLength = cpu_to_le32(sgl->sge[i].length | sge_flags);
    2d67:	0b 19                	or     (%ecx),%ebx
    2d69:	89 18                	mov    %ebx,(%eax)
    2d6b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
		stm_set_dma_addr(sge_simple->Address, sgl->sge[i].address);
    2d6e:	8b 59 04             	mov    0x4(%ecx),%ebx
    2d71:	89 58 04             	mov    %ebx,0x4(%eax)
    2d74:	8b 59 08             	mov    0x8(%ecx),%ebx
    2d77:	89 58 08             	mov    %ebx,0x8(%eax)
		mpt_dump_sge(&sgl->sge[i], NULL);
		sge_simple++;
    2d7a:	8d 58 0c             	lea    0xc(%eax),%ebx
		MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_SIMPLE_ELEMENT |
				  MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
	if (flags & TARGET_ASSIST_FLAGS_DATA_DIRECTION)
		sge_flags |= MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_HOST_TO_IOC);
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	for (i = 0, j = 0, k = 0; i < (int)sgl->num_sges; i++, j++) {
    2d7d:	3b b7 a0 07 00 00    	cmp    0x7a0(%edi),%esi
    2d83:	0f 8d f7 00 00 00    	jge    2e80 <mpt_send_target_data+0x490>
		if (k == 0) {
    2d89:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2d8c:	85 c0                	test   %eax,%eax
    2d8e:	74 c0                	je     2d50 <mpt_send_target_data+0x360>
				j = 1;
				k++;
			}
		} else {
			/* now in chain, do we need to chain again? */
			if (j == priv->num_sge_chain) {
    2d90:	3b 57 0c             	cmp    0xc(%edi),%edx
    2d93:	75 c4                	jne    2d59 <mpt_send_target_data+0x369>
				/* yes, we need to chain */
				/* fix up the previous chain element */
				chain_length = sizeof(MPT_STM_CHAIN) +
    2d95:	8d 04 52             	lea    (%edx,%edx,2),%eax
					(priv->num_sge_chain - 1) * sizeof(MPT_STM_SIMPLE);
				sge_chain->Length = cpu_to_le16(chain_length);
    2d98:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		} else {
			/* now in chain, do we need to chain again? */
			if (j == priv->num_sge_chain) {
				/* yes, we need to chain */
				/* fix up the previous chain element */
				chain_length = sizeof(MPT_STM_CHAIN) +
    2d9b:	c1 e0 02             	shl    $0x2,%eax
					(priv->num_sge_chain - 1) * sizeof(MPT_STM_SIMPLE);
				sge_chain->Length = cpu_to_le16(chain_length);
    2d9e:	66 89 02             	mov    %ax,(%edx)
				sge_chain->NextChainOffset =
					(chain_length - sizeof(MPT_STM_CHAIN)) / sizeof(u32);
    2da1:	83 e8 0c             	sub    $0xc,%eax
    2da4:	c1 e8 02             	shr    $0x2,%eax
				/* yes, we need to chain */
				/* fix up the previous chain element */
				chain_length = sizeof(MPT_STM_CHAIN) +
					(priv->num_sge_chain - 1) * sizeof(MPT_STM_SIMPLE);
				sge_chain->Length = cpu_to_le16(chain_length);
				sge_chain->NextChainOffset =
    2da7:	88 42 02             	mov    %al,0x2(%edx)
					(chain_length - sizeof(MPT_STM_CHAIN)) / sizeof(u32);
				/* overwrite the last element in the chain with another chain */
				sge_chain = (MPT_STM_CHAIN *)(sge_simple - 1);
    2daa:	8d 43 f4             	lea    -0xc(%ebx),%eax
				sge_chain->Flags =
    2dad:	c6 43 f7 32          	movb   $0x32,-0x9(%ebx)
					(priv->num_sge_chain - 1) * sizeof(MPT_STM_SIMPLE);
				sge_chain->Length = cpu_to_le16(chain_length);
				sge_chain->NextChainOffset =
					(chain_length - sizeof(MPT_STM_CHAIN)) / sizeof(u32);
				/* overwrite the last element in the chain with another chain */
				sge_chain = (MPT_STM_CHAIN *)(sge_simple - 1);
    2db1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				sge_chain->Flags =
					(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
						 MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
				dma_addr = priv->hw_dma + ((u8 *)sge_simple - (u8 *)priv->hw);
    2db4:	89 d8                	mov    %ebx,%eax
    2db6:	2b 47 20             	sub    0x20(%edi),%eax
    2db9:	99                   	cltd   
    2dba:	03 47 24             	add    0x24(%edi),%eax
    2dbd:	13 57 28             	adc    0x28(%edi),%edx
				stm_set_dma_addr(sge_chain->Address, dma_addr);
				/* set the "last element" flag in the previous chain */
				sge_simple = (MPT_STM_SIMPLE *)(sge_chain - 1);
				sge_simple->FlagsLength |=
    2dc0:	81 4b e8 00 00 00 80 	orl    $0x80000000,-0x18(%ebx)
				stm_set_dma_addr(sge_simple->Address, sgl->sge[i-1].address);
				mpt_dump_sge(&sgl->sge[i-1], NULL);
				sge_simple++;
				/* say we've chained */
				j = 1;
				k++;
    2dc7:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
				sge_chain = (MPT_STM_CHAIN *)(sge_simple - 1);
				sge_chain->Flags =
					(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
						 MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
				dma_addr = priv->hw_dma + ((u8 *)sge_simple - (u8 *)priv->hw);
				stm_set_dma_addr(sge_chain->Address, dma_addr);
    2dcb:	89 43 f8             	mov    %eax,-0x8(%ebx)
				sge_simple->FlagsLength |=
					cpu_to_le32(MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_LAST_ELEMENT));
				/* redo the last element in the previous chain */
				sge_simple = (MPT_STM_SIMPLE *)(sge_chain + 1);
				sge_simple->FlagsLength =
					cpu_to_le32(sgl->sge[i-1].length | sge_flags);
    2dce:	8b 45 f0             	mov    -0x10(%ebp),%eax
				sge_chain = (MPT_STM_CHAIN *)(sge_simple - 1);
				sge_chain->Flags =
					(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
						 MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
				dma_addr = priv->hw_dma + ((u8 *)sge_simple - (u8 *)priv->hw);
				stm_set_dma_addr(sge_chain->Address, dma_addr);
    2dd1:	89 53 fc             	mov    %edx,-0x4(%ebx)
				stm_set_dma_addr(sge_simple->Address, sgl->sge[i-1].address);
				mpt_dump_sge(&sgl->sge[i-1], NULL);
				sge_simple++;
				/* say we've chained */
				j = 1;
				k++;
    2dd4:	ba 02 00 00 00       	mov    $0x2,%edx
				sge_simple->FlagsLength |=
					cpu_to_le32(MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_LAST_ELEMENT));
				/* redo the last element in the previous chain */
				sge_simple = (MPT_STM_SIMPLE *)(sge_chain + 1);
				sge_simple->FlagsLength =
					cpu_to_le32(sgl->sge[i-1].length | sge_flags);
    2dd9:	0b 01                	or     (%ecx),%eax
				sge_simple = (MPT_STM_SIMPLE *)(sge_chain - 1);
				sge_simple->FlagsLength |=
					cpu_to_le32(MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_LAST_ELEMENT));
				/* redo the last element in the previous chain */
				sge_simple = (MPT_STM_SIMPLE *)(sge_chain + 1);
				sge_simple->FlagsLength =
    2ddb:	89 03                	mov    %eax,(%ebx)
					cpu_to_le32(sgl->sge[i-1].length | sge_flags);
				stm_set_dma_addr(sge_simple->Address, sgl->sge[i-1].address);
    2ddd:	8b 41 04             	mov    0x4(%ecx),%eax
    2de0:	89 43 04             	mov    %eax,0x4(%ebx)
    2de3:	8b 41 08             	mov    0x8(%ecx),%eax
    2de6:	89 43 08             	mov    %eax,0x8(%ebx)
				mpt_dump_sge(&sgl->sge[i-1], NULL);
				sge_simple++;
    2de9:	8d 43 0c             	lea    0xc(%ebx),%eax
    2dec:	e9 6d ff ff ff       	jmp    2d5e <mpt_send_target_data+0x36e>
	if (priv->exiting)
		flags &= ~TARGET_ASSIST_FLAGS_REPOST_CMD_BUFFER;

	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
		flags |= TARGET_ASSIST_FLAGS_HIGH_PRIORITY;
		if (flags & TARGET_ASSIST_FLAGS_AUTO_STATUS) {
    2df1:	f6 45 d8 02          	testb  $0x2,-0x28(%ebp)
    2df5:	0f 84 3e 01 00 00    	je     2f39 <mpt_send_target_data+0x549>
			flags |= TARGET_ASSIST_FLAGS_REPOST_CMD_BUFFER;
			priv->io_state[index] |= IO_STATE_AUTO_REPOST;
    2dfb:	8b 4d d0             	mov    -0x30(%ebp),%ecx
		flags &= ~TARGET_ASSIST_FLAGS_REPOST_CMD_BUFFER;

	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
		flags |= TARGET_ASSIST_FLAGS_HIGH_PRIORITY;
		if (flags & TARGET_ASSIST_FLAGS_AUTO_STATUS) {
			flags |= TARGET_ASSIST_FLAGS_REPOST_CMD_BUFFER;
    2dfe:	81 4d d8 84 00 00 00 	orl    $0x84,-0x28(%ebp)
			priv->io_state[index] |= IO_STATE_AUTO_REPOST;
    2e05:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
    2e0b:	83 c8 20             	or     $0x20,%eax
    2e0e:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
    2e14:	e9 a6 fe ff ff       	jmp    2cbf <mpt_send_target_data+0x2cf>
    2e19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (k == 0) {
			/* still in mf, haven't chained yet -- do we need to? */
			if (j == priv->num_sge_target_assist) {
				/* yes, we need to chain */
				/* overwrite the last element in the mf with a chain */
				sge_chain = (MPT_STM_CHAIN *)(sge_simple - 1);
    2e20:	8d 43 f4             	lea    -0xc(%ebx),%eax
    2e23:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				sge_chain->Flags =
					(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
						 MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
				dma_addr = priv->hw_dma +
    2e26:	8b 45 e0             	mov    -0x20(%ebp),%eax
			/* still in mf, haven't chained yet -- do we need to? */
			if (j == priv->num_sge_target_assist) {
				/* yes, we need to chain */
				/* overwrite the last element in the mf with a chain */
				sge_chain = (MPT_STM_CHAIN *)(sge_simple - 1);
				sge_chain->Flags =
    2e29:	c6 43 f7 32          	movb   $0x32,-0x9(%ebx)
				sge_simple++;
				/* say we've chained */
				req->ChainOffset =
					((u8 *)sge_chain - (u8 *)req) / sizeof(u32);
				j = 1;
				k++;
    2e2d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
				/* overwrite the last element in the mf with a chain */
				sge_chain = (MPT_STM_CHAIN *)(sge_simple - 1);
				sge_chain->Flags =
					(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
						 MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
				dma_addr = priv->hw_dma +
    2e34:	99                   	cltd   
    2e35:	03 47 24             	add    0x24(%edi),%eax
    2e38:	13 57 28             	adc    0x28(%edi),%edx
					((u8 *)priv->hw->cmd_buf[index].chain_sge -
					 (u8 *)priv->hw);
				stm_set_dma_addr(sge_chain->Address, dma_addr);
				/* set the "last element" flag in the mf */
				sge_simple = (MPT_STM_SIMPLE *)(sge_chain - 1);
				sge_simple->FlagsLength |=
    2e3b:	81 4b e8 00 00 00 80 	orl    $0x80000000,-0x18(%ebx)
					(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
						 MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
				dma_addr = priv->hw_dma +
					((u8 *)priv->hw->cmd_buf[index].chain_sge -
					 (u8 *)priv->hw);
				stm_set_dma_addr(sge_chain->Address, dma_addr);
    2e42:	89 43 f8             	mov    %eax,-0x8(%ebx)
				/* set the "last element" flag in the mf */
				sge_simple = (MPT_STM_SIMPLE *)(sge_chain - 1);
				sge_simple->FlagsLength |=
					cpu_to_le32(MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_LAST_ELEMENT));
				/* redo the last element in the mf */
				sge_simple =
    2e45:	8b 45 e0             	mov    -0x20(%ebp),%eax
					(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
						 MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
				dma_addr = priv->hw_dma +
					((u8 *)priv->hw->cmd_buf[index].chain_sge -
					 (u8 *)priv->hw);
				stm_set_dma_addr(sge_chain->Address, dma_addr);
    2e48:	89 53 fc             	mov    %edx,-0x4(%ebx)
					cpu_to_le32(MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_LAST_ELEMENT));
				/* redo the last element in the mf */
				sge_simple =
					(MPT_STM_SIMPLE *)priv->hw->cmd_buf[index].chain_sge;
				sge_simple->FlagsLength =
					cpu_to_le32(sgl->sge[i-1].length | sge_flags);
    2e4b:	8b 55 f0             	mov    -0x10(%ebp),%edx
				/* set the "last element" flag in the mf */
				sge_simple = (MPT_STM_SIMPLE *)(sge_chain - 1);
				sge_simple->FlagsLength |=
					cpu_to_le32(MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_LAST_ELEMENT));
				/* redo the last element in the mf */
				sge_simple =
    2e4e:	03 47 20             	add    0x20(%edi),%eax
					(MPT_STM_SIMPLE *)priv->hw->cmd_buf[index].chain_sge;
				sge_simple->FlagsLength =
					cpu_to_le32(sgl->sge[i-1].length | sge_flags);
    2e51:	0b 11                	or     (%ecx),%edx
				stm_set_dma_addr(sge_simple->Address, sgl->sge[i-1].address);
				mpt_dump_sge(&sgl->sge[i-1], NULL);
				sge_simple++;
				/* say we've chained */
				req->ChainOffset =
					((u8 *)sge_chain - (u8 *)req) / sizeof(u32);
    2e53:	8b 5d dc             	mov    -0x24(%ebp),%ebx
					(MPT_STM_SIMPLE *)priv->hw->cmd_buf[index].chain_sge;
				sge_simple->FlagsLength =
					cpu_to_le32(sgl->sge[i-1].length | sge_flags);
				stm_set_dma_addr(sge_simple->Address, sgl->sge[i-1].address);
				mpt_dump_sge(&sgl->sge[i-1], NULL);
				sge_simple++;
    2e56:	83 c0 0c             	add    $0xc,%eax
				sge_simple->FlagsLength |=
					cpu_to_le32(MPI_SGE_SET_FLAGS(MPI_SGE_FLAGS_LAST_ELEMENT));
				/* redo the last element in the mf */
				sge_simple =
					(MPT_STM_SIMPLE *)priv->hw->cmd_buf[index].chain_sge;
				sge_simple->FlagsLength =
    2e59:	89 50 f4             	mov    %edx,-0xc(%eax)
					cpu_to_le32(sgl->sge[i-1].length | sge_flags);
				stm_set_dma_addr(sge_simple->Address, sgl->sge[i-1].address);
    2e5c:	8b 51 04             	mov    0x4(%ecx),%edx
    2e5f:	89 50 f8             	mov    %edx,-0x8(%eax)
    2e62:	8b 51 08             	mov    0x8(%ecx),%edx
    2e65:	89 50 fc             	mov    %edx,-0x4(%eax)
				mpt_dump_sge(&sgl->sge[i-1], NULL);
				sge_simple++;
				/* say we've chained */
				req->ChainOffset =
					((u8 *)sge_chain - (u8 *)req) / sizeof(u32);
    2e68:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    2e6b:	29 da                	sub    %ebx,%edx
    2e6d:	c1 ea 02             	shr    $0x2,%edx
					cpu_to_le32(sgl->sge[i-1].length | sge_flags);
				stm_set_dma_addr(sge_simple->Address, sgl->sge[i-1].address);
				mpt_dump_sge(&sgl->sge[i-1], NULL);
				sge_simple++;
				/* say we've chained */
				req->ChainOffset =
    2e70:	88 53 02             	mov    %dl,0x2(%ebx)
    2e73:	ba 02 00 00 00       	mov    $0x2,%edx
    2e78:	e9 e1 fe ff ff       	jmp    2d5e <mpt_send_target_data+0x36e>
    2e7d:	8d 76 00             	lea    0x0(%esi),%esi
		stm_set_dma_addr(sge_simple->Address, sgl->sge[i].address);
		mpt_dump_sge(&sgl->sge[i], NULL);
		sge_simple++;
	}
	/* did we chain? */
	if (k != 0) {
    2e80:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2e83:	8b 7d e8             	mov    -0x18(%ebp),%edi
    2e86:	85 c9                	test   %ecx,%ecx
    2e88:	74 12                	je     2e9c <mpt_send_target_data+0x4ac>
		/* fix up the last chain element */
		sge_chain->Length = cpu_to_le16(j * sizeof(MPT_STM_SIMPLE));
    2e8a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    2e8d:	8d 14 52             	lea    (%edx,%edx,2),%edx
    2e90:	c1 e2 02             	shl    $0x2,%edx
    2e93:	66 89 11             	mov    %dx,(%ecx)
		sge_chain->NextChainOffset = 0;
    2e96:	c6 41 02 00          	movb   $0x0,0x2(%ecx)
    2e9a:	8b 38                	mov    (%eax),%edi
		}
	}
#endif
	res = 0;

	priv->io_state[index] |= IO_STATE_DATA_SENT;
    2e9c:	8b 4d d0             	mov    -0x30(%ebp),%ecx
		sge_chain->Length = cpu_to_le16(j * sizeof(MPT_STM_SIMPLE));
		sge_chain->NextChainOffset = 0;
	}
	/* fix up the last element */
	sge_simple--;
	sge_simple->FlagsLength |=
    2e9f:	81 cf 00 00 00 c1    	or     $0xc1000000,%edi
    2ea5:	89 7b f4             	mov    %edi,-0xc(%ebx)
		}
	}
#endif
	res = 0;

	priv->io_state[index] |= IO_STATE_DATA_SENT;
    2ea8:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
    2eae:	83 c8 02             	or     $0x2,%eax
	if (flags & TARGET_ASSIST_FLAGS_AUTO_STATUS)
    2eb1:	f6 45 d8 02          	testb  $0x2,-0x28(%ebp)
		}
	}
#endif
	res = 0;

	priv->io_state[index] |= IO_STATE_DATA_SENT;
    2eb5:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
	if (flags & TARGET_ASSIST_FLAGS_AUTO_STATUS)
    2ebb:	74 0f                	je     2ecc <mpt_send_target_data+0x4dc>
		priv->io_state[index] |= IO_STATE_STATUS_SENT;
    2ebd:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
    2ec3:	83 c8 04             	or     $0x4,%eax
    2ec6:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)


	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
    2ecc:	8b 45 d0             	mov    -0x30(%ebp),%eax
    2ecf:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    2ed5:	a8 80                	test   $0x80,%al
    2ed7:	74 2b                	je     2f04 <mpt_send_target_data+0x514>
		res = mpt_send_handshake_request(stm_context, _IOC_ID,
    2ed9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    2edc:	8b 75 dc             	mov    -0x24(%ebp),%esi
    2edf:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    2ee6:	8b 8a 14 01 00 00    	mov    0x114(%edx),%ecx
    2eec:	89 34 24             	mov    %esi,(%esp)
    2eef:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    2ef6:	00 
    2ef7:	e8 fc ff ff ff       	call   2ef8 <mpt_send_target_data+0x508>
	mpt_send_tgt_data(priv, reply_word, index, flags, lun, tag,
			sgl, length, offset);

	TRACE_EXIT();
	return;
}
    2efc:	83 c4 34             	add    $0x34,%esp
    2eff:	5b                   	pop    %ebx
    2f00:	5e                   	pop    %esi
    2f01:	5f                   	pop    %edi
    2f02:	5d                   	pop    %ebp
    2f03:	c3                   	ret    
	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
		res = mpt_send_handshake_request(stm_context, _IOC_ID,
						 ioc->req_sz,
						 (u32 *)req _HS_SLEEP);
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    2f04:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    2f07:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    2f0a:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
	mpt_send_tgt_data(priv, reply_word, index, flags, lun, tag,
			sgl, length, offset);

	TRACE_EXIT();
	return;
}
    2f11:	83 c4 34             	add    $0x34,%esp
    2f14:	5b                   	pop    %ebx
    2f15:	5e                   	pop    %esi
    2f16:	5f                   	pop    %edi
    2f17:	5d                   	pop    %ebp
	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
		res = mpt_send_handshake_request(stm_context, _IOC_ID,
						 ioc->req_sz,
						 (u32 *)req _HS_SLEEP);
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    2f18:	e9 fc ff ff ff       	jmp    2f19 <mpt_send_target_data+0x529>
	int chain_length, i, j, k, init_index, res = 1;
	dma_addr_t dma_addr;

	TRACE_ENTRY();
	req = (TargetAssistRequest_t *)mpt_msg_frame_alloc(ioc, index);
	memset(req, 0, sizeof(*req));
    2f1d:	c6 07 00             	movb   $0x0,(%edi)
    2f20:	e9 6f fd ff ff       	jmp    2c94 <mpt_send_target_data+0x2a4>
    2f25:	31 c0                	xor    %eax,%eax
    2f27:	83 c7 02             	add    $0x2,%edi
    2f2a:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    2f2e:	83 e2 01             	and    $0x1,%edx
    2f31:	0f 84 5d fd ff ff    	je     2c94 <mpt_send_target_data+0x2a4>
    2f37:	eb e4                	jmp    2f1d <mpt_send_target_data+0x52d>

	if (priv->exiting)
		flags &= ~TARGET_ASSIST_FLAGS_REPOST_CMD_BUFFER;

	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
		flags |= TARGET_ASSIST_FLAGS_HIGH_PRIORITY;
    2f39:	83 4d d8 04          	orl    $0x4,-0x28(%ebp)
    2f3d:	e9 7d fd ff ff       	jmp    2cbf <mpt_send_target_data+0x2cf>
	int chain_length, i, j, k, init_index, res = 1;
	dma_addr_t dma_addr;

	TRACE_ENTRY();
	req = (TargetAssistRequest_t *)mpt_msg_frame_alloc(ioc, index);
	memset(req, 0, sizeof(*req));
    2f42:	c6 00 00             	movb   $0x0,(%eax)
    2f45:	8d 78 01             	lea    0x1(%eax),%edi
    2f48:	b2 2b                	mov    $0x2b,%dl
    2f4a:	e9 1e fd ff ff       	jmp    2c6d <mpt_send_target_data+0x27d>
    2f4f:	31 c0                	xor    %eax,%eax
    2f51:	83 c7 02             	add    $0x2,%edi
    2f54:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    2f58:	83 ea 02             	sub    $0x2,%edx
    2f5b:	e9 19 fd ff ff       	jmp    2c79 <mpt_send_target_data+0x289>
    2f60:	8b 79 14             	mov    0x14(%ecx),%edi
    2f63:	e9 34 ff ff ff       	jmp    2e9c <mpt_send_target_data+0x4ac>
	MPT_FRAME_HDR *mf;

	if (index != -1) {
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
    2f68:	ba 4d 01 00 00       	mov    $0x14d,%edx
    2f6d:	b8 8c 01 00 00       	mov    $0x18c,%eax
    2f72:	e8 fc ff ff ff       	call   2f73 <mpt_send_target_data+0x583>
    2f77:	e9 bf fc ff ff       	jmp    2c3b <mpt_send_target_data+0x24b>
dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
		       int nelems, enum dma_data_direction dir)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
    2f7c:	0f 0b                	ud2    
    2f7e:	e8 0f 00 00 00       	call   2f92 <mpt_send_target_data+0x5a2>
	int i, ents;
	struct scatterlist *s;

	for_each_sg(sg, s, nents, i)
		kmemcheck_mark_initialized(sg_virt(s), s->length);
	BUG_ON(!valid_dma_direction(dir));
    2f83:	0f 0b                	ud2    
	unsigned int bufflen = prm->bufflen;
	int i;

	TRACE_ENTRY();
	TRACE_DBG("bufflen %d, %p", bufflen, prm->buffer);
	sBUG_ON(prm->use_sg == 0);
    2f85:	c7 44 24 0c f9 00 00 	movl   $0xf9,0xc(%esp)
    2f8c:	00 
    2f8d:	c7 44 24 08 76 04 00 	movl   $0x476,0x8(%esp)
    2f94:	00 
    2f95:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
    2f9c:	00 
    2f9d:	c7 04 24 b3 00 00 00 	movl   $0xb3,(%esp)
    2fa4:	e8 fc ff ff ff       	call   2fa5 <mpt_send_target_data+0x5b5>
	PVOP_VCALLEE0(pv_irq_ops.irq_disable);
}

static inline notrace void arch_local_irq_enable(void)
{
	PVOP_VCALLEE0(pv_irq_ops.irq_enable);
    2fa9:	ff 15 0c 00 00 00    	call   *0xc
    2faf:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
    2fb5:	f6 c4 ff             	test   $0xff,%ah
    2fb8:	74 1a                	je     2fd4 <mpt_send_target_data+0x5e4>
    2fba:	b8 ba 2f 00 00       	mov    $0x2fba,%eax
    2fbf:	ba 00 02 00 00       	mov    $0x200,%edx
    2fc4:	e8 fc ff ff ff       	call   2fc5 <mpt_send_target_data+0x5d5>
    2fc9:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
    2fcf:	f6 c4 ff             	test   $0xff,%ah
    2fd2:	75 e6                	jne    2fba <mpt_send_target_data+0x5ca>
    2fd4:	0f 0b                	ud2    
    2fd6:	e8 11 00 00 00       	call   2fec <stmapp_tgt_command+0xc>
    2fdb:	90                   	nop
    2fdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00002fe0 <stmapp_tgt_command>:

	return task_mgmt;
}

static void stmapp_tgt_command(MPT_STM_PRIV *priv, u32 reply_word)
{
    2fe0:	55                   	push   %ebp
    2fe1:	89 e5                	mov    %esp,%ebp
    2fe3:	57                   	push   %edi
    2fe4:	56                   	push   %esi
    2fe5:	53                   	push   %ebx
    2fe6:	83 ec 70             	sub    $0x70,%esp
    2fe9:	e8 fc ff ff ff       	call   2fea <stmapp_tgt_command+0xa>
    2fee:	89 c3                	mov    %eax,%ebx
    2ff0:	89 d0                	mov    %edx,%eax
    2ff2:	89 55 ac             	mov    %edx,-0x54(%ebp)
	TRACE_ENTRY();

	index = GET_IO_INDEX(reply_word);
	cmd = &priv->hw->cmd_buf[index];

	if (IsScsi(priv)) {
    2ff5:	8b 13                	mov    (%ebx),%edx
	CMD *cmd;
	/*struct mpt_tgt *tgt = priv->tgt;*/

	TRACE_ENTRY();

	index = GET_IO_INDEX(reply_word);
    2ff7:	25 ff 3f 00 00       	and    $0x3fff,%eax
	int init_index, res = 0, task_mgmt, lun;
	char *init_str = NULL;

	TRACE_ENTRY();

	tgt = priv->tgt;
    2ffc:	8b 8b 0c 0c 00 00    	mov    0xc0c(%ebx),%ecx
	/*struct mpt_tgt *tgt = priv->tgt;*/

	TRACE_ENTRY();

	index = GET_IO_INDEX(reply_word);
	cmd = &priv->hw->cmd_buf[index];
    3002:	69 c0 f0 03 00 00    	imul   $0x3f0,%eax,%eax
    3008:	03 43 20             	add    0x20(%ebx),%eax

	if (IsScsi(priv)) {
    300b:	0f b6 92 69 03 00 00 	movzbl 0x369(%edx),%edx
	int init_index, res = 0, task_mgmt, lun;
	char *init_str = NULL;

	TRACE_ENTRY();

	tgt = priv->tgt;
    3012:	89 4d b0             	mov    %ecx,-0x50(%ebp)
	TRACE_ENTRY();

	index = GET_IO_INDEX(reply_word);
	cmd = &priv->hw->cmd_buf[index];

	if (IsScsi(priv)) {
    3015:	80 fa 01             	cmp    $0x1,%dl
    3018:	0f 84 f2 01 00 00    	je     3210 <stmapp_tgt_command+0x230>
		SCSI_CMD *scsi_cmd = (SCSI_CMD *)cmd->cmd;
		task_mgmt = scsi_cmd->TaskManagementFlags;
		*lun = get2bytes(scsi_cmd->LogicalUnitNumber, 0);
	} else if (IsSas(priv)) {
    301e:	80 fa 30             	cmp    $0x30,%dl
    3021:	0f 84 01 02 00 00    	je     3228 <stmapp_tgt_command+0x248>
		}
		*lun = get2bytes(ssp_cmd->LogicalUnitNumber, 0);
	} else {
		FCP_CMD *fcp_cmd = (FCP_CMD *)cmd->cmd;
		task_mgmt = fcp_cmd->FcpCntl[2];
		*lun = get2bytes(fcp_cmd->FcpLun, 0);
    3027:	0f b6 10             	movzbl (%eax),%edx
			task_mgmt = ssp_task->TaskManagementFunction;
		}
		*lun = get2bytes(ssp_cmd->LogicalUnitNumber, 0);
	} else {
		FCP_CMD *fcp_cmd = (FCP_CMD *)cmd->cmd;
		task_mgmt = fcp_cmd->FcpCntl[2];
    302a:	0f b6 70 0a          	movzbl 0xa(%eax),%esi
		*lun = get2bytes(fcp_cmd->FcpLun, 0);
    302e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    3032:	c1 e2 08             	shl    $0x8,%edx
    3035:	01 c2                	add    %eax,%edx
	TRACE_ENTRY();

	tgt = priv->tgt;

	task_mgmt = mpt_is_task_mgm(priv, reply_word, &lun);
	if (task_mgmt)
    3037:	85 f6                	test   %esi,%esi
    3039:	75 25                	jne    3060 <stmapp_tgt_command+0x80>
    303b:	8b 75 ac             	mov    -0x54(%ebp),%esi
    303e:	81 e6 00 c0 ff 03    	and    $0x3ffc000,%esi
    3044:	c1 ee 0e             	shr    $0xe,%esi
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    3047:	8b 45 b0             	mov    -0x50(%ebp),%eax
    304a:	8b 40 10             	mov    0x10(%eax),%eax
		mpt_handle_task_mgmt(priv, reply_word, task_mgmt, lun);

	init_index = GET_INITIATOR_INDEX(reply_word);

	if (test_bit(MPT_TGT_SHUTDOWN, &tgt->tgt_flags)) {
    304d:	a8 01                	test   $0x1,%al
    304f:	74 77                	je     30c8 <stmapp_tgt_command+0xe8>
	/* go through */
out_free_cmd:
	TRACE_MEM("kfree for cmd %p", cmd);
	kfree(cmd);
	goto out;
}
    3051:	83 c4 70             	add    $0x70,%esp
    3054:	5b                   	pop    %ebx
    3055:	5e                   	pop    %esi
    3056:	5f                   	pop    %edi
    3057:	5d                   	pop    %ebp
    3058:	c3                   	ret    
    3059:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	TRACE_ENTRY();

	TRACE_DBG("task_mgmt %d", task_mgmt);
	tgt = priv->tgt;
	init_index = GET_INITIATOR_INDEX(reply_word);
    3060:	8b 45 ac             	mov    -0x54(%ebp),%eax
	int res = 0, rc = 0;
	struct mpt_mgmt_cmd *mcmd;
	struct mpt_tgt *tgt;
	struct mpt_sess *sess;
	int init_index;
	uint16_t lun = _lun;
    3063:	66 89 55 b4          	mov    %dx,-0x4c(%ebp)

	TRACE_ENTRY();

	TRACE_DBG("task_mgmt %d", task_mgmt);
	tgt = priv->tgt;
	init_index = GET_INITIATOR_INDEX(reply_word);
    3067:	25 00 c0 ff 03       	and    $0x3ffc000,%eax
    306c:	89 45 a8             	mov    %eax,-0x58(%ebp)

	sess = tgt->sess[init_index];
    306f:	8b 45 b0             	mov    -0x50(%ebp),%eax

	TRACE_ENTRY();

	TRACE_DBG("task_mgmt %d", task_mgmt);
	tgt = priv->tgt;
	init_index = GET_INITIATOR_INDEX(reply_word);
    3072:	c1 6d a8 0e          	shrl   $0xe,-0x58(%ebp)

	sess = tgt->sess[init_index];
    3076:	8b 4d a8             	mov    -0x58(%ebp),%ecx
    3079:	8b 7c 88 24          	mov    0x24(%eax,%ecx,4),%edi
	if (sess == NULL) {
    307d:	85 ff                	test   %edi,%edi
    307f:	0f 84 83 01 00 00    	je     3208 <stmapp_tgt_command+0x228>
    3085:	8b 47 0c             	mov    0xc(%edi),%eax
		      "unexisting session", priv->ioc->name, tgt);
		res = -EFAULT;
		goto out;
	}

	if (test_bit(MPT_SESS_INITING, &sess->sess_flags)) {
    3088:	a8 01                	test   $0x1,%al
    308a:	0f 85 e8 04 00 00    	jne    3578 <stmapp_tgt_command+0x598>
    3090:	a1 14 00 00 00       	mov    0x14,%eax
    3095:	b9 08 00 00 00       	mov    $0x8,%ecx
    309a:	ba 20 00 00 00       	mov    $0x20,%edx
    309f:	e8 fc ff ff ff       	call   30a0 <stmapp_tgt_command+0xc0>
	}

	mcmd = kmalloc(sizeof(*mcmd), GFP_ATOMIC);
	TRACE_MEM("kmalloc(GFP_ATOMIC) for mcmd (%zd): %p",
		  sizeof(*mcmd), mcmd);
	if (mcmd == NULL) {
    30a4:	85 c0                	test   %eax,%eax
    30a6:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    30a9:	0f 84 b9 01 00 00    	je     3268 <stmapp_tgt_command+0x288>
		res = -ENOMEM;
		goto out;
	}

	memset(mcmd, 0, sizeof(*mcmd));
	mcmd->sess = sess;
    30af:	8b 45 a4             	mov    -0x5c(%ebp),%eax
	mcmd->task_mgmt = task_mgmt;

	switch (task_mgmt) {
    30b2:	83 fe 40             	cmp    $0x40,%esi
		res = -ENOMEM;
		goto out;
	}

	memset(mcmd, 0, sizeof(*mcmd));
	mcmd->sess = sess;
    30b5:	89 38                	mov    %edi,(%eax)
	mcmd->task_mgmt = task_mgmt;
    30b7:	89 70 04             	mov    %esi,0x4(%eax)

	switch (task_mgmt) {
    30ba:	0f 87 70 04 00 00    	ja     3530 <stmapp_tgt_command+0x550>
    30c0:	ff 24 b5 50 00 00 00 	jmp    *0x50(,%esi,4)
    30c7:	90                   	nop
    30c8:	a1 18 00 00 00       	mov    0x18,%eax
    30cd:	b9 28 00 00 00       	mov    $0x28,%ecx
    30d2:	ba 20 00 00 00       	mov    $0x20,%edx
    30d7:	e8 fc ff ff ff       	call   30d8 <stmapp_tgt_command+0xf8>
		goto out;
	}

	cmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);
	TRACE_MEM("kmalloc(GFP_ATOMIC) for cmd (%zd): %p", sizeof(*cmd), cmd);
	if (cmd == NULL) {
    30dc:	85 c0                	test   %eax,%eax
    30de:	89 45 a8             	mov    %eax,-0x58(%ebp)
    30e1:	0f 84 d9 01 00 00    	je     32c0 <stmapp_tgt_command+0x2e0>
		TRACE(TRACE_OUT_OF_MEM, "%s", "Allocation of cmd failed");
		res = -ENOMEM;
		goto out;
	}

	memset(cmd, 0, sizeof(*cmd));
    30e7:	8b 45 a8             	mov    -0x58(%ebp),%eax
    30ea:	ba 28 00 00 00       	mov    $0x28,%edx
    30ef:	a8 01                	test   $0x1,%al
    30f1:	89 c7                	mov    %eax,%edi
    30f3:	0f 85 d7 02 00 00    	jne    33d0 <stmapp_tgt_command+0x3f0>
    30f9:	f7 c7 02 00 00 00    	test   $0x2,%edi
    30ff:	0f 85 db 02 00 00    	jne    33e0 <stmapp_tgt_command+0x400>
    3105:	89 d1                	mov    %edx,%ecx
    3107:	31 c0                	xor    %eax,%eax
    3109:	c1 e9 02             	shr    $0x2,%ecx
    310c:	f6 c2 02             	test   $0x2,%dl
    310f:	f3 ab                	rep stos %eax,%es:(%edi)
    3111:	0f 85 39 01 00 00    	jne    3250 <stmapp_tgt_command+0x270>
    3117:	83 e2 01             	and    $0x1,%edx
    311a:	0f 85 28 01 00 00    	jne    3248 <stmapp_tgt_command+0x268>
	cmd->priv = priv;
    3120:	8b 45 a8             	mov    -0x58(%ebp),%eax
	cmd->reply_word = reply_word;
    3123:	8b 7d ac             	mov    -0x54(%ebp),%edi
		res = -ENOMEM;
		goto out;
	}

	memset(cmd, 0, sizeof(*cmd));
	cmd->priv = priv;
    3126:	89 58 08             	mov    %ebx,0x8(%eax)
	cmd->reply_word = reply_word;
    3129:	89 78 10             	mov    %edi,0x10(%eax)
	cmd->state = MPT_STATE_NEW;
    312c:	c7 40 1c 01 00 00 00 	movl   $0x1,0x1c(%eax)
    3133:	8b 45 b0             	mov    -0x50(%ebp),%eax
    3136:	8d 3c b0             	lea    (%eax,%esi,4),%edi

	sess = tgt->sess[init_index];
    3139:	8b 57 24             	mov    0x24(%edi),%edx
	if (sess == NULL) {
    313c:	85 d2                	test   %edx,%edx
    313e:	0f 84 ec 02 00 00    	je     3430 <stmapp_tgt_command+0x450>
		list_add_tail(&cmd->delayed_cmds_entry, &sess->delayed_cmds);
		goto out;
	}

	/* session is ready let us do it */
	cmd->sess = sess;
    3144:	8b 7d a8             	mov    -0x58(%ebp),%edi
    3147:	89 17                	mov    %edx,(%edi)
    3149:	8b 42 0c             	mov    0xc(%edx),%eax
	if (test_bit(MPT_SESS_INITING, &sess->sess_flags)) {
    314c:	83 e0 01             	and    $0x1,%eax
    314f:	0f 84 b3 01 00 00    	je     3308 <stmapp_tgt_command+0x328>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3155:	8b 42 14             	mov    0x14(%edx),%eax
		list_add_tail(&cmd->delayed_cmds_entry, &sess->delayed_cmds);
    3158:	8d 4f 14             	lea    0x14(%edi),%ecx
    315b:	83 c2 10             	add    $0x10,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    315e:	89 4a 04             	mov    %ecx,0x4(%edx)
    3161:	89 57 14             	mov    %edx,0x14(%edi)
	new->next = next;
	new->prev = prev;
    3164:	89 47 18             	mov    %eax,0x18(%edi)
	prev->next = new;
    3167:	89 08                	mov    %ecx,(%eax)
	/* go through */
out_free_cmd:
	TRACE_MEM("kfree for cmd %p", cmd);
	kfree(cmd);
	goto out;
}
    3169:	83 c4 70             	add    $0x70,%esp
    316c:	5b                   	pop    %ebx
    316d:	5e                   	pop    %esi
    316e:	5f                   	pop    %edi
    316f:	5d                   	pop    %ebp
    3170:	c3                   	ret    
    3171:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	const struct scst_rx_mgmt_params *params);

static inline void scst_rx_mgmt_params_init(
		struct scst_rx_mgmt_params *params)
{
	memset(params, 0, sizeof(*params));
    3178:	8d 55 cc             	lea    -0x34(%ebp),%edx
	mcmd->task_mgmt = task_mgmt;

	switch (task_mgmt) {
	case IMM_NTFY_CLEAR_ACA:
		TRACE(TRACE_MGMT, "%s", "IMM_NTFY_CLEAR_ACA received");
		rc = scst_rx_mgmt_fn_lun(sess->scst_sess, SCST_CLEAR_ACA,
    317b:	8b 37                	mov    (%edi),%esi
    317d:	b9 09 00 00 00       	mov    $0x9,%ecx
    3182:	31 c0                	xor    %eax,%eax
    3184:	89 d7                	mov    %edx,%edi
    3186:	f3 ab                	rep stos %eax,%es:(%edi)

	BUG_ON(fn == SCST_ABORT_TASK);

	scst_rx_mgmt_params_init(&params);

	params.fn = fn;
    3188:	c7 45 cc 02 00 00 00 	movl   $0x2,-0x34(%ebp)
	params.lun = lun;
    318f:	8d 45 b4             	lea    -0x4c(%ebp),%eax
    3192:	89 45 d8             	mov    %eax,-0x28(%ebp)
	params.lun_len = lun_len;
	params.lun_set = !!lun;
	params.atomic = atomic;
	params.tgt_priv = tgt_priv;
    3195:	8b 45 a4             	mov    -0x5c(%ebp),%eax

	scst_rx_mgmt_params_init(&params);

	params.fn = fn;
	params.lun = lun;
	params.lun_len = lun_len;
    3198:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
	params.lun_set = !!lun;
    319f:	c6 45 ed 01          	movb   $0x1,-0x13(%ebp)
	params.atomic = atomic;
    31a3:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
	params.tgt_priv = tgt_priv;
    31aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return scst_rx_mgmt_fn(sess, &params);
    31ad:	89 f0                	mov    %esi,%eax
    31af:	e8 fc ff ff ff       	call   31b0 <stmapp_tgt_command+0x1d0>
	default:
		PRINT_ERROR("mpt_scst(%s): Unknown task mgmt fn 0x%x",
			    priv->ioc->name, task_mgmt);
		break;
	}
	if (rc != 0) {
    31b4:	85 c0                	test   %eax,%eax
    31b6:	74 50                	je     3208 <stmapp_tgt_command+0x228>
		PRINT_ERROR("mpt_scst(%s): scst_rx_mgmt_fn_lun() failed: %d",
    31b8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    31bc:	8b 03                	mov    (%ebx),%eax
    31be:	c7 44 24 14 28 07 00 	movl   $0x728,0x14(%esp)
    31c5:	00 
    31c6:	c7 44 24 10 bb 07 00 	movl   $0x7bb,0x10(%esp)
    31cd:	00 
    31ce:	c7 44 24 0c f5 02 00 	movl   $0x2f5,0xc(%esp)
    31d5:	00 
    31d6:	83 c0 08             	add    $0x8,%eax
    31d9:	89 44 24 18          	mov    %eax,0x18(%esp)
    31dd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    31e4:	00 
    31e5:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
    31ec:	00 
    31ed:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
    31f4:	e8 fc ff ff ff       	call   31f5 <stmapp_tgt_command+0x215>
	TRACE_EXIT_RES(res);
	return res;

out_free:
	TRACE_MEM("kmem_cache_free for mcmd %p", mcmd);
	kfree(mcmd);
    31f9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    31fc:	e8 fc ff ff ff       	call   31fd <stmapp_tgt_command+0x21d>
    3201:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    3208:	8b 75 a8             	mov    -0x58(%ebp),%esi
    320b:	e9 37 fe ff ff       	jmp    3047 <stmapp_tgt_command+0x67>
	cmd = &priv->hw->cmd_buf[index];

	if (IsScsi(priv)) {
		SCSI_CMD *scsi_cmd = (SCSI_CMD *)cmd->cmd;
		task_mgmt = scsi_cmd->TaskManagementFlags;
		*lun = get2bytes(scsi_cmd->LogicalUnitNumber, 0);
    3210:	0f b6 50 04          	movzbl 0x4(%eax),%edx
	index = GET_IO_INDEX(reply_word);
	cmd = &priv->hw->cmd_buf[index];

	if (IsScsi(priv)) {
		SCSI_CMD *scsi_cmd = (SCSI_CMD *)cmd->cmd;
		task_mgmt = scsi_cmd->TaskManagementFlags;
    3214:	0f b6 70 12          	movzbl 0x12(%eax),%esi
		*lun = get2bytes(scsi_cmd->LogicalUnitNumber, 0);
    3218:	0f b6 40 05          	movzbl 0x5(%eax),%eax
    321c:	c1 e2 08             	shl    $0x8,%edx
    321f:	01 c2                	add    %eax,%edx
    3221:	e9 11 fe ff ff       	jmp    3037 <stmapp_tgt_command+0x57>
    3226:	66 90                	xchg   %ax,%ax
	TRACE_EXIT();
}

static int mpt_is_task_mgm(MPT_STM_PRIV *priv, u32 reply_word, int *lun)
{
	int task_mgmt = 0, index;
    3228:	31 f6                	xor    %esi,%esi
		SCSI_CMD *scsi_cmd = (SCSI_CMD *)cmd->cmd;
		task_mgmt = scsi_cmd->TaskManagementFlags;
		*lun = get2bytes(scsi_cmd->LogicalUnitNumber, 0);
	} else if (IsSas(priv)) {
		SSP_CMD *ssp_cmd = (SSP_CMD *)cmd->cmd;
		if (ssp_cmd->FrameType == SSP_TASK_FRAME) {
    322a:	80 38 16             	cmpb   $0x16,(%eax)
    322d:	0f 84 7d 00 00 00    	je     32b0 <stmapp_tgt_command+0x2d0>
			SSP_TASK *ssp_task = (SSP_TASK *)cmd->cmd;
			task_mgmt = ssp_task->TaskManagementFunction;
		}
		*lun = get2bytes(ssp_cmd->LogicalUnitNumber, 0);
    3233:	0f b6 50 08          	movzbl 0x8(%eax),%edx
    3237:	0f b6 40 09          	movzbl 0x9(%eax),%eax
    323b:	c1 e2 08             	shl    $0x8,%edx
    323e:	01 c2                	add    %eax,%edx
    3240:	e9 f2 fd ff ff       	jmp    3037 <stmapp_tgt_command+0x57>
    3245:	8d 76 00             	lea    0x0(%esi),%esi
		TRACE(TRACE_OUT_OF_MEM, "%s", "Allocation of cmd failed");
		res = -ENOMEM;
		goto out;
	}

	memset(cmd, 0, sizeof(*cmd));
    3248:	c6 07 00             	movb   $0x0,(%edi)
    324b:	e9 d0 fe ff ff       	jmp    3120 <stmapp_tgt_command+0x140>
    3250:	31 c0                	xor    %eax,%eax
    3252:	83 c7 02             	add    $0x2,%edi
    3255:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    3259:	83 e2 01             	and    $0x1,%edx
    325c:	0f 84 be fe ff ff    	je     3120 <stmapp_tgt_command+0x140>
    3262:	eb e4                	jmp    3248 <stmapp_tgt_command+0x268>
    3264:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	mcmd = kmalloc(sizeof(*mcmd), GFP_ATOMIC);
	TRACE_MEM("kmalloc(GFP_ATOMIC) for mcmd (%zd): %p",
		  sizeof(*mcmd), mcmd);
	if (mcmd == NULL) {
		TRACE(TRACE_OUT_OF_MEM, "%s", "Allocation of mgmt cmd failed");
    3268:	c7 44 24 18 0a 01 00 	movl   $0x10a,0x18(%esp)
    326f:	00 
    3270:	c7 44 24 14 e1 00 00 	movl   $0xe1,0x14(%esp)
    3277:	00 
    3278:	c7 44 24 10 8d 07 00 	movl   $0x78d,0x10(%esp)
    327f:	00 
    3280:	c7 44 24 0c f5 02 00 	movl   $0x2f5,0xc(%esp)
    3287:	00 
    3288:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    328f:	00 
    3290:	c7 44 24 04 a5 00 00 	movl   $0xa5,0x4(%esp)
    3297:	00 
    3298:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
    329f:	e8 fc ff ff ff       	call   32a0 <stmapp_tgt_command+0x2c0>
    32a4:	e9 5f ff ff ff       	jmp    3208 <stmapp_tgt_command+0x228>
    32a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		*lun = get2bytes(scsi_cmd->LogicalUnitNumber, 0);
	} else if (IsSas(priv)) {
		SSP_CMD *ssp_cmd = (SSP_CMD *)cmd->cmd;
		if (ssp_cmd->FrameType == SSP_TASK_FRAME) {
			SSP_TASK *ssp_task = (SSP_TASK *)cmd->cmd;
			task_mgmt = ssp_task->TaskManagementFunction;
    32b0:	0f b6 70 12          	movzbl 0x12(%eax),%esi
    32b4:	e9 7a ff ff ff       	jmp    3233 <stmapp_tgt_command+0x253>
    32b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

	cmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);
	TRACE_MEM("kmalloc(GFP_ATOMIC) for cmd (%zd): %p", sizeof(*cmd), cmd);
	if (cmd == NULL) {
		TRACE(TRACE_OUT_OF_MEM, "%s", "Allocation of cmd failed");
    32c0:	c7 44 24 18 28 01 00 	movl   $0x128,0x18(%esp)
    32c7:	00 
    32c8:	c7 44 24 14 e1 00 00 	movl   $0xe1,0x14(%esp)
    32cf:	00 
    32d0:	c7 44 24 10 da 03 00 	movl   $0x3da,0x10(%esp)
    32d7:	00 
    32d8:	c7 44 24 0c 21 03 00 	movl   $0x321,0xc(%esp)
    32df:	00 
    32e0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    32e7:	00 
    32e8:	c7 44 24 04 a5 00 00 	movl   $0xa5,0x4(%esp)
    32ef:	00 
    32f0:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
    32f7:	e8 fc ff ff ff       	call   32f8 <stmapp_tgt_command+0x318>
    32fc:	e9 50 fd ff ff       	jmp    3051 <stmapp_tgt_command+0x71>
    3301:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	int init_index = 0;
	int flags = 0;
	SCSI_CMD *scsi_cmd = NULL;
	CMD *cmd;
	u8 *cdb;
	struct mpt_prm prm = { NULL };
    3308:	b9 0a 00 00 00       	mov    $0xa,%ecx
    330d:	8d 7d cc             	lea    -0x34(%ebp),%edi
    3310:	f3 ab                	rep stos %eax,%es:(%edi)
	struct scst_cmd *scst_cmd;
	struct scatterlist sg;

	TRACE_ENTRY();

	priv = mpt_cmd->priv;
    3312:	8b 45 a8             	mov    -0x58(%ebp),%eax
    3315:	8b 58 08             	mov    0x8(%eax),%ebx
	if (IsScsi(priv)) {
    3318:	8b 03                	mov    (%ebx),%eax
    331a:	80 b8 69 03 00 00 01 	cmpb   $0x1,0x369(%eax)
    3321:	0f 84 d1 00 00 00    	je     33f8 <stmapp_tgt_command+0x418>
	} else {
		/* if there is pending sense left over from the last command,
		 * we need to send that if this is a REQUEST SENSE command.
		 * Otherwise send the command to SCST */
		if (!stmapp_pending_sense(cmd)) {
			res = mpt_send_cmd_to_scst(cmd, SCST_CONTEXT_TASKLET);
    3327:	8b 45 a8             	mov    -0x58(%ebp),%eax
    332a:	ba 02 00 00 00       	mov    $0x2,%edx
    332f:	e8 9c d0 ff ff       	call   3d0 <mpt_send_cmd_to_scst>
			/*res = mpt_send_cmd_to_scst(cmd, SCST_CONTEXT_DIRECT_ATOMIC);*/
			if (res != 0)
    3334:	85 c0                	test   %eax,%eax
    3336:	0f 84 15 fd ff ff    	je     3051 <stmapp_tgt_command+0x71>
	if (atomic_dec_and_test(&tgt->sess_count))
		wake_up_all(&tgt->waitQ);
	/* go through */
out_free_cmd:
	TRACE_MEM("kfree for cmd %p", cmd);
	kfree(cmd);
    333c:	8b 45 a8             	mov    -0x58(%ebp),%eax
    333f:	e8 fc ff ff ff       	call   3340 <stmapp_tgt_command+0x360>
	goto out;
    3344:	e9 08 fd ff ff       	jmp    3051 <stmapp_tgt_command+0x71>
    3349:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	const struct scst_rx_mgmt_params *params);

static inline void scst_rx_mgmt_params_init(
		struct scst_rx_mgmt_params *params)
{
	memset(params, 0, sizeof(*params));
    3350:	8d 55 cc             	lea    -0x34(%ebp),%edx
		rc = scst_rx_mgmt_fn_lun(sess->scst_sess, SCST_CLEAR_ACA,
					 &lun, sizeof(lun), SCST_ATOMIC, mcmd);
		break;
	case IMM_NTFY_TARGET_RESET:
		TRACE(TRACE_MGMT, "%s", "IMM_NTFY_TARGET_RESET received");
		rc = scst_rx_mgmt_fn_lun(sess->scst_sess, SCST_TARGET_RESET,
    3353:	8b 37                	mov    (%edi),%esi
    3355:	b9 09 00 00 00       	mov    $0x9,%ecx
    335a:	31 c0                	xor    %eax,%eax
    335c:	89 d7                	mov    %edx,%edi
    335e:	f3 ab                	rep stos %eax,%es:(%edi)

	BUG_ON(fn == SCST_ABORT_TASK);

	scst_rx_mgmt_params_init(&params);

	params.fn = fn;
    3360:	c7 45 cc 05 00 00 00 	movl   $0x5,-0x34(%ebp)
    3367:	e9 23 fe ff ff       	jmp    318f <stmapp_tgt_command+0x1af>
    336c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	const struct scst_rx_mgmt_params *params);

static inline void scst_rx_mgmt_params_init(
		struct scst_rx_mgmt_params *params)
{
	memset(params, 0, sizeof(*params));
    3370:	8d 55 cc             	lea    -0x34(%ebp),%edx
					 &lun, sizeof(lun), SCST_ATOMIC, mcmd);
		break;
	case IMM_NTFY_LUN_RESET1:
	case IMM_NTFY_LUN_RESET2:
		TRACE(TRACE_MGMT, "%s", "IMM_NTFY_LUN_RESET received");
		rc = scst_rx_mgmt_fn_lun(sess->scst_sess, SCST_LUN_RESET,
    3373:	8b 37                	mov    (%edi),%esi
    3375:	b9 09 00 00 00       	mov    $0x9,%ecx
    337a:	31 c0                	xor    %eax,%eax
    337c:	89 d7                	mov    %edx,%edi
    337e:	f3 ab                	rep stos %eax,%es:(%edi)

	BUG_ON(fn == SCST_ABORT_TASK);

	scst_rx_mgmt_params_init(&params);

	params.fn = fn;
    3380:	c7 45 cc 04 00 00 00 	movl   $0x4,-0x34(%ebp)
    3387:	e9 03 fe ff ff       	jmp    318f <stmapp_tgt_command+0x1af>
    338c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	const struct scst_rx_mgmt_params *params);

static inline void scst_rx_mgmt_params_init(
		struct scst_rx_mgmt_params *params)
{
	memset(params, 0, sizeof(*params));
    3390:	8d 55 cc             	lea    -0x34(%ebp),%edx
					 &lun, sizeof(lun), SCST_ATOMIC, mcmd);
		break;
	case IMM_NTFY_CLEAR_TS:
		TRACE(TRACE_MGMT, "%s", "IMM_NTFY_CLEAR_TS received");
		rc = scst_rx_mgmt_fn_lun(sess->scst_sess, SCST_CLEAR_TASK_SET,
    3393:	8b 37                	mov    (%edi),%esi
    3395:	b9 09 00 00 00       	mov    $0x9,%ecx
    339a:	31 c0                	xor    %eax,%eax
    339c:	89 d7                	mov    %edx,%edi
    339e:	f3 ab                	rep stos %eax,%es:(%edi)

	BUG_ON(fn == SCST_ABORT_TASK);

	scst_rx_mgmt_params_init(&params);

	params.fn = fn;
    33a0:	c7 45 cc 03 00 00 00 	movl   $0x3,-0x34(%ebp)
    33a7:	e9 e3 fd ff ff       	jmp    318f <stmapp_tgt_command+0x1af>
    33ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	const struct scst_rx_mgmt_params *params);

static inline void scst_rx_mgmt_params_init(
		struct scst_rx_mgmt_params *params)
{
	memset(params, 0, sizeof(*params));
    33b0:	8d 55 cc             	lea    -0x34(%ebp),%edx
		break;

	case IMM_NTFY_ABORT_TS1:
	case IMM_NTFY_ABORT_TS2:
		TRACE(TRACE_MGMT, "%s", "IMM_NTFY_ABORT_TS received");
		rc = scst_rx_mgmt_fn_lun(sess->scst_sess, SCST_ABORT_TASK_SET,
    33b3:	8b 37                	mov    (%edi),%esi
    33b5:	b9 09 00 00 00       	mov    $0x9,%ecx
    33ba:	31 c0                	xor    %eax,%eax
    33bc:	89 d7                	mov    %edx,%edi
    33be:	f3 ab                	rep stos %eax,%es:(%edi)

	BUG_ON(fn == SCST_ABORT_TASK);

	scst_rx_mgmt_params_init(&params);

	params.fn = fn;
    33c0:	c7 45 cc 01 00 00 00 	movl   $0x1,-0x34(%ebp)
    33c7:	e9 c3 fd ff ff       	jmp    318f <stmapp_tgt_command+0x1af>
    33cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		TRACE(TRACE_OUT_OF_MEM, "%s", "Allocation of cmd failed");
		res = -ENOMEM;
		goto out;
	}

	memset(cmd, 0, sizeof(*cmd));
    33d0:	c6 00 00             	movb   $0x0,(%eax)
    33d3:	8d 78 01             	lea    0x1(%eax),%edi
    33d6:	b2 27                	mov    $0x27,%dl
    33d8:	e9 1c fd ff ff       	jmp    30f9 <stmapp_tgt_command+0x119>
    33dd:	8d 76 00             	lea    0x0(%esi),%esi
    33e0:	31 c9                	xor    %ecx,%ecx
    33e2:	83 c7 02             	add    $0x2,%edi
    33e5:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    33e9:	83 ea 02             	sub    $0x2,%edx
    33ec:	e9 14 fd ff ff       	jmp    3105 <stmapp_tgt_command+0x125>
    33f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	TRACE_ENTRY();

	priv = mpt_cmd->priv;
	if (IsScsi(priv)) {
		index = GET_IO_INDEX(mpt_cmd->reply_word);
    33f8:	8b 45 a8             	mov    -0x58(%ebp),%eax
    33fb:	8b 40 10             	mov    0x10(%eax),%eax
		init_index = GET_INITIATOR_INDEX(mpt_cmd->reply_word);
    33fe:	89 c1                	mov    %eax,%ecx
    3400:	81 e1 00 c0 ff 03    	and    $0x3ffc000,%ecx
    3406:	89 4d b0             	mov    %ecx,-0x50(%ebp)
    3409:	c1 6d b0 0e          	shrl   $0xe,-0x50(%ebp)
		if (atomic_read(&priv->pending_sense[init_index]) ==
    340d:	8b 4d b0             	mov    -0x50(%ebp),%ecx
    3410:	8d b4 8b 10 0e 00 00 	lea    0xe10(%ebx,%ecx,4),%esi
 *
 * Atomically reads the value of @v.
 */
static inline int atomic_read(const atomic_t *v)
{
	return (*(volatile int *)&(v)->counter);
    3417:	8b 16                	mov    (%esi),%edx
    3419:	83 fa 03             	cmp    $0x3,%edx
    341c:	0f 84 22 02 00 00    	je     3644 <stmapp_tgt_command+0x664>
 *
 * Atomically sets the value of @v to @i.
 */
static inline void atomic_set(atomic_t *v, int i)
{
	v->counter = i;
    3422:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    3428:	e9 fa fe ff ff       	jmp    3327 <stmapp_tgt_command+0x347>
    342d:	8d 76 00             	lea    0x0(%esi),%esi
    3430:	a1 14 00 00 00       	mov    0x14,%eax
    3435:	b9 18 00 00 00       	mov    $0x18,%ecx
    343a:	b2 20                	mov    $0x20,%dl
    343c:	e8 fc ff ff ff       	call   343d <stmapp_tgt_command+0x45d>

	sess = tgt->sess[init_index];
	if (sess == NULL) {
		/* Allocation of sess */
		sess = kmalloc(sizeof(*sess), GFP_ATOMIC);
		if (sess == NULL) {
    3441:	85 c0                	test   %eax,%eax
    3443:	89 45 ac             	mov    %eax,-0x54(%ebp)
    3446:	0f 84 f0 03 00 00    	je     383c <stmapp_tgt_command+0x85c>
			res = -ENOMEM;
			goto out_free_cmd;
		}

		/* indentify the Initiator */
		init_str = kasprintf(GFP_KERNEL,
    344c:	89 74 24 0c          	mov    %esi,0xc(%esp)
				    "%s->%02x",
				    priv->ioc->name, init_index);
    3450:	8b 03                	mov    (%ebx),%eax
			res = -ENOMEM;
			goto out_free_cmd;
		}

		/* indentify the Initiator */
		init_str = kasprintf(GFP_KERNEL,
    3452:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
    3459:	00 
    345a:	c7 04 24 d0 00 00 00 	movl   $0xd0,(%esp)
				    "%s->%02x",
				    priv->ioc->name, init_index);
    3461:	83 c0 08             	add    $0x8,%eax
			res = -ENOMEM;
			goto out_free_cmd;
		}

		/* indentify the Initiator */
		init_str = kasprintf(GFP_KERNEL,
    3464:	89 44 24 08          	mov    %eax,0x8(%esp)
    3468:	e8 fc ff ff ff       	call   3469 <stmapp_tgt_command+0x489>
				    "%s->%02x",
				    priv->ioc->name, init_index);
		if (init_str == NULL) {
    346d:	85 c0                	test   %eax,%eax
			res = -ENOMEM;
			goto out_free_cmd;
		}

		/* indentify the Initiator */
		init_str = kasprintf(GFP_KERNEL,
    346f:	89 c1                	mov    %eax,%ecx
				    "%s->%02x",
				    priv->ioc->name, init_index);
		if (init_str == NULL) {
    3471:	0f 84 06 04 00 00    	je     387d <stmapp_tgt_command+0x89d>
 *
 * Atomically increments @v by 1.
 */
static inline void atomic_inc(atomic_t *v)
{
	asm volatile(LOCK_PREFIX "incl %0"
    3477:	8b 45 b0             	mov    -0x50(%ebp),%eax
    347a:	f0 ff 40 14          	lock incl 0x14(%eax)
		}

		atomic_inc(&tgt->sess_count);
		smp_mb__after_atomic_inc();

		memset(sess, 0, sizeof(*sess));
    347e:	8b 45 ac             	mov    -0x54(%ebp),%eax
    3481:	bb 18 00 00 00       	mov    $0x18,%ebx
    3486:	a8 01                	test   $0x1,%al
    3488:	89 c2                	mov    %eax,%edx
    348a:	0f 85 72 04 00 00    	jne    3902 <stmapp_tgt_command+0x922>
    3490:	f6 c2 02             	test   $0x2,%dl
    3493:	0f 85 59 04 00 00    	jne    38f2 <stmapp_tgt_command+0x912>
    3499:	89 d8                	mov    %ebx,%eax
    349b:	83 e0 fc             	and    $0xfffffffc,%eax
    349e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    34a1:	31 c0                	xor    %eax,%eax
    34a3:	c7 04 02 00 00 00 00 	movl   $0x0,(%edx,%eax,1)
    34aa:	83 c0 04             	add    $0x4,%eax
    34ad:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
    34b0:	72 f1                	jb     34a3 <stmapp_tgt_command+0x4c3>
    34b2:	01 c2                	add    %eax,%edx
    34b4:	f6 c3 02             	test   $0x2,%bl
    34b7:	74 08                	je     34c1 <stmapp_tgt_command+0x4e1>
    34b9:	66 c7 02 00 00       	movw   $0x0,(%edx)
    34be:	83 c2 02             	add    $0x2,%edx
    34c1:	83 e3 01             	and    $0x1,%ebx
    34c4:	74 03                	je     34c9 <stmapp_tgt_command+0x4e9>
    34c6:	c6 02 00             	movb   $0x0,(%edx)
		sess->tgt = tgt;
    34c9:	8b 45 ac             	mov    -0x54(%ebp),%eax
		sess->init_index = init_index;
		INIT_LIST_HEAD(&sess->delayed_cmds);

		sess->scst_sess = scst_register_session(tgt->scst_tgt, 1,
    34cc:	ba 01 00 00 00       	mov    $0x1,%edx

		atomic_inc(&tgt->sess_count);
		smp_mb__after_atomic_inc();

		memset(sess, 0, sizeof(*sess));
		sess->tgt = tgt;
    34d1:	8b 5d b0             	mov    -0x50(%ebp),%ebx
		sess->init_index = init_index;
    34d4:	89 70 08             	mov    %esi,0x8(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    34d7:	89 c6                	mov    %eax,%esi

		atomic_inc(&tgt->sess_count);
		smp_mb__after_atomic_inc();

		memset(sess, 0, sizeof(*sess));
		sess->tgt = tgt;
    34d9:	89 58 04             	mov    %ebx,0x4(%eax)
		sess->init_index = init_index;
		INIT_LIST_HEAD(&sess->delayed_cmds);
    34dc:	8d 58 10             	lea    0x10(%eax),%ebx
    34df:	89 58 10             	mov    %ebx,0x10(%eax)
	list->prev = list;
    34e2:	89 58 14             	mov    %ebx,0x14(%eax)

		sess->scst_sess = scst_register_session(tgt->scst_tgt, 1,
    34e5:	89 44 24 04          	mov    %eax,0x4(%esp)
    34e9:	89 04 24             	mov    %eax,(%esp)
    34ec:	8b 45 b0             	mov    -0x50(%ebp),%eax
    34ef:	c7 44 24 08 a0 06 00 	movl   $0x6a0,0x8(%esp)
    34f6:	00 
    34f7:	8b 00                	mov    (%eax),%eax
    34f9:	e8 fc ff ff ff       	call   34fa <stmapp_tgt_command+0x51a>
							init_str, sess, sess,
							mpt_alloc_session_done);
		if (sess->scst_sess == NULL) {
    34fe:	85 c0                	test   %eax,%eax
		memset(sess, 0, sizeof(*sess));
		sess->tgt = tgt;
		sess->init_index = init_index;
		INIT_LIST_HEAD(&sess->delayed_cmds);

		sess->scst_sess = scst_register_session(tgt->scst_tgt, 1,
    3500:	89 06                	mov    %eax,(%esi)
							init_str, sess, sess,
							mpt_alloc_session_done);
		if (sess->scst_sess == NULL) {
    3502:	0f 84 07 04 00 00    	je     390f <stmapp_tgt_command+0x92f>
 * If it's called on the same region of memory simultaneously, the effect
 * may be that only one operation succeeds.
 */
static inline void __set_bit(long nr, volatile unsigned long *addr)
{
	asm volatile("bts %1,%0" : ADDR : "Ir" (nr) : "memory");
    3508:	8b 45 ac             	mov    -0x54(%ebp),%eax
    350b:	0f ba 68 0c 00       	btsl   $0x0,0xc(%eax)
			goto out_free_sess;
		}

		__set_bit(MPT_SESS_INITING, &sess->sess_flags);

		tgt->sess[init_index] = sess;
    3510:	89 47 24             	mov    %eax,0x24(%edi)

		cmd->sess = sess;
    3513:	8b 7d a8             	mov    -0x58(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3516:	89 c1                	mov    %eax,%ecx
    3518:	89 07                	mov    %eax,(%edi)
    351a:	8b 40 14             	mov    0x14(%eax),%eax
		list_add_tail(&cmd->delayed_cmds_entry, &sess->delayed_cmds);
    351d:	8d 57 14             	lea    0x14(%edi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    3520:	89 51 14             	mov    %edx,0x14(%ecx)
	new->next = next;
    3523:	89 5f 14             	mov    %ebx,0x14(%edi)
	new->prev = prev;
    3526:	89 47 18             	mov    %eax,0x18(%edi)
	prev->next = new;
    3529:	89 10                	mov    %edx,(%eax)
    352b:	e9 21 fb ff ff       	jmp    3051 <stmapp_tgt_command+0x71>
		rc = scst_rx_mgmt_fn_lun(sess->scst_sess, SCST_ABORT_TASK_SET,
					 &lun, sizeof(lun), SCST_ATOMIC, mcmd);
		break;

	default:
		PRINT_ERROR("mpt_scst(%s): Unknown task mgmt fn 0x%x",
    3530:	89 74 24 1c          	mov    %esi,0x1c(%esp)
    3534:	8b 03                	mov    (%ebx),%eax
    3536:	c7 44 24 14 f0 06 00 	movl   $0x6f0,0x14(%esp)
    353d:	00 
    353e:	c7 44 24 10 b6 07 00 	movl   $0x7b6,0x10(%esp)
    3545:	00 
    3546:	c7 44 24 0c f5 02 00 	movl   $0x2f5,0xc(%esp)
    354d:	00 
    354e:	83 c0 08             	add    $0x8,%eax
    3551:	89 44 24 18          	mov    %eax,0x18(%esp)
    3555:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    355c:	00 
    355d:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
    3564:	00 
    3565:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
    356c:	e8 fc ff ff ff       	call   356d <stmapp_tgt_command+0x58d>
    3571:	e9 92 fc ff ff       	jmp    3208 <stmapp_tgt_command+0x228>
    3576:	66 90                	xchg   %ax,%ax
    3578:	8b 45 ac             	mov    -0x54(%ebp),%eax
    357b:	8d 48 ff             	lea    -0x1(%eax),%ecx
    357e:	83 f9 1f             	cmp    $0x1f,%ecx
    3581:	0f 87 81 fc ff ff    	ja     3208 <stmapp_tgt_command+0x228>
    3587:	b8 01 00 00 00       	mov    $0x1,%eax
    358c:	d3 e0                	shl    %cl,%eax
    358e:	a9 8b 80 00 00       	test   $0x808b,%eax
    3593:	75 47                	jne    35dc <stmapp_tgt_command+0x5fc>
    3595:	85 c0                	test   %eax,%eax
    3597:	0f 89 6b fc ff ff    	jns    3208 <stmapp_tgt_command+0x228>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    359d:	8b 47 10             	mov    0x10(%edi),%eax
	struct mpt_cmd *cmd, *t;

	TRACE_ENTRY();
	switch (task_mgmt) {
	case IMM_NTFY_TARGET_RESET:
		while (!list_empty(&sess->delayed_cmds)) {
    35a0:	8d 77 10             	lea    0x10(%edi),%esi
    35a3:	39 f0                	cmp    %esi,%eax
    35a5:	0f 84 5d fc ff ff    	je     3208 <stmapp_tgt_command+0x228>
    35ab:	90                   	nop
    35ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    35b0:	8b 08                	mov    (%eax),%ecx
			cmd = list_entry(sess->delayed_cmds.next,
    35b2:	83 e8 14             	sub    $0x14,%eax
    35b5:	8b 50 18             	mov    0x18(%eax),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    35b8:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    35bb:	89 0a                	mov    %ecx,(%edx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    35bd:	c7 40 14 00 01 10 00 	movl   $0x100100,0x14(%eax)
	entry->prev = LIST_POISON2;
    35c4:	c7 40 18 00 02 20 00 	movl   $0x200200,0x18(%eax)
					 typeof(*cmd), delayed_cmds_entry);
			list_del(&cmd->delayed_cmds_entry);
			kfree(cmd);
    35cb:	e8 fc ff ff ff       	call   35cc <stmapp_tgt_command+0x5ec>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    35d0:	8b 47 10             	mov    0x10(%edi),%eax
	struct mpt_cmd *cmd, *t;

	TRACE_ENTRY();
	switch (task_mgmt) {
	case IMM_NTFY_TARGET_RESET:
		while (!list_empty(&sess->delayed_cmds)) {
    35d3:	39 f0                	cmp    %esi,%eax
    35d5:	75 d9                	jne    35b0 <stmapp_tgt_command+0x5d0>
    35d7:	e9 2c fc ff ff       	jmp    3208 <stmapp_tgt_command+0x228>
	case IMM_NTFY_LUN_RESET1:
	case IMM_NTFY_LUN_RESET2:
	case IMM_NTFY_CLEAR_TS:
	case IMM_NTFY_ABORT_TS1:
	case IMM_NTFY_ABORT_TS2:
		list_for_each_entry_safe(cmd, t, &sess->delayed_cmds,
    35dc:	8b 47 10             	mov    0x10(%edi),%eax
    35df:	83 c7 10             	add    $0x10,%edi
    35e2:	8b 10                	mov    (%eax),%edx
    35e4:	8d 48 ec             	lea    -0x14(%eax),%ecx
    35e7:	83 ea 14             	sub    $0x14,%edx
    35ea:	39 c7                	cmp    %eax,%edi
    35ec:	0f 84 16 fc ff ff    	je     3208 <stmapp_tgt_command+0x228>
    35f2:	89 5d a4             	mov    %ebx,-0x5c(%ebp)
    35f5:	89 c8                	mov    %ecx,%eax
    35f7:	89 d3                	mov    %edx,%ebx
    35f9:	eb 16                	jmp    3611 <stmapp_tgt_command+0x631>
    35fb:	90                   	nop
    35fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    3600:	8b 43 14             	mov    0x14(%ebx),%eax
    3603:	8d 50 ec             	lea    -0x14(%eax),%edx
    3606:	8d 43 14             	lea    0x14(%ebx),%eax
    3609:	39 c7                	cmp    %eax,%edi
    360b:	74 2f                	je     363c <stmapp_tgt_command+0x65c>
    360d:	89 d8                	mov    %ebx,%eax
    360f:	89 d3                	mov    %edx,%ebx
					 delayed_cmds_entry) {
			if (cmd->CMD->lun == lun) {
    3611:	8b 50 0c             	mov    0xc(%eax),%edx
    3614:	3b b2 e8 03 00 00    	cmp    0x3e8(%edx),%esi
    361a:	75 e4                	jne    3600 <stmapp_tgt_command+0x620>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    361c:	8b 48 14             	mov    0x14(%eax),%ecx
    361f:	8b 50 18             	mov    0x18(%eax),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    3622:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    3625:	89 0a                	mov    %ecx,(%edx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    3627:	c7 40 14 00 01 10 00 	movl   $0x100100,0x14(%eax)
	entry->prev = LIST_POISON2;
    362e:	c7 40 18 00 02 20 00 	movl   $0x200200,0x18(%eax)
				list_del(&cmd->delayed_cmds_entry);
				kfree(cmd);
    3635:	e8 fc ff ff ff       	call   3636 <stmapp_tgt_command+0x656>
    363a:	eb c4                	jmp    3600 <stmapp_tgt_command+0x620>
    363c:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
    363f:	e9 c4 fb ff ff       	jmp    3208 <stmapp_tgt_command+0x228>

	TRACE_ENTRY();

	priv = mpt_cmd->priv;
	if (IsScsi(priv)) {
		index = GET_IO_INDEX(mpt_cmd->reply_word);
    3644:	25 ff 3f 00 00       	and    $0x3fff,%eax
    3649:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		init_index = GET_INITIATOR_INDEX(mpt_cmd->reply_word);
		if (atomic_read(&priv->pending_sense[init_index]) ==
				MPT_STATUS_SENSE_HANDLE_RQ) {
			cmd = &priv->hw->cmd_buf[index];
    364c:	69 c0 f0 03 00 00    	imul   $0x3f0,%eax,%eax
    3652:	89 45 ac             	mov    %eax,-0x54(%ebp)
    3655:	8b 43 20             	mov    0x20(%ebx),%eax
    3658:	01 45 ac             	add    %eax,-0x54(%ebp)
			scsi_cmd = (SCSI_CMD *)cmd->cmd;
			cdb = scsi_cmd->CDB;

			if (cdb[0] == REQUEST_SENSE) {
    365b:	8b 45 ac             	mov    -0x54(%ebp),%eax
    365e:	80 78 14 03          	cmpb   $0x3,0x14(%eax)
    3662:	0f 85 ba fd ff ff    	jne    3422 <stmapp_tgt_command+0x442>
    3668:	a1 24 00 00 00       	mov    0x24,%eax
    366d:	b2 20                	mov    $0x20,%dl
    366f:	b9 9c 01 00 00       	mov    $0x19c,%ecx
    3674:	e8 fc ff ff ff       	call   3675 <stmapp_tgt_command+0x695>
				/* scst_cmd used as a container in stm_tgt_reply,
				 * command doesn't actually go to SCST */
				scst_cmd = kmalloc(sizeof(struct scst_cmd),
						GFP_ATOMIC);
				TRACE_DBG("scst_cmd 0x%p", scst_cmd);
				if (scst_cmd != NULL) {
    3679:	85 c0                	test   %eax,%eax
    367b:	89 c2                	mov    %eax,%edx
    367d:	0f 84 9f fd ff ff    	je     3422 <stmapp_tgt_command+0x442>
					cmd->reply_word = mpt_cmd->reply_word;
    3683:	8b 45 a8             	mov    -0x58(%ebp),%eax
    3686:	8b 7d ac             	mov    -0x54(%ebp),%edi
    3689:	8b 40 10             	mov    0x10(%eax),%eax
					if (cmd->reply_word &
    368c:	a9 00 00 00 04       	test   $0x4000000,%eax
				 * command doesn't actually go to SCST */
				scst_cmd = kmalloc(sizeof(struct scst_cmd),
						GFP_ATOMIC);
				TRACE_DBG("scst_cmd 0x%p", scst_cmd);
				if (scst_cmd != NULL) {
					cmd->reply_word = mpt_cmd->reply_word;
    3691:	89 87 e0 03 00 00    	mov    %eax,0x3e0(%edi)
					if (cmd->reply_word &
    3697:	0f 84 b2 02 00 00    	je     394f <stmapp_tgt_command+0x96f>
						TARGET_MODE_REPLY_ALIAS_MASK) {
						cmd->alias = (scsi_cmd->AliasID -
    369d:	0f b6 47 24          	movzbl 0x24(%edi),%eax
    36a1:	2b 43 3c             	sub    0x3c(%ebx),%eax
								priv->port_id) & 15;
    36a4:	83 e0 0f             	and    $0xf,%eax
    36a7:	89 87 e4 03 00 00    	mov    %eax,0x3e4(%edi)
					} else {
						cmd->alias = 0;
					}
					cmd->lun = get2bytes(scsi_cmd->LogicalUnitNumber,
    36ad:	8b 7d ac             	mov    -0x54(%ebp),%edi
							0);
					cmd->tag = scsi_cmd->Tag;
					mpt_cmd->CMD = cmd;

					memset(scst_cmd, 0x00,
    36b0:	be 9c 01 00 00       	mov    $0x19c,%esi
						cmd->alias = (scsi_cmd->AliasID -
								priv->port_id) & 15;
					} else {
						cmd->alias = 0;
					}
					cmd->lun = get2bytes(scsi_cmd->LogicalUnitNumber,
    36b5:	0f b6 47 04          	movzbl 0x4(%edi),%eax
    36b9:	0f b6 4f 05          	movzbl 0x5(%edi),%ecx
    36bd:	c1 e0 08             	shl    $0x8,%eax
    36c0:	01 c8                	add    %ecx,%eax
    36c2:	89 87 e8 03 00 00    	mov    %eax,0x3e8(%edi)
							0);
					cmd->tag = scsi_cmd->Tag;
    36c8:	0f b7 47 02          	movzwl 0x2(%edi),%eax
    36cc:	89 87 ec 03 00 00    	mov    %eax,0x3ec(%edi)
					mpt_cmd->CMD = cmd;
    36d2:	8b 45 a8             	mov    -0x58(%ebp),%eax
    36d5:	89 78 0c             	mov    %edi,0xc(%eax)

					memset(scst_cmd, 0x00,
    36d8:	31 c0                	xor    %eax,%eax
    36da:	f6 c2 01             	test   $0x1,%dl
    36dd:	89 d7                	mov    %edx,%edi
    36df:	0f 85 98 02 00 00    	jne    397d <stmapp_tgt_command+0x99d>
    36e5:	f7 c7 02 00 00 00    	test   $0x2,%edi
    36eb:	0f 85 82 02 00 00    	jne    3973 <stmapp_tgt_command+0x993>
    36f1:	89 f1                	mov    %esi,%ecx
    36f3:	c1 e9 02             	shr    $0x2,%ecx
    36f6:	f7 c6 02 00 00 00    	test   $0x2,%esi
    36fc:	f3 ab                	rep stos %eax,%es:(%edi)
    36fe:	74 02                	je     3702 <stmapp_tgt_command+0x722>
    3700:	66 ab                	stos   %ax,%es:(%edi)
    3702:	83 e6 01             	and    $0x1,%esi
    3705:	74 01                	je     3708 <stmapp_tgt_command+0x728>
    3707:	aa                   	stos   %al,%es:(%edi)
						sizeof(struct scst_cmd));
					scst_cmd->resp_data_len = -1;
					memcpy(scst_cmd->cdb, cdb,
    3708:	8b 7a 78             	mov    0x78(%edx),%edi
    370b:	8b 45 ac             	mov    -0x54(%ebp),%eax
					cmd->tag = scsi_cmd->Tag;
					mpt_cmd->CMD = cmd;

					memset(scst_cmd, 0x00,
						sizeof(struct scst_cmd));
					scst_cmd->resp_data_len = -1;
    370e:	c7 82 e8 00 00 00 ff 	movl   $0xffffffff,0xe8(%edx)
    3715:	ff ff ff 
					memcpy(scst_cmd->cdb, cdb,
    3718:	f7 c7 01 00 00 00    	test   $0x1,%edi
    371e:	8d 70 14             	lea    0x14(%eax),%esi
    3721:	b8 10 00 00 00       	mov    $0x10,%eax
    3726:	0f 85 3f 02 00 00    	jne    396b <stmapp_tgt_command+0x98b>
    372c:	f7 c7 02 00 00 00    	test   $0x2,%edi
    3732:	0f 85 29 02 00 00    	jne    3961 <stmapp_tgt_command+0x981>
    3738:	89 c1                	mov    %eax,%ecx
    373a:	c1 e9 02             	shr    $0x2,%ecx
    373d:	a8 02                	test   $0x2,%al
    373f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    3741:	74 0b                	je     374e <stmapp_tgt_command+0x76e>
    3743:	0f b7 0e             	movzwl (%esi),%ecx
    3746:	66 89 0f             	mov    %cx,(%edi)
    3749:	b9 02 00 00 00       	mov    $0x2,%ecx
    374e:	a8 01                	test   $0x1,%al
    3750:	74 07                	je     3759 <stmapp_tgt_command+0x779>
    3752:	0f b6 04 0e          	movzbl (%esi,%ecx,1),%eax
    3756:	88 04 0f             	mov    %al,(%edi,%ecx,1)
							MPT_MAX_CDB_LEN);
					priv->scst_cmd[index] = scst_cmd;
					scst_cmd_set_tag(scst_cmd, cmd->tag);
    3759:	8b 7d ac             	mov    -0x54(%ebp),%edi
					memset(scst_cmd, 0x00,
						sizeof(struct scst_cmd));
					scst_cmd->resp_data_len = -1;
					memcpy(scst_cmd->cdb, cdb,
							MPT_MAX_CDB_LEN);
					priv->scst_cmd[index] = scst_cmd;
    375c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    375f:	89 94 83 10 0c 00 00 	mov    %edx,0xc10(%ebx,%eax,4)
					scst_cmd_set_tag(scst_cmd, cmd->tag);
    3766:	8b 87 ec 03 00 00    	mov    0x3ec(%edi),%eax
    376c:	89 42 6c             	mov    %eax,0x6c(%edx)
    376f:	c1 f8 1f             	sar    $0x1f,%eax
    3772:	89 42 70             	mov    %eax,0x70(%edx)
	return cmd->tgt_i_priv;
}

static inline void scst_cmd_set_tgt_priv(struct scst_cmd *cmd, void *val)
{
	cmd->tgt_i_priv = val;
    3775:	8b 45 a8             	mov    -0x58(%ebp),%eax
    3778:	89 82 44 01 00 00    	mov    %eax,0x144(%edx)
					flags = TARGET_ASSIST_FLAGS_AUTO_STATUS;
					prm.cmd = mpt_cmd;
					/* smallest amount of data between
					 * requested length, buffer size,
					 * and cached length */
					prm.bufflen = min_t(size_t, cdb[4],
    377e:	ba 60 00 00 00       	mov    $0x60,%edx
					scst_cmd_set_tgt_priv(scst_cmd, mpt_cmd);

					TRACE_BUFFER("CDB", cdb, MPT_MAX_CDB_LEN);

					flags = TARGET_ASSIST_FLAGS_AUTO_STATUS;
					prm.cmd = mpt_cmd;
    3783:	89 45 f0             	mov    %eax,-0x10(%ebp)
					/* smallest amount of data between
					 * requested length, buffer size,
					 * and cached length */
					prm.bufflen = min_t(size_t, cdb[4],
    3786:	0f b6 47 18          	movzbl 0x18(%edi),%eax
    378a:	83 f8 60             	cmp    $0x60,%eax
    378d:	0f 47 c2             	cmova  %edx,%eax
						SCSI_SENSE_BUFFERSIZE);
					prm.bufflen = min_t(size_t, prm.bufflen,
    3790:	6b 55 b0 60          	imul   $0x60,-0x50(%ebp),%edx
    3794:	0f b6 8c 13 57 0e 00 	movzbl 0xe57(%ebx,%edx,1),%ecx
    379b:	00 
						priv->pending_sense_buffer[init_index][7]
							 + 8);
					sg_set_page(&sg,
						virt_to_page(priv->pending_sense_buffer[init_index]),
						prm.bufflen,
						offset_in_page(priv->pending_sense_buffer[init_index]));
    379c:	8d 94 13 50 0e 00 00 	lea    0xe50(%ebx,%edx,1),%edx
					prm.bufflen = min_t(size_t, cdb[4],
						SCSI_SENSE_BUFFERSIZE);
					prm.bufflen = min_t(size_t, prm.bufflen,
						priv->pending_sense_buffer[init_index][7]
							 + 8);
					sg_set_page(&sg,
    37a3:	89 d6                	mov    %edx,%esi
					/* smallest amount of data between
					 * requested length, buffer size,
					 * and cached length */
					prm.bufflen = min_t(size_t, cdb[4],
						SCSI_SENSE_BUFFERSIZE);
					prm.bufflen = min_t(size_t, prm.bufflen,
    37a5:	83 c1 08             	add    $0x8,%ecx
    37a8:	39 c8                	cmp    %ecx,%eax
    37aa:	0f 46 c8             	cmovbe %eax,%ecx
						priv->pending_sense_buffer[init_index][7]
							 + 8);
					sg_set_page(&sg,
						virt_to_page(priv->pending_sense_buffer[init_index]),
    37ad:	81 c2 00 00 00 40    	add    $0x40000000,%edx
    37b3:	89 d0                	mov    %edx,%eax
					prm.bufflen = min_t(size_t, cdb[4],
						SCSI_SENSE_BUFFERSIZE);
					prm.bufflen = min_t(size_t, prm.bufflen,
						priv->pending_sense_buffer[init_index][7]
							 + 8);
					sg_set_page(&sg,
    37b5:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
extern s8 physnode_map[];

static inline int pfn_to_nid(unsigned long pfn)
{
#ifdef CONFIG_NUMA
	return((int) physnode_map[(pfn) / PAGES_PER_SECTION]);
    37bb:	c1 ea 1a             	shr    $0x1a,%edx
						virt_to_page(priv->pending_sense_buffer[init_index]),
    37be:	0f be 92 00 00 00 00 	movsbl 0x0(%edx),%edx
    37c5:	c1 e8 0c             	shr    $0xc,%eax
					/* smallest amount of data between
					 * requested length, buffer size,
					 * and cached length */
					prm.bufflen = min_t(size_t, cdb[4],
						SCSI_SENSE_BUFFERSIZE);
					prm.bufflen = min_t(size_t, prm.bufflen,
    37c8:	89 4d d8             	mov    %ecx,-0x28(%ebp)
						priv->pending_sense_buffer[init_index][7]
							 + 8);
					sg_set_page(&sg,
						virt_to_page(priv->pending_sense_buffer[init_index]),
    37cb:	8b 3c 95 00 00 00 00 	mov    0x0(,%edx,4),%edi
 *   variant.
 *
 **/
static inline void sg_assign_page(struct scatterlist *sg, struct page *page)
{
	unsigned long page_link = sg->page_link & 0x3;
    37d2:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    37d5:	2b 87 b4 10 00 00    	sub    0x10b4(%edi),%eax
    37db:	83 e2 03             	and    $0x3,%edx
    37de:	c1 e0 05             	shl    $0x5,%eax
    37e1:	03 87 ac 10 00 00    	add    0x10ac(%edi),%eax

	/*
	 * In order for the low bit stealing approach to work, pages
	 * must be aligned at a 32-bit boundary as a minimum.
	 */
	BUG_ON((unsigned long) page & 0x03);
    37e7:	a8 03                	test   $0x3,%al
    37e9:	0f 85 98 01 00 00    	jne    3987 <stmapp_tgt_command+0x9a7>
#ifdef CONFIG_DEBUG_SG
	BUG_ON(sg->sg_magic != SG_MAGIC);
	BUG_ON(sg_is_chain(sg));
#endif
	sg->page_link = page_link | (unsigned long) page;
    37ef:	09 c2                	or     %eax,%edx
						prm.bufflen,
						offset_in_page(priv->pending_sense_buffer[init_index]));
					prm.buffer = &sg;
    37f1:	8d 45 b4             	lea    -0x4c(%ebp),%eax
    37f4:	89 55 b4             	mov    %edx,-0x4c(%ebp)
					prm.tgt = priv->tgt->sess[init_index]->tgt;
					prm.cmd->state = MPT_STATE_DATA_OUT;

					TRACE_DBG("%s: sending pending sense",
							priv->ioc->name);
					mpt_send_target_data(&prm, flags);
    37f7:	ba 02 00 00 00       	mov    $0x2,%edx
 **/
static inline void sg_set_page(struct scatterlist *sg, struct page *page,
			       unsigned int len, unsigned int offset)
{
	sg_assign_page(sg, page);
	sg->offset = offset;
    37fc:	89 75 b8             	mov    %esi,-0x48(%ebp)
	sg->length = len;
    37ff:	89 4d bc             	mov    %ecx,-0x44(%ebp)
							 + 8);
					sg_set_page(&sg,
						virt_to_page(priv->pending_sense_buffer[init_index]),
						prm.bufflen,
						offset_in_page(priv->pending_sense_buffer[init_index]));
					prm.buffer = &sg;
    3802:	89 45 dc             	mov    %eax,-0x24(%ebp)
					prm.use_sg = 1;
    3805:	66 c7 45 d2 01 00    	movw   $0x1,-0x2e(%ebp)
					prm.data_direction = SCST_DATA_READ;
    380b:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
					prm.tgt = priv->tgt->sess[init_index]->tgt;
    3812:	8b 83 0c 0c 00 00    	mov    0xc0c(%ebx),%eax
    3818:	8b 5d b0             	mov    -0x50(%ebp),%ebx
    381b:	8b 44 98 24          	mov    0x24(%eax,%ebx,4),%eax
    381f:	8b 40 04             	mov    0x4(%eax),%eax
    3822:	89 45 cc             	mov    %eax,-0x34(%ebp)
					prm.cmd->state = MPT_STATE_DATA_OUT;
    3825:	8b 45 a8             	mov    -0x58(%ebp),%eax
    3828:	c7 40 1c 04 00 00 00 	movl   $0x4,0x1c(%eax)

					TRACE_DBG("%s: sending pending sense",
							priv->ioc->name);
					mpt_send_target_data(&prm, flags);
    382f:	8d 45 cc             	lea    -0x34(%ebp),%eax
    3832:	e8 b9 f1 ff ff       	call   29f0 <mpt_send_target_data>
    3837:	e9 15 f8 ff ff       	jmp    3051 <stmapp_tgt_command+0x71>
	sess = tgt->sess[init_index];
	if (sess == NULL) {
		/* Allocation of sess */
		sess = kmalloc(sizeof(*sess), GFP_ATOMIC);
		if (sess == NULL) {
			TRACE(TRACE_OUT_OF_MEM, "%s",
    383c:	c7 44 24 18 41 01 00 	movl   $0x141,0x18(%esp)
    3843:	00 
    3844:	c7 44 24 14 e1 00 00 	movl   $0xe1,0x14(%esp)
    384b:	00 
    384c:	c7 44 24 10 ea 03 00 	movl   $0x3ea,0x10(%esp)
    3853:	00 
    3854:	c7 44 24 0c 21 03 00 	movl   $0x321,0xc(%esp)
    385b:	00 
    385c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    3863:	00 
    3864:	c7 44 24 04 a5 00 00 	movl   $0xa5,0x4(%esp)
    386b:	00 
    386c:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
    3873:	e8 fc ff ff ff       	call   3874 <stmapp_tgt_command+0x894>
    3878:	e9 bf fa ff ff       	jmp    333c <stmapp_tgt_command+0x35c>
		/* indentify the Initiator */
		init_str = kasprintf(GFP_KERNEL,
				    "%s->%02x",
				    priv->ioc->name, init_index);
		if (init_str == NULL) {
			PRINT_ERROR(MYNAM ": Allocation of init_str failed. "
    387d:	89 74 24 1c          	mov    %esi,0x1c(%esp)
    3881:	8b 03                	mov    (%ebx),%eax
    3883:	c7 44 24 14 64 07 00 	movl   $0x764,0x14(%esp)
    388a:	00 
    388b:	c7 44 24 10 f7 03 00 	movl   $0x3f7,0x10(%esp)
    3892:	00 
    3893:	c7 44 24 0c 21 03 00 	movl   $0x321,0xc(%esp)
    389a:	00 
    389b:	83 c0 08             	add    $0x8,%eax
    389e:	89 44 24 18          	mov    %eax,0x18(%esp)
    38a2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    38a9:	00 
    38aa:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
    38b1:	00 
    38b2:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
    38b9:	e8 fc ff ff ff       	call   38ba <stmapp_tgt_command+0x8da>
	TRACE_EXIT();
	return;

out_free_sess:
	TRACE_MEM("kfree for sess %p", sess);
	kfree(sess);
    38be:	8b 45 ac             	mov    -0x54(%ebp),%eax
    38c1:	e8 fc ff ff ff       	call   38c2 <stmapp_tgt_command+0x8e2>
 * returns true if the result is 0, or false for all other
 * cases.
 */
static inline int atomic_dec_and_test(atomic_t *v)
{
	GEN_UNARY_RMWcc(LOCK_PREFIX "decl", v->counter, "%0", "e");
    38c6:	8b 45 b0             	mov    -0x50(%ebp),%eax
    38c9:	f0 ff 48 14          	lock decl 0x14(%eax)
    38cd:	74 05                	je     38d4 <stmapp_tgt_command+0x8f4>
    38cf:	e9 68 fa ff ff       	jmp    333c <stmapp_tgt_command+0x35c>

	if (atomic_dec_and_test(&tgt->sess_count))
		wake_up_all(&tgt->waitQ);
    38d4:	8b 45 b0             	mov    -0x50(%ebp),%eax
    38d7:	31 c9                	xor    %ecx,%ecx
    38d9:	ba 03 00 00 00       	mov    $0x3,%edx
    38de:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    38e5:	83 c0 18             	add    $0x18,%eax
    38e8:	e8 fc ff ff ff       	call   38e9 <stmapp_tgt_command+0x909>
    38ed:	e9 4a fa ff ff       	jmp    333c <stmapp_tgt_command+0x35c>
		}

		atomic_inc(&tgt->sess_count);
		smp_mb__after_atomic_inc();

		memset(sess, 0, sizeof(*sess));
    38f2:	66 c7 02 00 00       	movw   $0x0,(%edx)
    38f7:	83 eb 02             	sub    $0x2,%ebx
    38fa:	83 c2 02             	add    $0x2,%edx
    38fd:	e9 97 fb ff ff       	jmp    3499 <stmapp_tgt_command+0x4b9>
    3902:	c6 00 00             	movb   $0x0,(%eax)
    3905:	8d 50 01             	lea    0x1(%eax),%edx
    3908:	b3 17                	mov    $0x17,%bl
    390a:	e9 81 fb ff ff       	jmp    3490 <stmapp_tgt_command+0x4b0>

		sess->scst_sess = scst_register_session(tgt->scst_tgt, 1,
							init_str, sess, sess,
							mpt_alloc_session_done);
		if (sess->scst_sess == NULL) {
			PRINT_ERROR(MYNAM ": scst_register_session failed %p",
    390f:	8b 45 b0             	mov    -0x50(%ebp),%eax
    3912:	c7 44 24 14 cc 07 00 	movl   $0x7cc,0x14(%esp)
    3919:	00 
    391a:	c7 44 24 10 08 04 00 	movl   $0x408,0x10(%esp)
    3921:	00 
    3922:	c7 44 24 0c 21 03 00 	movl   $0x321,0xc(%esp)
    3929:	00 
    392a:	89 44 24 18          	mov    %eax,0x18(%esp)
    392e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    3935:	00 
    3936:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
    393d:	00 
    393e:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
    3945:	e8 fc ff ff ff       	call   3946 <stmapp_tgt_command+0x966>
				    tgt);
			res = -EFAULT;
			goto out_free_sess;
    394a:	e9 6f ff ff ff       	jmp    38be <stmapp_tgt_command+0x8de>
					if (cmd->reply_word &
						TARGET_MODE_REPLY_ALIAS_MASK) {
						cmd->alias = (scsi_cmd->AliasID -
								priv->port_id) & 15;
					} else {
						cmd->alias = 0;
    394f:	8b 45 ac             	mov    -0x54(%ebp),%eax
    3952:	c7 80 e4 03 00 00 00 	movl   $0x0,0x3e4(%eax)
    3959:	00 00 00 
    395c:	e9 4c fd ff ff       	jmp    36ad <stmapp_tgt_command+0x6cd>
					mpt_cmd->CMD = cmd;

					memset(scst_cmd, 0x00,
						sizeof(struct scst_cmd));
					scst_cmd->resp_data_len = -1;
					memcpy(scst_cmd->cdb, cdb,
    3961:	66 a5                	movsw  %ds:(%esi),%es:(%edi)
    3963:	83 e8 02             	sub    $0x2,%eax
    3966:	e9 cd fd ff ff       	jmp    3738 <stmapp_tgt_command+0x758>
    396b:	a4                   	movsb  %ds:(%esi),%es:(%edi)
    396c:	b0 0f                	mov    $0xf,%al
    396e:	e9 b9 fd ff ff       	jmp    372c <stmapp_tgt_command+0x74c>
					cmd->lun = get2bytes(scsi_cmd->LogicalUnitNumber,
							0);
					cmd->tag = scsi_cmd->Tag;
					mpt_cmd->CMD = cmd;

					memset(scst_cmd, 0x00,
    3973:	66 ab                	stos   %ax,%es:(%edi)
    3975:	83 ee 02             	sub    $0x2,%esi
    3978:	e9 74 fd ff ff       	jmp    36f1 <stmapp_tgt_command+0x711>
    397d:	aa                   	stos   %al,%es:(%edi)
    397e:	66 be 9b 01          	mov    $0x19b,%si
    3982:	e9 5e fd ff ff       	jmp    36e5 <stmapp_tgt_command+0x705>

	/*
	 * In order for the low bit stealing approach to work, pages
	 * must be aligned at a 32-bit boundary as a minimum.
	 */
	BUG_ON((unsigned long) page & 0x03);
    3987:	0f 0b                	ud2    
    3989:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003990 <stm_tgt_reply>:
	}
	TRACE_EXIT();
}

static void stm_tgt_reply(MPT_ADAPTER *ioc, u32 reply_word)
{
    3990:	55                   	push   %ebp
    3991:	89 e5                	mov    %esp,%ebp
    3993:	57                   	push   %edi
    3994:	56                   	push   %esi
    3995:	53                   	push   %ebx
    3996:	83 ec 20             	sub    $0x20,%esp
    3999:	e8 fc ff ff ff       	call   399a <stm_tgt_reply+0xa>
    399e:	89 c7                	mov    %eax,%edi
	MPT_STM_PRIV *priv = mpt_stm_priv[ioc->id];
    39a0:	8b 00                	mov    (%eax),%eax
	}
	TRACE_EXIT();
}

static void stm_tgt_reply(MPT_ADAPTER *ioc, u32 reply_word)
{
    39a2:	89 55 e8             	mov    %edx,-0x18(%ebp)
	MPT_STM_PRIV *priv = mpt_stm_priv[ioc->id];
    39a5:	8b 04 85 20 00 00 00 	mov    0x20(,%eax,4),%eax
    39ac:	89 c1                	mov    %eax,%ecx
    39ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context = SCST_CONTEXT_THREAD;
#else
	context = SCST_CONTEXT_TASKLET;
#endif

	index = GET_IO_INDEX(reply_word);
    39b1:	89 d0                	mov    %edx,%eax
    39b3:	25 ff 3f 00 00       	and    $0x3fff,%eax
    39b8:	8d 1c 81             	lea    (%ecx,%eax,4),%ebx
	init_index = GET_INITIATOR_INDEX(reply_word);
	scst_cmd = priv->scst_cmd[index];
    39bb:	8b b3 10 0c 00 00    	mov    0xc10(%ebx),%esi
	context = SCST_CONTEXT_THREAD;
#else
	context = SCST_CONTEXT_TASKLET;
#endif

	index = GET_IO_INDEX(reply_word);
    39c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
			index, *io_state, scst_cmd, priv->current_mf[index]);
	/*
	 * if scst_cmd is NULL it show the command buffer not using by
	 * SCST, let parse the CDB
	 */
	if (scst_cmd == NULL) {
    39c4:	85 f6                	test   %esi,%esi
    39c6:	0f 84 94 01 00 00    	je     3b60 <stm_tgt_reply+0x1d0>
static void stm_tgt_reply(MPT_ADAPTER *ioc, u32 reply_word)
{
	MPT_STM_PRIV *priv = mpt_stm_priv[ioc->id];
	int index, init_index;
	enum scst_exec_context context;
	struct scst_cmd *scst_cmd;
    39cc:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    39d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	cmd = (struct mpt_cmd *)scst_cmd_get_tgt_priv(scst_cmd);
	TRACE_DBG("scst cmd %p, index %d, cmd %p, cmd state %s",
		  scst_cmd, index, cmd, mpt_state_string[cmd->state]);

	if (cmd->state == MPT_STATE_NEED_DATA) {
    39d5:	8b 40 1c             	mov    0x1c(%eax),%eax
    39d8:	83 f8 02             	cmp    $0x2,%eax
    39db:	74 4b                	je     3a28 <stm_tgt_reply+0x98>
		scst_rx_data(scst_cmd, rx_status, context);

		goto out;
	}

	if (*io_state & IO_STATE_STATUS_SENT) {
    39dd:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
    39e3:	83 e2 04             	and    $0x4,%edx
    39e6:	0f 85 9c 00 00 00    	jne    3a88 <stm_tgt_reply+0xf8>

	/*
	 *  data (but not status) was being sent, so if status needs to be
	 *  set now, go ahead and do it; otherwise do nothing
	 */
	if (*io_state & IO_STATE_DATA_SENT) {
    39ec:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
    39f2:	83 e2 02             	and    $0x2,%edx
    39f5:	0f 85 b5 01 00 00    	jne    3bb0 <stm_tgt_reply+0x220>

	/*
	 * just insert into list
	 * bug how can i handle it
	 */
	if (*io_state == 0 && cmd->state == MPT_STATE_NEW) {
    39fb:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
    3a01:	85 d2                	test   %edx,%edx
    3a03:	75 09                	jne    3a0e <stm_tgt_reply+0x7e>
    3a05:	83 f8 01             	cmp    $0x1,%eax
		WARN_ON(1);
    3a08:	66 ba 8c 03          	mov    $0x38c,%dx

	/*
	 * just insert into list
	 * bug how can i handle it
	 */
	if (*io_state == 0 && cmd->state == MPT_STATE_NEW) {
    3a0c:	74 05                	je     3a13 <stm_tgt_reply+0x83>
		 */
		*io_state &= ~IO_STATE_POSTED;
		goto out;
	}
#endif
	WARN_ON(1);
    3a0e:	ba 99 03 00 00       	mov    $0x399,%edx
out:

	TRACE_EXIT();
}
    3a13:	83 c4 20             	add    $0x20,%esp
		 */
		*io_state &= ~IO_STATE_POSTED;
		goto out;
	}
#endif
	WARN_ON(1);
    3a16:	b8 8c 01 00 00       	mov    $0x18c,%eax
out:

	TRACE_EXIT();
}
    3a1b:	5b                   	pop    %ebx
    3a1c:	5e                   	pop    %esi
    3a1d:	5f                   	pop    %edi
    3a1e:	5d                   	pop    %ebp
		 */
		*io_state &= ~IO_STATE_POSTED;
		goto out;
	}
#endif
	WARN_ON(1);
    3a1f:	e9 fc ff ff ff       	jmp    3a20 <stm_tgt_reply+0x90>
    3a24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		  scst_cmd, index, cmd, mpt_state_string[cmd->state]);

	if (cmd->state == MPT_STATE_NEED_DATA) {
		int rx_status = SCST_RX_STATUS_SUCCESS;

		cmd->state = MPT_STATE_DATA_IN;
    3a28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3a2b:	c7 40 1c 03 00 00 00 	movl   $0x3,0x1c(%eax)

		TRACE_DBG("Data received, context %x, rx_status %d",
				context, rx_status);

		sBUG_ON(!(*io_state & IO_STATE_DATA_SENT));
    3a32:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    3a38:	a8 02                	test   $0x2,%al
    3a3a:	0f 84 9e 02 00 00    	je     3cde <stm_tgt_reply+0x34e>
};

static inline void mpt_msg_frame_free(MPT_STM_PRIV *priv, int index)
{
	MPT_ADAPTER *ioc = priv->ioc;
	if (priv->current_mf[index] != NULL) {
    3a40:	8b 93 a0 03 00 00    	mov    0x3a0(%ebx),%edx
	.is_target_enabled = mpt_is_tgt_enabled,
};

static inline void mpt_msg_frame_free(MPT_STM_PRIV *priv, int index)
{
	MPT_ADAPTER *ioc = priv->ioc;
    3a46:	8b 45 f0             	mov    -0x10(%ebp),%eax
	if (priv->current_mf[index] != NULL) {
    3a49:	85 d2                	test   %edx,%edx
	.is_target_enabled = mpt_is_tgt_enabled,
};

static inline void mpt_msg_frame_free(MPT_STM_PRIV *priv, int index)
{
	MPT_ADAPTER *ioc = priv->ioc;
    3a4b:	8b 00                	mov    (%eax),%eax
	if (priv->current_mf[index] != NULL) {
    3a4d:	74 0f                	je     3a5e <stm_tgt_reply+0xce>
		TRACE_DBG("%s: free mf index %d, %p", ioc->name,
			  MF_TO_INDEX(priv->current_mf[index]),
			  priv->current_mf[index]);
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    3a4f:	e8 fc ff ff ff       	call   3a50 <stm_tgt_reply+0xc0>
		priv->current_mf[index] = NULL;
    3a54:	c7 83 a0 03 00 00 00 	movl   $0x0,0x3a0(%ebx)
    3a5b:	00 00 00 
		TRACE_DBG("Data received, context %x, rx_status %d",
				context, rx_status);

		sBUG_ON(!(*io_state & IO_STATE_DATA_SENT));
		mpt_msg_frame_free(priv, index);
		if (*io_state & IO_STATE_DATA_SENT) {
    3a5e:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    3a64:	a8 02                	test   $0x2,%al
    3a66:	0f 85 d4 00 00 00    	jne    3b40 <stm_tgt_reply+0x1b0>
#endif
	WARN_ON(1);
out:

	TRACE_EXIT();
}
    3a6c:	83 c4 20             	add    $0x20,%esp
		} else if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == 0) {
			TRACE_DBG("%s", "io state");
			stm_cmd_buf_post(priv, index);
		}
#endif
		scst_rx_data(scst_cmd, rx_status, context);
    3a6f:	89 f0                	mov    %esi,%eax
#endif
	WARN_ON(1);
out:

	TRACE_EXIT();
}
    3a71:	5b                   	pop    %ebx
		} else if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == 0) {
			TRACE_DBG("%s", "io state");
			stm_cmd_buf_post(priv, index);
		}
#endif
		scst_rx_data(scst_cmd, rx_status, context);
    3a72:	b9 02 00 00 00       	mov    $0x2,%ecx
#endif
	WARN_ON(1);
out:

	TRACE_EXIT();
}
    3a77:	5e                   	pop    %esi
		} else if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == 0) {
			TRACE_DBG("%s", "io state");
			stm_cmd_buf_post(priv, index);
		}
#endif
		scst_rx_data(scst_cmd, rx_status, context);
    3a78:	31 d2                	xor    %edx,%edx
#endif
	WARN_ON(1);
out:

	TRACE_EXIT();
}
    3a7a:	5f                   	pop    %edi
    3a7b:	5d                   	pop    %ebp
		} else if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == 0) {
			TRACE_DBG("%s", "io state");
			stm_cmd_buf_post(priv, index);
		}
#endif
		scst_rx_data(scst_cmd, rx_status, context);
    3a7c:	e9 fc ff ff ff       	jmp    3a7d <stm_tgt_reply+0xed>
    3a81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	if (*io_state & IO_STATE_STATUS_SENT) {
		/*
		 *  status (and maybe data too) was being sent, so repost the
		 *  command buffer
		 */
		*io_state &= ~IO_STATE_STATUS_SENT;
    3a88:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    3a8e:	8b 93 a0 03 00 00    	mov    0x3a0(%ebx),%edx
	if (*io_state & IO_STATE_STATUS_SENT) {
		/*
		 *  status (and maybe data too) was being sent, so repost the
		 *  command buffer
		 */
		*io_state &= ~IO_STATE_STATUS_SENT;
    3a94:	83 e0 fb             	and    $0xfffffffb,%eax
    3a97:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    3a9d:	89 f8                	mov    %edi,%eax
    3a9f:	e8 fc ff ff ff       	call   3aa0 <stm_tgt_reply+0x110>
		if (*io_state & IO_STATE_DATA_SENT) {
    3aa4:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    3aaa:	a8 02                	test   $0x2,%al
    3aac:	0f 85 46 01 00 00    	jne    3bf8 <stm_tgt_reply+0x268>
			*io_state &= ~IO_STATE_DATA_SENT;
			stm_data_done(ioc, reply_word, scst_cmd, cmd, index);
		}
		TRACE_DBG("set priv->scst_cmd[%d] = NULL", index);
		priv->scst_cmd[index] = NULL;
		if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == IO_STATE_AUTO_REPOST) {
    3ab2:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
		if (*io_state & IO_STATE_DATA_SENT) {
			*io_state &= ~IO_STATE_DATA_SENT;
			stm_data_done(ioc, reply_word, scst_cmd, cmd, index);
		}
		TRACE_DBG("set priv->scst_cmd[%d] = NULL", index);
		priv->scst_cmd[index] = NULL;
    3ab8:	c7 83 10 0c 00 00 00 	movl   $0x0,0xc10(%ebx)
    3abf:	00 00 00 
		if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == IO_STATE_AUTO_REPOST) {
    3ac2:	24 7f                	and    $0x7f,%al
    3ac4:	83 f8 20             	cmp    $0x20,%eax
    3ac7:	0f 84 6b 01 00 00    	je     3c38 <stm_tgt_reply+0x2a8>
			TRACE_DBG("%s", "io state auto repost");
			*io_state = IO_STATE_POSTED;
		} else if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == 0) {
    3acd:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    3ad3:	a9 7f ff ff ff       	test   $0xffffff7f,%eax
    3ad8:	75 0b                	jne    3ae5 <stm_tgt_reply+0x155>
			TRACE_DBG("%s", "io state");
			stm_cmd_buf_post(priv, index);
    3ada:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3add:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3ae0:	e8 4b d9 ff ff       	call   1430 <stm_cmd_buf_post>
		}

		/*
		 * figure out how we're handling cached sense data.
		 */
		if (IsScsi(priv)) {
    3ae5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3ae8:	8b 00                	mov    (%eax),%eax
    3aea:	80 b8 69 03 00 00 01 	cmpb   $0x1,0x369(%eax)
    3af1:	75 35                	jne    3b28 <stm_tgt_reply+0x198>
#else
	context = SCST_CONTEXT_TASKLET;
#endif

	index = GET_IO_INDEX(reply_word);
	init_index = GET_INITIATOR_INDEX(reply_word);
    3af3:	8b 45 e8             	mov    -0x18(%ebp),%eax

		/*
		 * figure out how we're handling cached sense data.
		 */
		if (IsScsi(priv)) {
			switch (atomic_read(&priv->pending_sense[init_index])) {
    3af6:	8b 7d f0             	mov    -0x10(%ebp),%edi
#else
	context = SCST_CONTEXT_TASKLET;
#endif

	index = GET_IO_INDEX(reply_word);
	init_index = GET_INITIATOR_INDEX(reply_word);
    3af9:	25 00 c0 ff 03       	and    $0x3ffc000,%eax
    3afe:	c1 e8 0e             	shr    $0xe,%eax

		/*
		 * figure out how we're handling cached sense data.
		 */
		if (IsScsi(priv)) {
			switch (atomic_read(&priv->pending_sense[init_index])) {
    3b01:	8d 94 87 10 0e 00 00 	lea    0xe10(%edi,%eax,4),%edx
 *
 * Atomically reads the value of @v.
 */
static inline int atomic_read(const atomic_t *v)
{
	return (*(volatile int *)&(v)->counter);
    3b08:	8b 02                	mov    (%edx),%eax
    3b0a:	83 f8 02             	cmp    $0x2,%eax
    3b0d:	0f 84 9d 01 00 00    	je     3cb0 <stm_tgt_reply+0x320>
    3b13:	83 f8 03             	cmp    $0x3,%eax
    3b16:	0f 84 fc 00 00 00    	je     3c18 <stm_tgt_reply+0x288>
    3b1c:	83 f8 01             	cmp    $0x1,%eax
    3b1f:	75 07                	jne    3b28 <stm_tgt_reply+0x198>
 *
 * Atomically sets the value of @v to @i.
 */
static inline void atomic_set(atomic_t *v, int i)
{
	v->counter = i;
    3b21:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    3b27:	90                   	nop
#endif
	WARN_ON(1);
out:

	TRACE_EXIT();
}
    3b28:	83 c4 20             	add    $0x20,%esp
				 * REQUEST_SENSE */
			case MPT_STATUS_SENSE_NOT_SENT:
				atomic_set(&priv->pending_sense[init_index],
					   MPT_STATUS_SENSE_HANDLE_RQ);
				/* ToDo: check and set scst_set_delivery_status(), if necessary */
				scst_tgt_cmd_done(scst_cmd, context);
    3b2b:	89 f0                	mov    %esi,%eax
#endif
	WARN_ON(1);
out:

	TRACE_EXIT();
}
    3b2d:	5b                   	pop    %ebx
				 * REQUEST_SENSE */
			case MPT_STATUS_SENSE_NOT_SENT:
				atomic_set(&priv->pending_sense[init_index],
					   MPT_STATUS_SENSE_HANDLE_RQ);
				/* ToDo: check and set scst_set_delivery_status(), if necessary */
				scst_tgt_cmd_done(scst_cmd, context);
    3b2e:	ba 02 00 00 00       	mov    $0x2,%edx
#endif
	WARN_ON(1);
out:

	TRACE_EXIT();
}
    3b33:	5e                   	pop    %esi
    3b34:	5f                   	pop    %edi
    3b35:	5d                   	pop    %ebp
				 * REQUEST_SENSE */
			case MPT_STATUS_SENSE_NOT_SENT:
				atomic_set(&priv->pending_sense[init_index],
					   MPT_STATUS_SENSE_HANDLE_RQ);
				/* ToDo: check and set scst_set_delivery_status(), if necessary */
				scst_tgt_cmd_done(scst_cmd, context);
    3b36:	e9 fc ff ff ff       	jmp    3b37 <stm_tgt_reply+0x1a7>
    3b3b:	90                   	nop
    3b3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				context, rx_status);

		sBUG_ON(!(*io_state & IO_STATE_DATA_SENT));
		mpt_msg_frame_free(priv, index);
		if (*io_state & IO_STATE_DATA_SENT) {
			*io_state &= ~IO_STATE_DATA_SENT;
    3b40:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
			stm_data_done(ioc, reply_word, scst_cmd, cmd, index);
    3b46:	89 f2                	mov    %esi,%edx
    3b48:	8b 4d ec             	mov    -0x14(%ebp),%ecx
				context, rx_status);

		sBUG_ON(!(*io_state & IO_STATE_DATA_SENT));
		mpt_msg_frame_free(priv, index);
		if (*io_state & IO_STATE_DATA_SENT) {
			*io_state &= ~IO_STATE_DATA_SENT;
    3b4b:	83 e0 fd             	and    $0xfffffffd,%eax
    3b4e:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
			stm_data_done(ioc, reply_word, scst_cmd, cmd, index);
    3b54:	8b 07                	mov    (%edi),%eax
    3b56:	e8 d5 ce ff ff       	call   a30 <stm_data_done.isra.38>
    3b5b:	e9 0c ff ff ff       	jmp    3a6c <stm_tgt_reply+0xdc>
	/*
	 * if scst_cmd is NULL it show the command buffer not using by
	 * SCST, let parse the CDB
	 */
	if (scst_cmd == NULL) {
		WARN_ON((*io_state & ~IO_STATE_HIGH_PRIORITY) != IO_STATE_POSTED);
    3b60:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    3b66:	24 7f                	and    $0x7f,%al
    3b68:	83 f8 01             	cmp    $0x1,%eax
    3b6b:	0f 85 59 01 00 00    	jne    3cca <stm_tgt_reply+0x33a>
		*io_state &= ~IO_STATE_POSTED;
    3b71:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
};

static inline void mpt_msg_frame_free(MPT_STM_PRIV *priv, int index)
{
	MPT_ADAPTER *ioc = priv->ioc;
	if (priv->current_mf[index] != NULL) {
    3b77:	8b 93 a0 03 00 00    	mov    0x3a0(%ebx),%edx
	 * if scst_cmd is NULL it show the command buffer not using by
	 * SCST, let parse the CDB
	 */
	if (scst_cmd == NULL) {
		WARN_ON((*io_state & ~IO_STATE_HIGH_PRIORITY) != IO_STATE_POSTED);
		*io_state &= ~IO_STATE_POSTED;
    3b7d:	83 e0 fe             	and    $0xfffffffe,%eax
    3b80:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	.is_target_enabled = mpt_is_tgt_enabled,
};

static inline void mpt_msg_frame_free(MPT_STM_PRIV *priv, int index)
{
	MPT_ADAPTER *ioc = priv->ioc;
    3b86:	8b 45 f0             	mov    -0x10(%ebp),%eax
	if (priv->current_mf[index] != NULL) {
    3b89:	85 d2                	test   %edx,%edx
	.is_target_enabled = mpt_is_tgt_enabled,
};

static inline void mpt_msg_frame_free(MPT_STM_PRIV *priv, int index)
{
	MPT_ADAPTER *ioc = priv->ioc;
    3b8b:	8b 00                	mov    (%eax),%eax
	if (priv->current_mf[index] != NULL) {
    3b8d:	74 0f                	je     3b9e <stm_tgt_reply+0x20e>
		TRACE_DBG("%s: free mf index %d, %p", ioc->name,
			  MF_TO_INDEX(priv->current_mf[index]),
			  priv->current_mf[index]);
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    3b8f:	e8 fc ff ff ff       	call   3b90 <stm_tgt_reply+0x200>
		priv->current_mf[index] = NULL;
    3b94:	c7 83 a0 03 00 00 00 	movl   $0x0,0x3a0(%ebx)
    3b9b:	00 00 00 
		WARN_ON((*io_state & ~IO_STATE_HIGH_PRIORITY) != IO_STATE_POSTED);
		*io_state &= ~IO_STATE_POSTED;

		mpt_msg_frame_free(priv, index);

		stmapp_tgt_command(priv, reply_word);
    3b9e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    3ba1:	8b 45 f0             	mov    -0x10(%ebp),%eax
#endif
	WARN_ON(1);
out:

	TRACE_EXIT();
}
    3ba4:	83 c4 20             	add    $0x20,%esp
    3ba7:	5b                   	pop    %ebx
    3ba8:	5e                   	pop    %esi
    3ba9:	5f                   	pop    %edi
    3baa:	5d                   	pop    %ebp
		WARN_ON((*io_state & ~IO_STATE_HIGH_PRIORITY) != IO_STATE_POSTED);
		*io_state &= ~IO_STATE_POSTED;

		mpt_msg_frame_free(priv, index);

		stmapp_tgt_command(priv, reply_word);
    3bab:	e9 30 f4 ff ff       	jmp    2fe0 <stmapp_tgt_command>
	/*
	 *  data (but not status) was being sent, so if status needs to be
	 *  set now, go ahead and do it; otherwise do nothing
	 */
	if (*io_state & IO_STATE_DATA_SENT) {
		*io_state &= ~IO_STATE_DATA_SENT;
    3bb0:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    3bb6:	8b 93 a0 03 00 00    	mov    0x3a0(%ebx),%edx
	/*
	 *  data (but not status) was being sent, so if status needs to be
	 *  set now, go ahead and do it; otherwise do nothing
	 */
	if (*io_state & IO_STATE_DATA_SENT) {
		*io_state &= ~IO_STATE_DATA_SENT;
    3bbc:	83 e0 fd             	and    $0xfffffffd,%eax
    3bbf:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    3bc5:	89 f8                	mov    %edi,%eax
    3bc7:	e8 fc ff ff ff       	call   3bc8 <stm_tgt_reply+0x238>
		stm_data_done(ioc, reply_word, scst_cmd, cmd, index);
    3bcc:	8b 07                	mov    (%edi),%eax
    3bce:	89 f2                	mov    %esi,%edx
    3bd0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    3bd3:	e8 58 ce ff ff       	call   a30 <stm_data_done.isra.38>
		if (*io_state & IO_STATE_STATUS_DEFERRED) {
    3bd8:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    3bde:	a8 08                	test   $0x8,%al
    3be0:	75 66                	jne    3c48 <stm_tgt_reply+0x2b8>
			*io_state &= ~IO_STATE_STATUS_DEFERRED;
			stm_send_target_status_deferred(priv, reply_word, index);
		}
		cmd->state = MPT_STATE_PROCESSED;
    3be2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3be5:	c7 40 1c 05 00 00 00 	movl   $0x5,0x1c(%eax)
#endif
	WARN_ON(1);
out:

	TRACE_EXIT();
}
    3bec:	83 c4 20             	add    $0x20,%esp
    3bef:	5b                   	pop    %ebx
    3bf0:	5e                   	pop    %esi
    3bf1:	5f                   	pop    %edi
    3bf2:	5d                   	pop    %ebp
    3bf3:	c3                   	ret    
    3bf4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		 *  command buffer
		 */
		*io_state &= ~IO_STATE_STATUS_SENT;
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
		if (*io_state & IO_STATE_DATA_SENT) {
			*io_state &= ~IO_STATE_DATA_SENT;
    3bf8:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
			stm_data_done(ioc, reply_word, scst_cmd, cmd, index);
    3bfe:	89 f2                	mov    %esi,%edx
    3c00:	8b 4d ec             	mov    -0x14(%ebp),%ecx
		 *  command buffer
		 */
		*io_state &= ~IO_STATE_STATUS_SENT;
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
		if (*io_state & IO_STATE_DATA_SENT) {
			*io_state &= ~IO_STATE_DATA_SENT;
    3c03:	83 e0 fd             	and    $0xfffffffd,%eax
    3c06:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
			stm_data_done(ioc, reply_word, scst_cmd, cmd, index);
    3c0c:	8b 07                	mov    (%edi),%eax
    3c0e:	e8 1d ce ff ff       	call   a30 <stm_data_done.isra.38>
    3c13:	e9 9a fe ff ff       	jmp    3ab2 <stm_tgt_reply+0x122>
			case MPT_STATUS_SENSE_HANDLE_RQ:
				TRACE_DBG("%s: clearing pending sense",
					  ioc->name);
				atomic_set(&priv->pending_sense[init_index],
					   MPT_STATUS_SENSE_IDLE);
				mpt_on_free_cmd(scst_cmd);
    3c18:	89 f0                	mov    %esi,%eax
    3c1a:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
    3c20:	e8 5b c6 ff ff       	call   280 <mpt_on_free_cmd>
#endif
	WARN_ON(1);
out:

	TRACE_EXIT();
}
    3c25:	83 c4 20             	add    $0x20,%esp
					  ioc->name);
				atomic_set(&priv->pending_sense[init_index],
					   MPT_STATUS_SENSE_IDLE);
				mpt_on_free_cmd(scst_cmd);
				/* scst_cmd alloced in stmapp_pending_sense */
				kfree(scst_cmd);
    3c28:	89 f0                	mov    %esi,%eax
#endif
	WARN_ON(1);
out:

	TRACE_EXIT();
}
    3c2a:	5b                   	pop    %ebx
    3c2b:	5e                   	pop    %esi
    3c2c:	5f                   	pop    %edi
    3c2d:	5d                   	pop    %ebp
					  ioc->name);
				atomic_set(&priv->pending_sense[init_index],
					   MPT_STATUS_SENSE_IDLE);
				mpt_on_free_cmd(scst_cmd);
				/* scst_cmd alloced in stmapp_pending_sense */
				kfree(scst_cmd);
    3c2e:	e9 fc ff ff ff       	jmp    3c2f <stm_tgt_reply+0x29f>
    3c33:	90                   	nop
    3c34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		TRACE_DBG("set priv->scst_cmd[%d] = NULL", index);
		priv->scst_cmd[index] = NULL;
		if ((*io_state & ~IO_STATE_HIGH_PRIORITY) == IO_STATE_AUTO_REPOST) {
			TRACE_DBG("%s", "io state auto repost");
			*io_state = IO_STATE_POSTED;
    3c38:	c7 83 a0 00 00 00 01 	movl   $0x1,0xa0(%ebx)
    3c3f:	00 00 00 
    3c42:	e9 9e fe ff ff       	jmp    3ae5 <stm_tgt_reply+0x155>
    3c47:	90                   	nop
	if (*io_state & IO_STATE_DATA_SENT) {
		*io_state &= ~IO_STATE_DATA_SENT;
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
		stm_data_done(ioc, reply_word, scst_cmd, cmd, index);
		if (*io_state & IO_STATE_STATUS_DEFERRED) {
			*io_state &= ~IO_STATE_STATUS_DEFERRED;
    3c48:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	MPT_ADAPTER         *ioc = priv->ioc;
	MPT_FRAME_HDR       *mf;
	TargetStatusSendRequest_t   *req;

	TRACE_ENTRY();
	mf = priv->status_deferred_mf[index];
    3c4e:	8b 8b a0 05 00 00    	mov    0x5a0(%ebx),%ecx
	if (*io_state & IO_STATE_DATA_SENT) {
		*io_state &= ~IO_STATE_DATA_SENT;
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
		stm_data_done(ioc, reply_word, scst_cmd, cmd, index);
		if (*io_state & IO_STATE_STATUS_DEFERRED) {
			*io_state &= ~IO_STATE_STATUS_DEFERRED;
    3c54:	83 e0 f7             	and    $0xfffffff7,%eax
    3c57:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)

static void stm_send_target_status_deferred(MPT_STM_PRIV *priv, u32 reply_word,
					    int index)
{
	int ret = 0;
	MPT_ADAPTER         *ioc = priv->ioc;
    3c5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3c60:	8b 10                	mov    (%eax),%edx
	TRACE_ENTRY();
	mf = priv->status_deferred_mf[index];
	TRACE_DBG("mf %p, index %d", mf, index);
	req = (TargetStatusSendRequest_t *)mf;

	priv->io_state[index] |= IO_STATE_STATUS_SENT;
    3c62:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax

	priv->current_mf[index] = mf;
    3c68:	89 8b a0 03 00 00    	mov    %ecx,0x3a0(%ebx)
	priv->status_deferred_mf[index] = NULL;
    3c6e:	c7 83 a0 05 00 00 00 	movl   $0x0,0x5a0(%ebx)
    3c75:	00 00 00 
	TRACE_ENTRY();
	mf = priv->status_deferred_mf[index];
	TRACE_DBG("mf %p, index %d", mf, index);
	req = (TargetStatusSendRequest_t *)mf;

	priv->io_state[index] |= IO_STATE_STATUS_SENT;
    3c78:	83 c8 04             	or     $0x4,%eax
    3c7b:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)

	priv->current_mf[index] = mf;
	priv->status_deferred_mf[index] = NULL;
	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
    3c81:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    3c87:	a8 80                	test   $0x80,%al
		ret = mpt_send_handshake_request(stm_context, _IOC_ID,
    3c89:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax

	priv->io_state[index] |= IO_STATE_STATUS_SENT;

	priv->current_mf[index] = mf;
	priv->status_deferred_mf[index] = NULL;
	if (priv->io_state[index] & IO_STATE_HIGH_PRIORITY) {
    3c90:	74 2e                	je     3cc0 <stm_tgt_reply+0x330>
		ret = mpt_send_handshake_request(stm_context, _IOC_ID,
    3c92:	89 0c 24             	mov    %ecx,(%esp)
    3c95:	b9 24 00 00 00       	mov    $0x24,%ecx
    3c9a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    3ca1:	00 
    3ca2:	e8 fc ff ff ff       	call   3ca3 <stm_tgt_reply+0x313>
    3ca7:	e9 36 ff ff ff       	jmp    3be2 <stm_tgt_reply+0x252>
    3cac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    3cb0:	c7 02 03 00 00 00    	movl   $0x3,(%edx)
    3cb6:	e9 6d fe ff ff       	jmp    3b28 <stm_tgt_reply+0x198>
    3cbb:	90                   	nop
    3cbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				sizeof(*req), (u32 *)req _HS_SLEEP);
	} else {
		mpt_put_msg_frame(stm_context, _IOC_ID, mf);
    3cc0:	e8 fc ff ff ff       	call   3cc1 <stm_tgt_reply+0x331>
    3cc5:	e9 18 ff ff ff       	jmp    3be2 <stm_tgt_reply+0x252>
	/*
	 * if scst_cmd is NULL it show the command buffer not using by
	 * SCST, let parse the CDB
	 */
	if (scst_cmd == NULL) {
		WARN_ON((*io_state & ~IO_STATE_HIGH_PRIORITY) != IO_STATE_POSTED);
    3cca:	ba 06 03 00 00       	mov    $0x306,%edx
    3ccf:	b8 8c 01 00 00       	mov    $0x18c,%eax
    3cd4:	e8 fc ff ff ff       	call   3cd5 <stm_tgt_reply+0x345>
    3cd9:	e9 93 fe ff ff       	jmp    3b71 <stm_tgt_reply+0x1e1>
		cmd->state = MPT_STATE_DATA_IN;

		TRACE_DBG("Data received, context %x, rx_status %d",
				context, rx_status);

		sBUG_ON(!(*io_state & IO_STATE_DATA_SENT));
    3cde:	c7 44 24 0c 3c 08 00 	movl   $0x83c,0xc(%esp)
    3ce5:	00 
    3ce6:	c7 44 24 08 1b 03 00 	movl   $0x31b,0x8(%esp)
    3ced:	00 
    3cee:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
    3cf5:	00 
    3cf6:	c7 04 24 b3 00 00 00 	movl   $0xb3,(%esp)
    3cfd:	e8 fc ff ff ff       	call   3cfe <stm_tgt_reply+0x36e>
    3d02:	ff 15 0c 00 00 00    	call   *0xc
    3d08:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
    3d0e:	f6 c4 ff             	test   $0xff,%ah
    3d11:	74 1a                	je     3d2d <stm_tgt_reply+0x39d>
    3d13:	b8 13 3d 00 00       	mov    $0x3d13,%eax
    3d18:	ba 00 02 00 00       	mov    $0x200,%edx
    3d1d:	e8 fc ff ff ff       	call   3d1e <stm_tgt_reply+0x38e>
    3d22:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
    3d28:	f6 c4 ff             	test   $0xff,%ah
    3d2b:	75 e6                	jne    3d13 <stm_tgt_reply+0x383>
    3d2d:	0f 0b                	ud2    
    3d2f:	90                   	nop

00003d30 <stmapp_target_error>:
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stmapp_target_error(MPT_STM_PRIV *priv, u32 reply_word, int index,
				int status, int reason)
{
    3d30:	55                   	push   %ebp
    3d31:	89 e5                	mov    %esp,%ebp
    3d33:	57                   	push   %edi
    3d34:	56                   	push   %esi
    3d35:	53                   	push   %ebx
    3d36:	83 ec 24             	sub    $0x24,%esp
    3d39:	e8 fc ff ff ff       	call   3d3a <stmapp_target_error+0xa>
    3d3e:	8b 7d 0c             	mov    0xc(%ebp),%edi
    3d41:	89 c6                	mov    %eax,%esi
    3d43:	8b 45 08             	mov    0x8(%ebp),%eax
	MPT_ADAPTER		*ioc = priv->ioc;
    3d46:	8b 1e                	mov    (%esi),%ebx
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stmapp_target_error(MPT_STM_PRIV *priv, u32 reply_word, int index,
				int status, int reason)
{
    3d48:	89 55 e0             	mov    %edx,-0x20(%ebp)
    3d4b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    3d4e:	89 7d dc             	mov    %edi,-0x24(%ebp)
	MPT_ADAPTER		*ioc = priv->ioc;
    3d51:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    3d54:	8d 1c 8e             	lea    (%esi,%ecx,4),%ebx
		  ioc->name, index, status, reason);

	io_state = priv->io_state + index;
	init_index = GET_INITIATOR_INDEX(reply_word);

	if (*io_state & IO_STATE_DATA_SENT) {
    3d57:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
    3d5d:	83 e2 02             	and    $0x2,%edx
    3d60:	0f 84 8a 01 00 00    	je     3ef0 <stmapp_target_error+0x1c0>
		TargetAssistRequest_t	*req;

		req = (TargetAssistRequest_t *)priv->current_mf[index];
    3d66:	8b 94 8e a0 03 00 00 	mov    0x3a0(%esi,%ecx,4),%edx
		lun = get2bytes(req->LUN, 0);
    3d6d:	0f b6 4a 10          	movzbl 0x10(%edx),%ecx
    3d71:	0f b6 7a 11          	movzbl 0x11(%edx),%edi
    3d75:	c1 e1 08             	shl    $0x8,%ecx
    3d78:	01 cf                	add    %ecx,%edi
		tag = req->QueueTag;
    3d7a:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx

	if (*io_state & IO_STATE_DATA_SENT) {
		TargetAssistRequest_t	*req;

		req = (TargetAssistRequest_t *)priv->current_mf[index];
		lun = get2bytes(req->LUN, 0);
    3d7e:	89 7d ec             	mov    %edi,-0x14(%ebp)
		tag = req->QueueTag;
    3d81:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	}

	if (*io_state & IO_STATE_STATUS_SENT) {
    3d84:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
    3d8a:	83 e2 04             	and    $0x4,%edx
    3d8d:	74 21                	je     3db0 <stmapp_target_error+0x80>
		TargetStatusSendRequest_t	*req;

		req = (TargetStatusSendRequest_t *)priv->current_mf[index];
    3d8f:	8b 7d f0             	mov    -0x10(%ebp),%edi
    3d92:	8b 94 be a0 03 00 00 	mov    0x3a0(%esi,%edi,4),%edx
		lun = get2bytes(req->LUN, 0);
    3d99:	0f b6 4a 10          	movzbl 0x10(%edx),%ecx
    3d9d:	0f b6 7a 11          	movzbl 0x11(%edx),%edi
    3da1:	c1 e1 08             	shl    $0x8,%ecx
    3da4:	01 f9                	add    %edi,%ecx
		tag = req->QueueTag;
    3da6:	0f b7 7a 04          	movzwl 0x4(%edx),%edi

	if (*io_state & IO_STATE_STATUS_SENT) {
		TargetStatusSendRequest_t	*req;

		req = (TargetStatusSendRequest_t *)priv->current_mf[index];
		lun = get2bytes(req->LUN, 0);
    3daa:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		tag = req->QueueTag;
    3dad:	89 7d e8             	mov    %edi,-0x18(%ebp)

	/*
	 *  if the status is Target Priority I/O, the I/O is still
	 *  active and a response is needed
	 */
	if (status == MPI_IOCSTATUS_TARGET_PRIORITY_IO) {
    3db0:	83 f8 60             	cmp    $0x60,%eax
    3db3:	0f 84 4f 03 00 00    	je     4108 <stmapp_target_error+0x3d8>
	 *  if the status is Target Transfer Count Mismatch, Target Data Offset
	 *  Error, Target Too Much Write Data, Target IU Too Short, EEDP Guard
	 *  Error, EEDP Reference Tag Error, or EEDP Application Tag Error, thes
	 *  I/O is still active and a response is needed
	 */
	if (status == MPI_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH ||
    3db9:	83 f8 6d             	cmp    $0x6d,%eax
    3dbc:	74 52                	je     3e10 <stmapp_target_error+0xe0>
    3dbe:	83 f8 6a             	cmp    $0x6a,%eax
    3dc1:	74 4d                	je     3e10 <stmapp_target_error+0xe0>
	    status == MPI_IOCSTATUS_TARGET_DATA_OFFSET_ERROR   ||
	    status == MPI_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA ||
    3dc3:	8d 50 92             	lea    -0x6e(%eax),%edx
    3dc6:	83 fa 01             	cmp    $0x1,%edx
    3dc9:	76 45                	jbe    3e10 <stmapp_target_error+0xe0>
	    status == MPI_IOCSTATUS_TARGET_IU_TOO_SHORT ||
	    status == MPI_IOCSTATUS_EEDP_GUARD_ERROR ||
    3dcb:	8d 48 b3             	lea    -0x4d(%eax),%ecx
    3dce:	83 f9 01             	cmp    $0x1,%ecx
    3dd1:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    3dd4:	76 40                	jbe    3e16 <stmapp_target_error+0xe6>
	    status == MPI_IOCSTATUS_EEDP_REF_TAG_ERROR ||
    3dd6:	83 f8 4f             	cmp    $0x4f,%eax
    3dd9:	0f 84 89 02 00 00    	je     4068 <stmapp_target_error+0x338>
	 *  The IOC knows it can't send status and sense over a
	 *  traditional SCSI cable (if non-packetized), so we should
	 *  treat this as a successful completion, manually repost the
	 *  command to the IOC, and free the SCST command.
	 */
	if (IsScsi(priv) && (status == MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT)) {
    3ddf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    3de2:	80 ba 69 03 00 00 01 	cmpb   $0x1,0x369(%edx)
    3de9:	0f 84 39 01 00 00    	je     3f28 <stmapp_target_error+0x1f8>
			TRACE_EXIT();
			return;
		}
	}

	*io_state &= ~IO_STATE_AUTO_REPOST;
    3def:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	stm_target_cleanup(priv, index);
    3df5:	8b 55 f0             	mov    -0x10(%ebp),%edx
			TRACE_EXIT();
			return;
		}
	}

	*io_state &= ~IO_STATE_AUTO_REPOST;
    3df8:	83 e0 df             	and    $0xffffffdf,%eax
    3dfb:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	stm_target_cleanup(priv, index);
	TRACE_EXIT();
}
    3e01:	83 c4 24             	add    $0x24,%esp
			return;
		}
	}

	*io_state &= ~IO_STATE_AUTO_REPOST;
	stm_target_cleanup(priv, index);
    3e04:	89 f0                	mov    %esi,%eax
	TRACE_EXIT();
}
    3e06:	5b                   	pop    %ebx
    3e07:	5e                   	pop    %esi
    3e08:	5f                   	pop    %edi
    3e09:	5d                   	pop    %ebp
			return;
		}
	}

	*io_state &= ~IO_STATE_AUTO_REPOST;
	stm_target_cleanup(priv, index);
    3e0a:	e9 31 d8 ff ff       	jmp    1640 <stm_target_cleanup>
    3e0f:	90                   	nop
    3e10:	83 e8 4d             	sub    $0x4d,%eax
    3e13:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    status == MPI_IOCSTATUS_EEDP_APP_TAG_ERROR) {
		/*
		 *  we want stm_target_cleanup to do everything except repost the
		 *  command buffer, so fake it out a bit
		 */
		*io_state |= IO_STATE_AUTO_REPOST;
    3e16:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
		stm_target_cleanup(priv, index);
    3e1c:	8b 7d f0             	mov    -0x10(%ebp),%edi
	    status == MPI_IOCSTATUS_EEDP_APP_TAG_ERROR) {
		/*
		 *  we want stm_target_cleanup to do everything except repost the
		 *  command buffer, so fake it out a bit
		 */
		*io_state |= IO_STATE_AUTO_REPOST;
    3e1f:	83 c8 20             	or     $0x20,%eax
    3e22:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
		stm_target_cleanup(priv, index);
    3e28:	89 fa                	mov    %edi,%edx
    3e2a:	89 f0                	mov    %esi,%eax
    3e2c:	e8 0f d8 ff ff       	call   1640 <stm_target_cleanup>
		*io_state = 0;

		cmd = priv->hw->cmd_buf + index;
		memset(cmd->rsp, 0, sizeof(cmd->rsp));
    3e31:	ba 40 00 00 00       	mov    $0x40,%edx
		 *  we want stm_target_cleanup to do everything except repost the
		 *  command buffer, so fake it out a bit
		 */
		*io_state |= IO_STATE_AUTO_REPOST;
		stm_target_cleanup(priv, index);
		*io_state = 0;
    3e36:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
    3e3d:	00 00 00 

		cmd = priv->hw->cmd_buf + index;
    3e40:	69 df f0 03 00 00    	imul   $0x3f0,%edi,%ebx
    3e46:	03 5e 20             	add    0x20(%esi),%ebx
		memset(cmd->rsp, 0, sizeof(cmd->rsp));
    3e49:	8d 7b 40             	lea    0x40(%ebx),%edi
    3e4c:	f7 c7 01 00 00 00    	test   $0x1,%edi
    3e52:	0f 85 50 03 00 00    	jne    41a8 <stmapp_target_error+0x478>
    3e58:	f7 c7 02 00 00 00    	test   $0x2,%edi
    3e5e:	0f 85 54 03 00 00    	jne    41b8 <stmapp_target_error+0x488>
    3e64:	89 d1                	mov    %edx,%ecx
    3e66:	31 c0                	xor    %eax,%eax
    3e68:	c1 e9 02             	shr    $0x2,%ecx
    3e6b:	f6 c2 02             	test   $0x2,%dl
    3e6e:	f3 ab                	rep stos %eax,%es:(%edi)
    3e70:	0f 85 9a 00 00 00    	jne    3f10 <stmapp_target_error+0x1e0>
    3e76:	83 e2 01             	and    $0x1,%edx
    3e79:	0f 85 89 00 00 00    	jne    3f08 <stmapp_target_error+0x1d8>

		switch (status) {
    3e7f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    3e82:	83 f8 22             	cmp    $0x22,%eax
    3e85:	77 39                	ja     3ec0 <stmapp_target_error+0x190>
    3e87:	ff 24 85 54 01 00 00 	jmp    *0x154(,%eax,4)
    3e8e:	66 90                	xchg   %ax,%ax
		case MPI_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH:
			printk(KERN_ERR MYNAM ":%s transfer count mismatch\n",
			       ioc->name);
    3e90:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		cmd = priv->hw->cmd_buf + index;
		memset(cmd->rsp, 0, sizeof(cmd->rsp));

		switch (status) {
		case MPI_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH:
			printk(KERN_ERR MYNAM ":%s transfer count mismatch\n",
    3e93:	c7 04 24 f4 09 00 00 	movl   $0x9f4,(%esp)
			       ioc->name);
    3e9a:	83 c0 08             	add    $0x8,%eax
    3e9d:	89 44 24 04          	mov    %eax,0x4(%esp)
		cmd = priv->hw->cmd_buf + index;
		memset(cmd->rsp, 0, sizeof(cmd->rsp));

		switch (status) {
		case MPI_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH:
			printk(KERN_ERR MYNAM ":%s transfer count mismatch\n",
    3ea1:	e8 fc ff ff ff       	call   3ea2 <stmapp_target_error+0x172>
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
    3ea6:	b9 4b 00 00 00       	mov    $0x4b,%ecx
    3eab:	89 da                	mov    %ebx,%edx
    3ead:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    3eb4:	89 f0                	mov    %esi,%eax
    3eb6:	e8 c5 ca ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
    3ebb:	90                   	nop
    3ebc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x10, 0x02);
			break;
		}

		stm_send_target_status(priv, reply_word, index, 0, lun, tag);
    3ec0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3ec3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    3ec6:	8b 55 e0             	mov    -0x20(%ebp),%edx
    3ec9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    3ed0:	89 44 24 08          	mov    %eax,0x8(%esp)
    3ed4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3ed7:	89 44 24 04          	mov    %eax,0x4(%esp)
    3edb:	89 f0                	mov    %esi,%eax
    3edd:	e8 de d0 ff ff       	call   fc0 <stm_send_target_status>
	}

	*io_state &= ~IO_STATE_AUTO_REPOST;
	stm_target_cleanup(priv, index);
	TRACE_EXIT();
}
    3ee2:	83 c4 24             	add    $0x24,%esp
    3ee5:	5b                   	pop    %ebx
    3ee6:	5e                   	pop    %esi
    3ee7:	5f                   	pop    %edi
    3ee8:	5d                   	pop    %ebp
    3ee9:	c3                   	ret    
    3eea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
{
	MPT_ADAPTER		*ioc = priv->ioc;
	volatile int	*io_state;
	CMD			*cmd;
	int			lun = 0;
	int			tag = 0;
    3ef0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
				int status, int reason)
{
	MPT_ADAPTER		*ioc = priv->ioc;
	volatile int	*io_state;
	CMD			*cmd;
	int			lun = 0;
    3ef7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    3efe:	e9 81 fe ff ff       	jmp    3d84 <stmapp_target_error+0x54>
    3f03:	90                   	nop
    3f04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		*io_state |= IO_STATE_AUTO_REPOST;
		stm_target_cleanup(priv, index);
		*io_state = 0;

		cmd = priv->hw->cmd_buf + index;
		memset(cmd->rsp, 0, sizeof(cmd->rsp));
    3f08:	c6 07 00             	movb   $0x0,(%edi)
    3f0b:	e9 6f ff ff ff       	jmp    3e7f <stmapp_target_error+0x14f>
    3f10:	31 c0                	xor    %eax,%eax
    3f12:	83 c7 02             	add    $0x2,%edi
    3f15:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    3f19:	83 e2 01             	and    $0x1,%edx
    3f1c:	0f 84 5d ff ff ff    	je     3e7f <stmapp_target_error+0x14f>
    3f22:	eb e4                	jmp    3f08 <stmapp_target_error+0x1d8>
    3f24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	 *  The IOC knows it can't send status and sense over a
	 *  traditional SCSI cable (if non-packetized), so we should
	 *  treat this as a successful completion, manually repost the
	 *  command to the IOC, and free the SCST command.
	 */
	if (IsScsi(priv) && (status == MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT)) {
    3f28:	83 f8 6b             	cmp    $0x6b,%eax
    3f2b:	0f 85 be fe ff ff    	jne    3def <stmapp_target_error+0xbf>
		if ((*io_state & IO_STATE_AUTO_REPOST) ||
    3f31:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    3f37:	a8 20                	test   $0x20,%al
    3f39:	75 0e                	jne    3f49 <stmapp_target_error+0x219>
		    (*io_state & IO_STATE_STATUS_SENT)) {
    3f3b:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	 *  traditional SCSI cable (if non-packetized), so we should
	 *  treat this as a successful completion, manually repost the
	 *  command to the IOC, and free the SCST command.
	 */
	if (IsScsi(priv) && (status == MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT)) {
		if ((*io_state & IO_STATE_AUTO_REPOST) ||
    3f41:	a8 04                	test   $0x4,%al
    3f43:	0f 84 a6 fe ff ff    	je     3def <stmapp_target_error+0xbf>
	TRACE_ENTRY();
	TRACE_DBG("%s target error, index %d, status %x, reason %x",
		  ioc->name, index, status, reason);

	io_state = priv->io_state + index;
	init_index = GET_INITIATOR_INDEX(reply_word);
    3f49:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3f4c:	25 00 c0 ff 03       	and    $0x3ffc000,%eax
    3f51:	c1 e8 0e             	shr    $0xe,%eax
	if (IsScsi(priv) && (status == MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT)) {
		if ((*io_state & IO_STATE_AUTO_REPOST) ||
		    (*io_state & IO_STATE_STATUS_SENT)) {
			/* if we know we were attempting to send status and sense
			 * simultaneously, indicate that we failed */
			if (atomic_read(&priv->pending_sense[init_index]) ==
    3f54:	8d 84 86 10 0e 00 00 	lea    0xe10(%esi,%eax,4),%eax
 *
 * Atomically reads the value of @v.
 */
static inline int atomic_read(const atomic_t *v)
{
	return (*(volatile int *)&(v)->counter);
    3f5b:	8b 10                	mov    (%eax),%edx
    3f5d:	83 fa 01             	cmp    $0x1,%edx
    3f60:	0f 84 2c 04 00 00    	je     4392 <stmapp_target_error+0x662>
			    MPT_STATUS_SENSE_ATTEMPT) {
				atomic_set(&priv->pending_sense[init_index],
					   MPT_STATUS_SENSE_NOT_SENT);
			}
			stm_tgt_reply(ioc, reply_word);
    3f66:	8b 55 e0             	mov    -0x20(%ebp),%edx
    3f69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	}

	*io_state &= ~IO_STATE_AUTO_REPOST;
	stm_target_cleanup(priv, index);
	TRACE_EXIT();
}
    3f6c:	83 c4 24             	add    $0x24,%esp
    3f6f:	5b                   	pop    %ebx
    3f70:	5e                   	pop    %esi
    3f71:	5f                   	pop    %edi
    3f72:	5d                   	pop    %ebp
			if (atomic_read(&priv->pending_sense[init_index]) ==
			    MPT_STATUS_SENSE_ATTEMPT) {
				atomic_set(&priv->pending_sense[init_index],
					   MPT_STATUS_SENSE_NOT_SENT);
			}
			stm_tgt_reply(ioc, reply_word);
    3f73:	e9 18 fa ff ff       	jmp    3990 <stm_tgt_reply>
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x0e, 0x01);
			break;
		case MPI_IOCSTATUS_EEDP_GUARD_ERROR:
			printk(KERN_ERR MYNAM ":%s EEDP Guard Error\n",
			       ioc->name);
    3f78:	8b 45 e4             	mov    -0x1c(%ebp),%eax
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x0e, 0x01);
			break;
		case MPI_IOCSTATUS_EEDP_GUARD_ERROR:
			printk(KERN_ERR MYNAM ":%s EEDP Guard Error\n",
    3f7b:	c7 04 24 64 0a 00 00 	movl   $0xa64,(%esp)
			       ioc->name);
    3f82:	83 c0 08             	add    $0x8,%eax
    3f85:	89 44 24 04          	mov    %eax,0x4(%esp)
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x0e, 0x01);
			break;
		case MPI_IOCSTATUS_EEDP_GUARD_ERROR:
			printk(KERN_ERR MYNAM ":%s EEDP Guard Error\n",
    3f89:	e8 fc ff ff ff       	call   3f8a <stmapp_target_error+0x25a>
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
    3f8e:	b9 10 00 00 00       	mov    $0x10,%ecx
    3f93:	89 da                	mov    %ebx,%edx
    3f95:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    3f9c:	89 f0                	mov    %esi,%eax
    3f9e:	e8 dd c9 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
					      SK_ABORTED_COMMAND, 0x10, 0x01);
			break;
    3fa3:	e9 18 ff ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
		case MPI_IOCSTATUS_EEDP_REF_TAG_ERROR:
			printk(KERN_ERR MYNAM ":%s EEDP Reference Tag Error\n",
			       ioc->name);
    3fa8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x10, 0x01);
			break;
		case MPI_IOCSTATUS_EEDP_REF_TAG_ERROR:
			printk(KERN_ERR MYNAM ":%s EEDP Reference Tag Error\n",
    3fab:	c7 04 24 84 0a 00 00 	movl   $0xa84,(%esp)
			       ioc->name);
    3fb2:	83 c0 08             	add    $0x8,%eax
    3fb5:	89 44 24 04          	mov    %eax,0x4(%esp)
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x10, 0x01);
			break;
		case MPI_IOCSTATUS_EEDP_REF_TAG_ERROR:
			printk(KERN_ERR MYNAM ":%s EEDP Reference Tag Error\n",
    3fb9:	e8 fc ff ff ff       	call   3fba <stmapp_target_error+0x28a>
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
    3fbe:	b9 10 00 00 00       	mov    $0x10,%ecx
    3fc3:	89 da                	mov    %ebx,%edx
    3fc5:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
    3fcc:	89 f0                	mov    %esi,%eax
    3fce:	e8 ad c9 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
					      SK_ABORTED_COMMAND, 0x10, 0x03);
			break;
    3fd3:	e9 e8 fe ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x4b, 0x00);
			break;
		case MPI_IOCSTATUS_TARGET_DATA_OFFSET_ERROR:
			printk(KERN_ERR MYNAM ":%s data offset error\n",
			       ioc->name);
    3fd8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x4b, 0x00);
			break;
		case MPI_IOCSTATUS_TARGET_DATA_OFFSET_ERROR:
			printk(KERN_ERR MYNAM ":%s data offset error\n",
    3fdb:	c7 04 24 1c 0a 00 00 	movl   $0xa1c,(%esp)
			       ioc->name);
    3fe2:	83 c0 08             	add    $0x8,%eax
    3fe5:	89 44 24 04          	mov    %eax,0x4(%esp)
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x4b, 0x00);
			break;
		case MPI_IOCSTATUS_TARGET_DATA_OFFSET_ERROR:
			printk(KERN_ERR MYNAM ":%s data offset error\n",
    3fe9:	e8 fc ff ff ff       	call   3fea <stmapp_target_error+0x2ba>
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
    3fee:	b9 4b 00 00 00       	mov    $0x4b,%ecx
    3ff3:	89 da                	mov    %ebx,%edx
    3ff5:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
    3ffc:	89 f0                	mov    %esi,%eax
    3ffe:	e8 7d c9 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
					      SK_ABORTED_COMMAND, 0x4b, 0x05);
			break;
    4003:	e9 b8 fe ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
		case MPI_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA:
			printk(KERN_ERR MYNAM ":%s too much write data\n",
			       ioc->name);
    4008:	8b 45 e4             	mov    -0x1c(%ebp),%eax
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x4b, 0x05);
			break;
		case MPI_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA:
			printk(KERN_ERR MYNAM ":%s too much write data\n",
    400b:	c7 04 24 40 0a 00 00 	movl   $0xa40,(%esp)
			       ioc->name);
    4012:	83 c0 08             	add    $0x8,%eax
    4015:	89 44 24 04          	mov    %eax,0x4(%esp)
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x4b, 0x05);
			break;
		case MPI_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA:
			printk(KERN_ERR MYNAM ":%s too much write data\n",
    4019:	e8 fc ff ff ff       	call   401a <stmapp_target_error+0x2ea>
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
    401e:	b9 4b 00 00 00       	mov    $0x4b,%ecx
    4023:	89 da                	mov    %ebx,%edx
    4025:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
    402c:	89 f0                	mov    %esi,%eax
    402e:	e8 4d c9 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
					      SK_ABORTED_COMMAND, 0x4b, 0x02);
			break;
    4033:	e9 88 fe ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
		case MPI_IOCSTATUS_TARGET_IU_TOO_SHORT:
			printk(KERN_ERR MYNAM ":%s IU too short\n",
			       ioc->name);
    4038:	8b 45 e4             	mov    -0x1c(%ebp),%eax
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x4b, 0x02);
			break;
		case MPI_IOCSTATUS_TARGET_IU_TOO_SHORT:
			printk(KERN_ERR MYNAM ":%s IU too short\n",
    403b:	c7 04 24 82 01 00 00 	movl   $0x182,(%esp)
			       ioc->name);
    4042:	83 c0 08             	add    $0x8,%eax
    4045:	89 44 24 04          	mov    %eax,0x4(%esp)
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x4b, 0x02);
			break;
		case MPI_IOCSTATUS_TARGET_IU_TOO_SHORT:
			printk(KERN_ERR MYNAM ":%s IU too short\n",
    4049:	e8 fc ff ff ff       	call   404a <stmapp_target_error+0x31a>
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
    404e:	b9 0e 00 00 00       	mov    $0xe,%ecx
    4053:	89 da                	mov    %ebx,%edx
    4055:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    405c:	89 f0                	mov    %esi,%eax
    405e:	e8 1d c9 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
					      SK_ABORTED_COMMAND, 0x0e, 0x01);
			break;
    4063:	e9 58 fe ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
	    status == MPI_IOCSTATUS_EEDP_APP_TAG_ERROR) {
		/*
		 *  we want stm_target_cleanup to do everything except repost the
		 *  command buffer, so fake it out a bit
		 */
		*io_state |= IO_STATE_AUTO_REPOST;
    4068:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
		stm_target_cleanup(priv, index);
    406e:	8b 7d f0             	mov    -0x10(%ebp),%edi
	    status == MPI_IOCSTATUS_EEDP_APP_TAG_ERROR) {
		/*
		 *  we want stm_target_cleanup to do everything except repost the
		 *  command buffer, so fake it out a bit
		 */
		*io_state |= IO_STATE_AUTO_REPOST;
    4071:	83 c8 20             	or     $0x20,%eax
    4074:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
		stm_target_cleanup(priv, index);
    407a:	89 fa                	mov    %edi,%edx
    407c:	89 f0                	mov    %esi,%eax
    407e:	e8 bd d5 ff ff       	call   1640 <stm_target_cleanup>
		*io_state = 0;

		cmd = priv->hw->cmd_buf + index;
		memset(cmd->rsp, 0, sizeof(cmd->rsp));
    4083:	ba 40 00 00 00       	mov    $0x40,%edx
		 *  we want stm_target_cleanup to do everything except repost the
		 *  command buffer, so fake it out a bit
		 */
		*io_state |= IO_STATE_AUTO_REPOST;
		stm_target_cleanup(priv, index);
		*io_state = 0;
    4088:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
    408f:	00 00 00 

		cmd = priv->hw->cmd_buf + index;
    4092:	69 df f0 03 00 00    	imul   $0x3f0,%edi,%ebx
    4098:	03 5e 20             	add    0x20(%esi),%ebx
		memset(cmd->rsp, 0, sizeof(cmd->rsp));
    409b:	8d 7b 40             	lea    0x40(%ebx),%edi
    409e:	f7 c7 01 00 00 00    	test   $0x1,%edi
    40a4:	0f 85 bb 02 00 00    	jne    4365 <stmapp_target_error+0x635>
    40aa:	f7 c7 02 00 00 00    	test   $0x2,%edi
    40b0:	0f 85 9e 02 00 00    	jne    4354 <stmapp_target_error+0x624>
    40b6:	89 d1                	mov    %edx,%ecx
    40b8:	31 c0                	xor    %eax,%eax
    40ba:	c1 e9 02             	shr    $0x2,%ecx
    40bd:	f6 c2 02             	test   $0x2,%dl
    40c0:	f3 ab                	rep stos %eax,%es:(%edi)
    40c2:	0f 85 10 01 00 00    	jne    41d8 <stmapp_target_error+0x4a8>
    40c8:	83 e2 01             	and    $0x1,%edx
    40cb:	0f 85 ff 00 00 00    	jne    41d0 <stmapp_target_error+0x4a0>
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x10, 0x03);
			break;
		case MPI_IOCSTATUS_EEDP_APP_TAG_ERROR:
			printk(KERN_ERR MYNAM ":%s EEDP Application Tag Error\n",
			       ioc->name);
    40d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x10, 0x03);
			break;
		case MPI_IOCSTATUS_EEDP_APP_TAG_ERROR:
			printk(KERN_ERR MYNAM ":%s EEDP Application Tag Error\n",
    40d4:	c7 04 24 ac 0a 00 00 	movl   $0xaac,(%esp)
			       ioc->name);
    40db:	83 c0 08             	add    $0x8,%eax
    40de:	89 44 24 04          	mov    %eax,0x4(%esp)
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
					      SK_ABORTED_COMMAND, 0x10, 0x03);
			break;
		case MPI_IOCSTATUS_EEDP_APP_TAG_ERROR:
			printk(KERN_ERR MYNAM ":%s EEDP Application Tag Error\n",
    40e2:	e8 fc ff ff ff       	call   40e3 <stmapp_target_error+0x3b3>
			       ioc->name);
			stmapp_set_sense_info(priv, cmd,
    40e7:	b9 10 00 00 00       	mov    $0x10,%ecx
    40ec:	89 da                	mov    %ebx,%edx
    40ee:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
    40f5:	89 f0                	mov    %esi,%eax
    40f7:	e8 84 c8 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
					      SK_ABORTED_COMMAND, 0x10, 0x02);
			break;
    40fc:	e9 bf fd ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
    4101:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	 *  we want stm_target_cleanup to do everything except repost the
	 *  command buffer, so fake it out a bit
	 */
	TRACE_ENTRY();
	io_state = priv->io_state + index;
	*io_state |= IO_STATE_AUTO_REPOST;
    4108:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
					     int index, int status, int reason,
					     int lun, int tag)
{
	MPT_ADAPTER		*ioc = priv->ioc;
	struct mpt_cmd *mpt_cmd;
	struct scst_cmd *scst_cmd;
    410e:	8b 7d f0             	mov    -0x10(%ebp),%edi
	 *  we want stm_target_cleanup to do everything except repost the
	 *  command buffer, so fake it out a bit
	 */
	TRACE_ENTRY();
	io_state = priv->io_state + index;
	*io_state |= IO_STATE_AUTO_REPOST;
    4111:	83 c8 20             	or     $0x20,%eax
    4114:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
					     int index, int status, int reason,
					     int lun, int tag)
{
	MPT_ADAPTER		*ioc = priv->ioc;
	struct mpt_cmd *mpt_cmd;
	struct scst_cmd *scst_cmd;
    411a:	8b 84 be 10 0c 00 00 	mov    0xc10(%esi,%edi,4),%eax
	*io_state |= IO_STATE_AUTO_REPOST;
	scst_cmd = priv->scst_cmd[index];
	mpt_cmd = (struct mpt_cmd *)scst_cmd_get_tgt_priv(scst_cmd);
	mpt_cmd->state = MPT_STATE_PROCESSED;

	stm_target_cleanup(priv, index);
    4121:	89 fa                	mov    %edi,%edx
					     int index, int status, int reason,
					     int lun, int tag)
{
	MPT_ADAPTER		*ioc = priv->ioc;
	struct mpt_cmd *mpt_cmd;
	struct scst_cmd *scst_cmd;
    4123:	8b 80 44 01 00 00    	mov    0x144(%eax),%eax
	TRACE_ENTRY();
	io_state = priv->io_state + index;
	*io_state |= IO_STATE_AUTO_REPOST;
	scst_cmd = priv->scst_cmd[index];
	mpt_cmd = (struct mpt_cmd *)scst_cmd_get_tgt_priv(scst_cmd);
	mpt_cmd->state = MPT_STATE_PROCESSED;
    4129:	c7 40 1c 05 00 00 00 	movl   $0x5,0x1c(%eax)

	stm_target_cleanup(priv, index);
    4130:	89 f0                	mov    %esi,%eax
    4132:	e8 09 d5 ff ff       	call   1640 <stm_target_cleanup>
	*io_state = IO_STATE_HIGH_PRIORITY;
    4137:	c7 83 a0 00 00 00 80 	movl   $0x80,0xa0(%ebx)
    413e:	00 00 00 
	printk(KERN_ERR MYNAM ": HIGH_PRIORITY %s\n", __func__);

	cmd = priv->hw->cmd_buf + index;
    4141:	69 df f0 03 00 00    	imul   $0x3f0,%edi,%ebx
	mpt_cmd = (struct mpt_cmd *)scst_cmd_get_tgt_priv(scst_cmd);
	mpt_cmd->state = MPT_STATE_PROCESSED;

	stm_target_cleanup(priv, index);
	*io_state = IO_STATE_HIGH_PRIORITY;
	printk(KERN_ERR MYNAM ": HIGH_PRIORITY %s\n", __func__);
    4147:	c7 44 24 04 c0 02 00 	movl   $0x2c0,0x4(%esp)
    414e:	00 
    414f:	c7 04 24 64 01 00 00 	movl   $0x164,(%esp)
    4156:	e8 fc ff ff ff       	call   4157 <stmapp_target_error+0x427>

	cmd = priv->hw->cmd_buf + index;
	memset(cmd->rsp, 0, sizeof(cmd->rsp));
    415b:	ba 40 00 00 00       	mov    $0x40,%edx

	stm_target_cleanup(priv, index);
	*io_state = IO_STATE_HIGH_PRIORITY;
	printk(KERN_ERR MYNAM ": HIGH_PRIORITY %s\n", __func__);

	cmd = priv->hw->cmd_buf + index;
    4160:	03 5e 20             	add    0x20(%esi),%ebx
	memset(cmd->rsp, 0, sizeof(cmd->rsp));
    4163:	8d 7b 40             	lea    0x40(%ebx),%edi
    4166:	f7 c7 01 00 00 00    	test   $0x1,%edi
    416c:	0f 85 12 02 00 00    	jne    4384 <stmapp_target_error+0x654>
    4172:	f7 c7 02 00 00 00    	test   $0x2,%edi
    4178:	0f 85 f5 01 00 00    	jne    4373 <stmapp_target_error+0x643>
    417e:	89 d1                	mov    %edx,%ecx
    4180:	31 c0                	xor    %eax,%eax
    4182:	c1 e9 02             	shr    $0x2,%ecx
    4185:	f6 c2 02             	test   $0x2,%dl
    4188:	f3 ab                	rep stos %eax,%es:(%edi)
    418a:	75 64                	jne    41f0 <stmapp_target_error+0x4c0>
    418c:	83 e2 01             	and    $0x1,%edx
    418f:	75 57                	jne    41e8 <stmapp_target_error+0x4b8>

	switch (reason) {
    4191:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4194:	83 f8 08             	cmp    $0x8,%eax
    4197:	0f 87 83 01 00 00    	ja     4320 <stmapp_target_error+0x5f0>
    419d:	ff 24 85 e0 01 00 00 	jmp    *0x1e0(,%eax,4)
    41a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		*io_state |= IO_STATE_AUTO_REPOST;
		stm_target_cleanup(priv, index);
		*io_state = 0;

		cmd = priv->hw->cmd_buf + index;
		memset(cmd->rsp, 0, sizeof(cmd->rsp));
    41a8:	c6 43 40 00          	movb   $0x0,0x40(%ebx)
    41ac:	8d 7b 41             	lea    0x41(%ebx),%edi
    41af:	b2 3f                	mov    $0x3f,%dl
    41b1:	e9 a2 fc ff ff       	jmp    3e58 <stmapp_target_error+0x128>
    41b6:	66 90                	xchg   %ax,%ax
    41b8:	31 c0                	xor    %eax,%eax
    41ba:	83 c7 02             	add    $0x2,%edi
    41bd:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    41c1:	83 ea 02             	sub    $0x2,%edx
    41c4:	e9 9b fc ff ff       	jmp    3e64 <stmapp_target_error+0x134>
    41c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    41d0:	c6 07 00             	movb   $0x0,(%edi)
    41d3:	e9 f9 fe ff ff       	jmp    40d1 <stmapp_target_error+0x3a1>
    41d8:	31 c0                	xor    %eax,%eax
    41da:	83 c7 02             	add    $0x2,%edi
    41dd:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    41e1:	e9 e2 fe ff ff       	jmp    40c8 <stmapp_target_error+0x398>
    41e6:	66 90                	xchg   %ax,%ax
	stm_target_cleanup(priv, index);
	*io_state = IO_STATE_HIGH_PRIORITY;
	printk(KERN_ERR MYNAM ": HIGH_PRIORITY %s\n", __func__);

	cmd = priv->hw->cmd_buf + index;
	memset(cmd->rsp, 0, sizeof(cmd->rsp));
    41e8:	c6 07 00             	movb   $0x0,(%edi)
    41eb:	eb a4                	jmp    4191 <stmapp_target_error+0x461>
    41ed:	8d 76 00             	lea    0x0(%esi),%esi
    41f0:	31 c0                	xor    %eax,%eax
    41f2:	83 c7 02             	add    $0x2,%edi
    41f5:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    41f9:	eb 91                	jmp    418c <stmapp_target_error+0x45c>
    41fb:	90                   	nop
    41fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				      SK_ABORTED_COMMAND, 0x47, 0x02);
		break;
	case PRIORITY_REASON_DATA_OUT_CRC_ERR:
		printk(KERN_ERR MYNAM ":%s "
		       "detected CRC error during Data Out phase\n",
		       ioc->name);
    4200:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x47, 0x02);
		break;
	case PRIORITY_REASON_DATA_OUT_CRC_ERR:
		printk(KERN_ERR MYNAM ":%s "
    4203:	c7 04 24 90 09 00 00 	movl   $0x990,(%esp)
		       "detected CRC error during Data Out phase\n",
		       ioc->name);
    420a:	83 c0 08             	add    $0x8,%eax
    420d:	89 44 24 04          	mov    %eax,0x4(%esp)
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x47, 0x02);
		break;
	case PRIORITY_REASON_DATA_OUT_CRC_ERR:
		printk(KERN_ERR MYNAM ":%s "
    4211:	e8 fc ff ff ff       	call   4212 <stmapp_target_error+0x4e2>
		       "detected CRC error during Data Out phase\n",
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
    4216:	b9 47 00 00 00       	mov    $0x47,%ecx
    421b:	89 da                	mov    %ebx,%edx
    421d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    4224:	89 f0                	mov    %esi,%eax
    4226:	e8 55 c7 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
    422b:	e9 90 fc ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
				      SK_ABORTED_COMMAND, 0x48, 0x00);
		break;
	case PRIORITY_REASON_DATA_OUT_PARITY_ERR:
		printk(KERN_ERR MYNAM ":%s "
		       "detected parity error during Data Out phase\n",
		       ioc->name);
    4230:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x48, 0x00);
		break;
	case PRIORITY_REASON_DATA_OUT_PARITY_ERR:
		printk(KERN_ERR MYNAM ":%s "
    4233:	c7 04 24 54 09 00 00 	movl   $0x954,(%esp)
		       "detected parity error during Data Out phase\n",
		       ioc->name);
    423a:	83 c0 08             	add    $0x8,%eax
    423d:	89 44 24 04          	mov    %eax,0x4(%esp)
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x48, 0x00);
		break;
	case PRIORITY_REASON_DATA_OUT_PARITY_ERR:
		printk(KERN_ERR MYNAM ":%s "
    4241:	e8 fc ff ff ff       	call   4242 <stmapp_target_error+0x512>
		       "detected parity error during Data Out phase\n",
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
    4246:	b9 47 00 00 00       	mov    $0x47,%ecx
    424b:	89 da                	mov    %ebx,%edx
    424d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
    4254:	89 f0                	mov    %esi,%eax
    4256:	e8 25 c7 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
    425b:	e9 60 fc ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
				      SK_ABORTED_COMMAND, 0x47, 0x03);
		break;
	case PRIORITY_REASON_PROTOCOL_ERR:
		printk(KERN_ERR MYNAM ":%s "
		       "received Initiator Detected Error message\n",
		       ioc->name);
    4260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x47, 0x03);
		break;
	case PRIORITY_REASON_PROTOCOL_ERR:
		printk(KERN_ERR MYNAM ":%s "
    4263:	c7 04 24 18 09 00 00 	movl   $0x918,(%esp)
		       "received Initiator Detected Error message\n",
		       ioc->name);
    426a:	83 c0 08             	add    $0x8,%eax
    426d:	89 44 24 04          	mov    %eax,0x4(%esp)
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x47, 0x03);
		break;
	case PRIORITY_REASON_PROTOCOL_ERR:
		printk(KERN_ERR MYNAM ":%s "
    4271:	e8 fc ff ff ff       	call   4272 <stmapp_target_error+0x542>
		       "received Initiator Detected Error message\n",
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
    4276:	b9 48 00 00 00       	mov    $0x48,%ecx
    427b:	89 da                	mov    %ebx,%edx
    427d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    4284:	89 f0                	mov    %esi,%eax
    4286:	e8 f5 c6 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
    428b:	e9 30 fc ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
				      SK_ABORTED_COMMAND, 0x43, 0x00);
		break;
	case PRIORITY_REASON_CMD_CRC_ERR:
		printk(KERN_ERR MYNAM ":%s "
		       "detected CRC error while receiving CMD_IU\n",
		       ioc->name);
    4290:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x43, 0x00);
		break;
	case PRIORITY_REASON_CMD_CRC_ERR:
		printk(KERN_ERR MYNAM ":%s "
    4293:	c7 04 24 dc 08 00 00 	movl   $0x8dc,(%esp)
		       "detected CRC error while receiving CMD_IU\n",
		       ioc->name);
    429a:	83 c0 08             	add    $0x8,%eax
    429d:	89 44 24 04          	mov    %eax,0x4(%esp)
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x43, 0x00);
		break;
	case PRIORITY_REASON_CMD_CRC_ERR:
		printk(KERN_ERR MYNAM ":%s "
    42a1:	e8 fc ff ff ff       	call   42a2 <stmapp_target_error+0x572>
		       "detected CRC error while receiving CMD_IU\n",
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
    42a6:	b9 47 00 00 00       	mov    $0x47,%ecx
    42ab:	89 da                	mov    %ebx,%edx
    42ad:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
    42b4:	89 f0                	mov    %esi,%eax
    42b6:	e8 c5 c6 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
    42bb:	e9 00 fc ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
				      SK_ABORTED_COMMAND, 0x47, 0x00);
		break;
	case PRIORITY_REASON_MSG_OUT_PARITY_ERR:
		printk(KERN_ERR MYNAM ":%s "
		       "detected parity error during Message Out phase\n",
		       ioc->name);
    42c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x47, 0x00);
		break;
	case PRIORITY_REASON_MSG_OUT_PARITY_ERR:
		printk(KERN_ERR MYNAM ":%s "
    42c3:	c7 04 24 9c 08 00 00 	movl   $0x89c,(%esp)
		       "detected parity error during Message Out phase\n",
		       ioc->name);
    42ca:	83 c0 08             	add    $0x8,%eax
    42cd:	89 44 24 04          	mov    %eax,0x4(%esp)
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x47, 0x00);
		break;
	case PRIORITY_REASON_MSG_OUT_PARITY_ERR:
		printk(KERN_ERR MYNAM ":%s "
    42d1:	e8 fc ff ff ff       	call   42d2 <stmapp_target_error+0x5a2>
		       "detected parity error during Message Out phase\n",
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
    42d6:	b9 43 00 00 00       	mov    $0x43,%ecx
    42db:	89 da                	mov    %ebx,%edx
    42dd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    42e4:	89 f0                	mov    %esi,%eax
    42e6:	e8 95 c6 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
    42eb:	e9 d0 fb ff ff       	jmp    3ec0 <stmapp_target_error+0x190>

	switch (reason) {
	case PRIORITY_REASON_CMD_PARITY_ERR:
		printk(KERN_ERR MYNAM ":%s "
		       "detected parity error during Command phase\n",
		       ioc->name);
    42f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	cmd = priv->hw->cmd_buf + index;
	memset(cmd->rsp, 0, sizeof(cmd->rsp));

	switch (reason) {
	case PRIORITY_REASON_CMD_PARITY_ERR:
		printk(KERN_ERR MYNAM ":%s "
    42f3:	c7 04 24 60 08 00 00 	movl   $0x860,(%esp)
		       "detected parity error during Command phase\n",
		       ioc->name);
    42fa:	83 c0 08             	add    $0x8,%eax
    42fd:	89 44 24 04          	mov    %eax,0x4(%esp)
	cmd = priv->hw->cmd_buf + index;
	memset(cmd->rsp, 0, sizeof(cmd->rsp));

	switch (reason) {
	case PRIORITY_REASON_CMD_PARITY_ERR:
		printk(KERN_ERR MYNAM ":%s "
    4301:	e8 fc ff ff ff       	call   4302 <stmapp_target_error+0x5d2>
		       "detected parity error during Command phase\n",
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
    4306:	b9 47 00 00 00       	mov    $0x47,%ecx
    430b:	89 da                	mov    %ebx,%edx
    430d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    4314:	89 f0                	mov    %esi,%eax
    4316:	e8 65 c6 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
    431b:	e9 a0 fb ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x47, 0x01);
		break;
	default:
		printk(KERN_ERR MYNAM ":%s unknown PriorityReason = %x\n",
    4320:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4323:	c7 04 24 c8 09 00 00 	movl   $0x9c8,(%esp)
    432a:	89 44 24 08          	mov    %eax,0x8(%esp)
		       ioc->name, reason);
    432e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4331:	83 c0 08             	add    $0x8,%eax
    4334:	89 44 24 04          	mov    %eax,0x4(%esp)
		       ioc->name);
		stmapp_set_sense_info(priv, cmd,
				      SK_ABORTED_COMMAND, 0x47, 0x01);
		break;
	default:
		printk(KERN_ERR MYNAM ":%s unknown PriorityReason = %x\n",
    4338:	e8 fc ff ff ff       	call   4339 <stmapp_target_error+0x609>
		       ioc->name, reason);
		stmapp_set_sense_info(priv, cmd,
    433d:	31 c9                	xor    %ecx,%ecx
    433f:	89 da                	mov    %ebx,%edx
    4341:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    4348:	89 f0                	mov    %esi,%eax
    434a:	e8 31 c6 ff ff       	call   980 <stmapp_set_sense_info.constprop.55>
    434f:	e9 6c fb ff ff       	jmp    3ec0 <stmapp_target_error+0x190>
		*io_state |= IO_STATE_AUTO_REPOST;
		stm_target_cleanup(priv, index);
		*io_state = 0;

		cmd = priv->hw->cmd_buf + index;
		memset(cmd->rsp, 0, sizeof(cmd->rsp));
    4354:	31 c9                	xor    %ecx,%ecx
    4356:	83 c7 02             	add    $0x2,%edi
    4359:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    435d:	83 ea 02             	sub    $0x2,%edx
    4360:	e9 51 fd ff ff       	jmp    40b6 <stmapp_target_error+0x386>
    4365:	c6 43 40 00          	movb   $0x0,0x40(%ebx)
    4369:	8d 7b 41             	lea    0x41(%ebx),%edi
    436c:	b2 3f                	mov    $0x3f,%dl
    436e:	e9 37 fd ff ff       	jmp    40aa <stmapp_target_error+0x37a>
	stm_target_cleanup(priv, index);
	*io_state = IO_STATE_HIGH_PRIORITY;
	printk(KERN_ERR MYNAM ": HIGH_PRIORITY %s\n", __func__);

	cmd = priv->hw->cmd_buf + index;
	memset(cmd->rsp, 0, sizeof(cmd->rsp));
    4373:	31 c0                	xor    %eax,%eax
    4375:	83 c7 02             	add    $0x2,%edi
    4378:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    437c:	83 ea 02             	sub    $0x2,%edx
    437f:	e9 fa fd ff ff       	jmp    417e <stmapp_target_error+0x44e>
    4384:	c6 43 40 00          	movb   $0x0,0x40(%ebx)
    4388:	8d 7b 41             	lea    0x41(%ebx),%edi
    438b:	b2 3f                	mov    $0x3f,%dl
    438d:	e9 e0 fd ff ff       	jmp    4172 <stmapp_target_error+0x442>
 *
 * Atomically sets the value of @v to @i.
 */
static inline void atomic_set(atomic_t *v, int i)
{
	v->counter = i;
    4392:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    4398:	e9 c9 fb ff ff       	jmp    3f66 <stmapp_target_error+0x236>
    439d:	8d 76 00             	lea    0x0(%esi),%esi

000043a0 <stm_target_reply_error>:
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_target_reply_error(MPT_ADAPTER *ioc, TargetErrorReply_t *rep)
{
    43a0:	55                   	push   %ebp
    43a1:	89 e5                	mov    %esp,%ebp
    43a3:	57                   	push   %edi
    43a4:	56                   	push   %esi
    43a5:	53                   	push   %ebx
    43a6:	83 ec 38             	sub    $0x38,%esp
    43a9:	e8 fc ff ff ff       	call   43aa <stm_target_reply_error+0xa>

	if (status == MPI_IOCSTATUS_TARGET_PRIORITY_IO) {
		reason = rep->PriorityReason;
		*io_state |= IO_STATE_HIGH_PRIORITY;
	} else {
		reason = 0;
    43ae:	31 c9                	xor    %ecx,%ecx
	TRACE_EXIT();
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stm_target_reply_error(MPT_ADAPTER *ioc, TargetErrorReply_t *rep)
{
    43b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	MPT_STM_PRIV	*priv = mpt_stm_priv[ioc->id];
    43b3:	8b 00                	mov    (%eax),%eax
    43b5:	8b 34 85 20 00 00 00 	mov    0x20(,%eax,4),%esi
	int			status;
	int			reason;
	volatile int	*io_state;

	TRACE_ENTRY();
	reply_word = le32_to_cpu(rep->ReplyWord);
    43bc:	8b 42 14             	mov    0x14(%edx),%eax
    43bf:	89 c7                	mov    %eax,%edi
    43c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
	status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
    43c4:	0f b7 42 0e          	movzwl 0xe(%edx),%eax

	index = GET_IO_INDEX(reply_word);
    43c8:	81 e7 ff 3f 00 00    	and    $0x3fff,%edi
    43ce:	89 7d f0             	mov    %edi,-0x10(%ebp)
	int			reason;
	volatile int	*io_state;

	TRACE_ENTRY();
	reply_word = le32_to_cpu(rep->ReplyWord);
	status = le16_to_cpu(rep->IOCStatus) & MPI_IOCSTATUS_MASK;
    43d1:	25 ff 7f 00 00       	and    $0x7fff,%eax

	index = GET_IO_INDEX(reply_word);

	io_state = priv->io_state + index;

	if (status == MPI_IOCSTATUS_TARGET_PRIORITY_IO) {
    43d6:	83 f8 60             	cmp    $0x60,%eax
    43d9:	0f 84 e9 00 00 00    	je     44c8 <stm_target_reply_error+0x128>
    43df:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    43e2:	8d 1c 9e             	lea    (%esi,%ebx,4),%ebx

	TRACE_DBG("%s: target reply error", ioc->name);
	TRACE_DBG("%s: ReplyWord = %08x, IOCStatus = %04x",
		  ioc->name, reply_word, status);

	if (*io_state & IO_STATE_REQUEST_ABORTED) {
    43e5:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
    43eb:	80 e6 01             	and    $0x1,%dh
    43ee:	0f 84 b4 00 00 00    	je     44a8 <stm_target_reply_error+0x108>
		TRACE_DBG("%s: index %d: io_state = %x",
			  ioc->name, index, *io_state);
		TRACE_DBG("%s:   request was aborted", ioc->name);
		*io_state &= ~IO_STATE_REQUEST_ABORTED;
    43f4:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
    43fa:	80 e6 fe             	and    $0xfe,%dh
    43fd:	89 93 a0 00 00 00    	mov    %edx,0xa0(%ebx)
		if (*io_state & IO_STATE_REISSUE_REQUEST) {
    4403:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
    4409:	80 e6 02             	and    $0x2,%dh
    440c:	0f 84 96 00 00 00    	je     44a8 <stm_target_reply_error+0x108>
			*io_state &= ~IO_STATE_REISSUE_REQUEST;
    4412:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    4418:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    441b:	80 e4 fd             	and    $0xfd,%ah
    441e:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
			TRACE_DBG("%s:   being reissued", ioc->name);
			if (*io_state & IO_STATE_ADJUST_OFFSET) {
    4424:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    442a:	81 c1 e8 00 00 00    	add    $0xe8,%ecx
    4430:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    4433:	f6 c4 04             	test   $0x4,%ah
    4436:	0f 85 5c 01 00 00    	jne    4598 <stm_target_reply_error+0x1f8>
				*io_state &= ~IO_STATE_ADJUST_OFFSET;
				stmapp_srr_adjust_offset(priv, index);
			}
			if (*io_state & IO_STATE_CONVERT_TA_TO_TSS) {
    443c:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    4442:	f6 c4 08             	test   $0x8,%ah
				*io_state &= ~IO_STATE_CONVERT_TA_TO_TSS;
    4445:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
			TRACE_DBG("%s:   being reissued", ioc->name);
			if (*io_state & IO_STATE_ADJUST_OFFSET) {
				*io_state &= ~IO_STATE_ADJUST_OFFSET;
				stmapp_srr_adjust_offset(priv, index);
			}
			if (*io_state & IO_STATE_CONVERT_TA_TO_TSS) {
    444b:	0f 85 b7 00 00 00    	jne    4508 <stm_target_reply_error+0x168>
				*io_state &= ~IO_STATE_CONVERT_TA_TO_TSS;
				stmapp_srr_convert_ta_to_tss(priv, index);
				goto out;
			}
			if (*io_state & IO_STATE_REDO_COMMAND) {
    4451:	f6 c4 10             	test   $0x10,%ah
    4454:	0f 84 8e 00 00 00    	je     44e8 <stm_target_reply_error+0x148>
				*io_state &= ~IO_STATE_REDO_COMMAND;
    445a:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    4460:	80 e4 ef             	and    $0xef,%ah
    4463:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
				*io_state &= ~IO_STATE_DATA_SENT;
    4469:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    446f:	83 e0 fd             	and    $0xfffffffd,%eax
    4472:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
				*io_state &= ~IO_STATE_STATUS_SENT;
    4478:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    447e:	83 e0 fb             	and    $0xfffffffb,%eax
    4481:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
				mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    4487:	8b 45 dc             	mov    -0x24(%ebp),%eax
    448a:	8b 14 86             	mov    (%esi,%eax,4),%edx
    448d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4490:	e8 fc ff ff ff       	call   4491 <stm_target_reply_error+0xf1>
				stmapp_tgt_command(priv, reply_word);
    4495:	8b 55 ec             	mov    -0x14(%ebp),%edx
	}

	stmapp_target_error(priv, reply_word, index, status, reason);
out:
	TRACE_EXIT();
}
    4498:	83 c4 38             	add    $0x38,%esp
    449b:	5b                   	pop    %ebx
			if (*io_state & IO_STATE_REDO_COMMAND) {
				*io_state &= ~IO_STATE_REDO_COMMAND;
				*io_state &= ~IO_STATE_DATA_SENT;
				*io_state &= ~IO_STATE_STATUS_SENT;
				mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
				stmapp_tgt_command(priv, reply_word);
    449c:	89 f0                	mov    %esi,%eax
	}

	stmapp_target_error(priv, reply_word, index, status, reason);
out:
	TRACE_EXIT();
}
    449e:	5e                   	pop    %esi
    449f:	5f                   	pop    %edi
    44a0:	5d                   	pop    %ebp
			if (*io_state & IO_STATE_REDO_COMMAND) {
				*io_state &= ~IO_STATE_REDO_COMMAND;
				*io_state &= ~IO_STATE_DATA_SENT;
				*io_state &= ~IO_STATE_STATUS_SENT;
				mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
				stmapp_tgt_command(priv, reply_word);
    44a1:	e9 3a eb ff ff       	jmp    2fe0 <stmapp_tgt_command>
    44a6:	66 90                	xchg   %ax,%ax
			mpt_put_msg_frame(stm_context, _IOC_ID, priv->current_mf[index]);
			goto out;
		}
	}

	stmapp_target_error(priv, reply_word, index, status, reason);
    44a8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    44ac:	8b 55 ec             	mov    -0x14(%ebp),%edx
    44af:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    44b2:	89 04 24             	mov    %eax,(%esp)
    44b5:	89 f0                	mov    %esi,%eax
    44b7:	e8 74 f8 ff ff       	call   3d30 <stmapp_target_error>
out:
	TRACE_EXIT();
}
    44bc:	83 c4 38             	add    $0x38,%esp
    44bf:	5b                   	pop    %ebx
    44c0:	5e                   	pop    %esi
    44c1:	5f                   	pop    %edi
    44c2:	5d                   	pop    %ebp
    44c3:	c3                   	ret    
    44c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    44c8:	8d 1c be             	lea    (%esi,%edi,4),%ebx
	index = GET_IO_INDEX(reply_word);

	io_state = priv->io_state + index;

	if (status == MPI_IOCSTATUS_TARGET_PRIORITY_IO) {
		reason = rep->PriorityReason;
    44cb:	0f b6 4a 0c          	movzbl 0xc(%edx),%ecx
		*io_state |= IO_STATE_HIGH_PRIORITY;
    44cf:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
    44d5:	80 ca 80             	or     $0x80,%dl
    44d8:	89 93 a0 00 00 00    	mov    %edx,0xa0(%ebx)
    44de:	e9 fc fe ff ff       	jmp    43df <stm_target_reply_error+0x3f>
    44e3:	90                   	nop
    44e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				*io_state &= ~IO_STATE_STATUS_SENT;
				mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
				stmapp_tgt_command(priv, reply_word);
				goto out;
			}
			mpt_put_msg_frame(stm_context, _IOC_ID, priv->current_mf[index]);
    44e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    44eb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    44ee:	8b 0c 86             	mov    (%esi,%eax,4),%ecx
    44f1:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
	}

	stmapp_target_error(priv, reply_word, index, status, reason);
out:
	TRACE_EXIT();
}
    44f8:	83 c4 38             	add    $0x38,%esp
    44fb:	5b                   	pop    %ebx
    44fc:	5e                   	pop    %esi
    44fd:	5f                   	pop    %edi
    44fe:	5d                   	pop    %ebp
				*io_state &= ~IO_STATE_STATUS_SENT;
				mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
				stmapp_tgt_command(priv, reply_word);
				goto out;
			}
			mpt_put_msg_frame(stm_context, _IOC_ID, priv->current_mf[index]);
    44ff:	e9 fc ff ff ff       	jmp    4500 <stm_target_reply_error+0x160>
    4504:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int			flags;

	TRACE_ENTRY();
	io_state = priv->io_state + index;

	cmd = priv->hw->cmd_buf + index;
    4508:	69 55 f0 f0 03 00 00 	imul   $0x3f0,-0x10(%ebp),%edx
			if (*io_state & IO_STATE_ADJUST_OFFSET) {
				*io_state &= ~IO_STATE_ADJUST_OFFSET;
				stmapp_srr_adjust_offset(priv, index);
			}
			if (*io_state & IO_STATE_CONVERT_TA_TO_TSS) {
				*io_state &= ~IO_STATE_CONVERT_TA_TO_TSS;
    450f:	80 e4 f7             	and    $0xf7,%ah
    4512:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static void stmapp_srr_convert_ta_to_tss(MPT_STM_PRIV *priv, int index)
{
	MPT_ADAPTER		*ioc = priv->ioc;
    4518:	8b 06                	mov    (%esi),%eax
	int			flags;

	TRACE_ENTRY();
	io_state = priv->io_state + index;

	cmd = priv->hw->cmd_buf + index;
    451a:	03 56 20             	add    0x20(%esi),%edx

	reply_word = cmd->reply_word;
    451d:	8b ba e0 03 00 00    	mov    0x3e0(%edx),%edi
	lun = cmd->lun;
	tag = cmd->tag;
    4523:	8b 8a ec 03 00 00    	mov    0x3ec(%edx),%ecx
	TRACE_ENTRY();
	io_state = priv->io_state + index;

	cmd = priv->hw->cmd_buf + index;

	reply_word = cmd->reply_word;
    4529:	89 7d ec             	mov    %edi,-0x14(%ebp)
	lun = cmd->lun;
    452c:	8b ba e8 03 00 00    	mov    0x3e8(%edx),%edi
	tag = cmd->tag;

	*io_state &= ~IO_STATE_DATA_SENT;
    4532:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx

	cmd = priv->hw->cmd_buf + index;

	reply_word = cmd->reply_word;
	lun = cmd->lun;
	tag = cmd->tag;
    4538:	89 4d e8             	mov    %ecx,-0x18(%ebp)

	*io_state &= ~IO_STATE_DATA_SENT;
	*io_state &= ~IO_STATE_STATUS_SENT;
	mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    453b:	8b 4d dc             	mov    -0x24(%ebp),%ecx

	reply_word = cmd->reply_word;
	lun = cmd->lun;
	tag = cmd->tag;

	*io_state &= ~IO_STATE_DATA_SENT;
    453e:	83 e2 fd             	and    $0xfffffffd,%edx
    4541:	89 93 a0 00 00 00    	mov    %edx,0xa0(%ebx)
	*io_state &= ~IO_STATE_STATUS_SENT;
    4547:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
    454d:	83 e2 fb             	and    $0xfffffffb,%edx
    4550:	89 93 a0 00 00 00    	mov    %edx,0xa0(%ebx)
	mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
    4556:	8b 14 8e             	mov    (%esi,%ecx,4),%edx
    4559:	e8 fc ff ff ff       	call   455a <stm_target_reply_error+0x1ba>

	flags = TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS;
	if (*io_state & IO_STATE_AUTO_REPOST)
    455e:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
		flags |= TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER;
	stm_send_target_status(priv, reply_word, index, flags, lun, tag);
    4564:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    4567:	8b 55 ec             	mov    -0x14(%ebp),%edx
    456a:	89 7c 24 04          	mov    %edi,0x4(%esp)
	*io_state &= ~IO_STATE_DATA_SENT;
	*io_state &= ~IO_STATE_STATUS_SENT;
	mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);

	flags = TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS;
	if (*io_state & IO_STATE_AUTO_REPOST)
    456e:	83 e0 20             	and    $0x20,%eax

	*io_state &= ~IO_STATE_DATA_SENT;
	*io_state &= ~IO_STATE_STATUS_SENT;
	mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);

	flags = TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS;
    4571:	83 f8 01             	cmp    $0x1,%eax
    4574:	19 c0                	sbb    %eax,%eax
	if (*io_state & IO_STATE_AUTO_REPOST)
		flags |= TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER;
	stm_send_target_status(priv, reply_word, index, flags, lun, tag);
    4576:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    457a:	8b 4d f0             	mov    -0x10(%ebp),%ecx

	*io_state &= ~IO_STATE_DATA_SENT;
	*io_state &= ~IO_STATE_STATUS_SENT;
	mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);

	flags = TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS;
    457d:	83 e0 80             	and    $0xffffff80,%eax
    4580:	05 81 00 00 00       	add    $0x81,%eax
	if (*io_state & IO_STATE_AUTO_REPOST)
		flags |= TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER;
	stm_send_target_status(priv, reply_word, index, flags, lun, tag);
    4585:	89 04 24             	mov    %eax,(%esp)
    4588:	89 f0                	mov    %esi,%eax
    458a:	e8 31 ca ff ff       	call   fc0 <stm_send_target_status>
	}

	stmapp_target_error(priv, reply_word, index, status, reason);
out:
	TRACE_EXIT();
}
    458f:	83 c4 38             	add    $0x38,%esp
    4592:	5b                   	pop    %ebx
    4593:	5e                   	pop    %esi
    4594:	5f                   	pop    %edi
    4595:	5d                   	pop    %ebp
    4596:	c3                   	ret    
    4597:	90                   	nop
		*io_state &= ~IO_STATE_REQUEST_ABORTED;
		if (*io_state & IO_STATE_REISSUE_REQUEST) {
			*io_state &= ~IO_STATE_REISSUE_REQUEST;
			TRACE_DBG("%s:   being reissued", ioc->name);
			if (*io_state & IO_STATE_ADJUST_OFFSET) {
				*io_state &= ~IO_STATE_ADJUST_OFFSET;
    4598:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	old_offset = le32_to_cpu(req->RelativeOffset);

	/* walk the SGL, skipping along until we get to the right offset */
	offset = old_offset;
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	n = 0;
    459e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	TargetAssistRequest_t	*req;
	u32				old_offset;
	u32				new_offset = 0;
	u32				offset;
	MPT_STM_SIMPLE		*sge_simple;
	MPT_STM_CHAIN		*sge_chain = NULL;
    45a5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		*io_state &= ~IO_STATE_REQUEST_ABORTED;
		if (*io_state & IO_STATE_REISSUE_REQUEST) {
			*io_state &= ~IO_STATE_REISSUE_REQUEST;
			TRACE_DBG("%s:   being reissued", ioc->name);
			if (*io_state & IO_STATE_ADJUST_OFFSET) {
				*io_state &= ~IO_STATE_ADJUST_OFFSET;
    45ac:	80 e4 fb             	and    $0xfb,%ah
    45af:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	dma_addr_t			dma_addr;
	int				n;

	TRACE_ENTRY();
	cmd = priv->hw->cmd_buf + index;
	req = (TargetAssistRequest_t *)priv->current_mf[index];
    45b5:	8b 04 8e             	mov    (%esi,%ecx,4),%eax
    45b8:	89 c7                	mov    %eax,%edi
    45ba:	89 45 d0             	mov    %eax,-0x30(%ebp)

	old_offset = le32_to_cpu(req->RelativeOffset);
    45bd:	8b 40 18             	mov    0x18(%eax),%eax

	/* walk the SGL, skipping along until we get to the right offset */
	offset = old_offset;
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
    45c0:	83 c7 20             	add    $0x20,%edi
    45c3:	89 7d cc             	mov    %edi,-0x34(%ebp)

	TRACE_ENTRY();
	cmd = priv->hw->cmd_buf + index;
	req = (TargetAssistRequest_t *)priv->current_mf[index];

	old_offset = le32_to_cpu(req->RelativeOffset);
    45c6:	89 45 c8             	mov    %eax,-0x38(%ebp)
    45c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	/* walk the SGL, skipping along until we get to the right offset */
	offset = old_offset;
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	n = 0;
	while (1) {
		flags_length = le32_to_cpu(sge_simple->FlagsLength);
    45d0:	8b 0f                	mov    (%edi),%ecx
		type = MPI_SGE_GET_FLAGS(flags_length) & MPI_SGE_FLAGS_ELEMENT_MASK;
    45d2:	89 ca                	mov    %ecx,%edx
    45d4:	c1 ea 18             	shr    $0x18,%edx
    45d7:	83 e2 30             	and    $0x30,%edx
		if (type == MPI_SGE_FLAGS_CHAIN_ELEMENT) {
    45da:	83 fa 30             	cmp    $0x30,%edx
    45dd:	74 24                	je     4603 <stm_target_reply_error+0x263>
				sge_simple = (MPT_STM_SIMPLE *)(sge_chain + 1);
			}
			n = 0;
		} else {
			length = MPI_SGE_LENGTH(flags_length);
			if (offset + length > new_offset)
    45df:	89 ca                	mov    %ecx,%edx
    45e1:	81 e2 ff ff ff 00    	and    $0xffffff,%edx
    45e7:	01 c2                	add    %eax,%edx
    45e9:	75 35                	jne    4620 <stm_target_reply_error+0x280>
				break;
			offset += length;
			sge_simple++;
    45eb:	83 c7 0c             	add    $0xc,%edi
	/* walk the SGL, skipping along until we get to the right offset */
	offset = old_offset;
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	n = 0;
	while (1) {
		flags_length = le32_to_cpu(sge_simple->FlagsLength);
    45ee:	8b 0f                	mov    (%edi),%ecx
			length = MPI_SGE_LENGTH(flags_length);
			if (offset + length > new_offset)
				break;
			offset += length;
			sge_simple++;
			n++;
    45f0:	31 c0                	xor    %eax,%eax
    45f2:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
	offset = old_offset;
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	n = 0;
	while (1) {
		flags_length = le32_to_cpu(sge_simple->FlagsLength);
		type = MPI_SGE_GET_FLAGS(flags_length) & MPI_SGE_FLAGS_ELEMENT_MASK;
    45f6:	89 ca                	mov    %ecx,%edx
    45f8:	c1 ea 18             	shr    $0x18,%edx
    45fb:	83 e2 30             	and    $0x30,%edx
		if (type == MPI_SGE_FLAGS_CHAIN_ELEMENT) {
    45fe:	83 fa 30             	cmp    $0x30,%edx
    4601:	75 dc                	jne    45df <stm_target_reply_error+0x23f>
			if (sge_chain == NULL) {
    4603:	8b 55 e0             	mov    -0x20(%ebp),%edx
    4606:	85 d2                	test   %edx,%edx
    4608:	0f 84 92 00 00 00    	je     46a0 <stm_target_reply_error+0x300>
				stm_get_dma_addr(dma_addr, sge_chain->Address);
				sge_simple = (MPT_STM_SIMPLE *)
					((u8 *)priv->hw + (dma_addr - priv->hw_dma));
			} else {
				sge_chain = (MPT_STM_CHAIN *)sge_simple;
				sge_simple = (MPT_STM_SIMPLE *)(sge_chain + 1);
    460e:	89 7d e0             	mov    %edi,-0x20(%ebp)
    4611:	83 c7 0c             	add    $0xc,%edi
			}
			n = 0;
    4614:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    461b:	eb b3                	jmp    45d0 <stm_target_reply_error+0x230>
    461d:	8d 76 00             	lea    0x0(%esi),%esi
			n++;
		}
	}

	/* fix up the current SGE */
	flags_length -= new_offset - offset;
    4620:	01 c1                	add    %eax,%ecx
	sge_simple->FlagsLength = le32_to_cpu(flags_length);
	stm_get_dma_addr(dma_addr, sge_simple->Address);
	dma_addr += new_offset - offset;
    4622:	31 d2                	xor    %edx,%edx
			n++;
		}
	}

	/* fix up the current SGE */
	flags_length -= new_offset - offset;
    4624:	89 0f                	mov    %ecx,(%edi)
	sge_simple->FlagsLength = le32_to_cpu(flags_length);
	stm_get_dma_addr(dma_addr, sge_simple->Address);
    4626:	8b 4f 04             	mov    0x4(%edi),%ecx
	dma_addr += new_offset - offset;
    4629:	f7 d8                	neg    %eax
	}

	/* fix up the current SGE */
	flags_length -= new_offset - offset;
	sge_simple->FlagsLength = le32_to_cpu(flags_length);
	stm_get_dma_addr(dma_addr, sge_simple->Address);
    462b:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
    462e:	8b 4f 08             	mov    0x8(%edi),%ecx
	dma_addr += new_offset - offset;
    4631:	03 45 d4             	add    -0x2c(%ebp),%eax
	}

	/* fix up the current SGE */
	flags_length -= new_offset - offset;
	sge_simple->FlagsLength = le32_to_cpu(flags_length);
	stm_get_dma_addr(dma_addr, sge_simple->Address);
    4634:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	dma_addr += new_offset - offset;
    4637:	13 55 d8             	adc    -0x28(%ebp),%edx
	stm_set_dma_addr(sge_simple->Address, dma_addr);

	/* if we have skipped any SGEs, we need to use a chain to point to */
	/* the new "first" SGE */
	if (sge_simple != (MPT_STM_SIMPLE *)&req->SGL) {
    463a:	39 7d cc             	cmp    %edi,-0x34(%ebp)
	/* fix up the current SGE */
	flags_length -= new_offset - offset;
	sge_simple->FlagsLength = le32_to_cpu(flags_length);
	stm_get_dma_addr(dma_addr, sge_simple->Address);
	dma_addr += new_offset - offset;
	stm_set_dma_addr(sge_simple->Address, dma_addr);
    463d:	89 47 04             	mov    %eax,0x4(%edi)
    4640:	89 57 08             	mov    %edx,0x8(%edi)

	/* if we have skipped any SGEs, we need to use a chain to point to */
	/* the new "first" SGE */
	if (sge_simple != (MPT_STM_SIMPLE *)&req->SGL) {
    4643:	74 42                	je     4687 <stm_target_reply_error+0x2e7>
		/* see if we've already walked past a chain */
		if (sge_chain == NULL) {
    4645:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4648:	85 c0                	test   %eax,%eax
    464a:	74 6e                	je     46ba <stm_target_reply_error+0x31a>
				req->ChainOffset -= n * sizeof(MPT_STM_SIMPLE) / sizeof(u32);
		} else {
			/* we have to build a chain on top of the first SGE */
			length = le16_to_cpu(sge_chain->Length) -
				n * sizeof(MPT_STM_SIMPLE);
			offset = sge_chain->NextChainOffset;
    464c:	8b 45 e0             	mov    -0x20(%ebp),%eax
			if (req->ChainOffset != 0)
				req->ChainOffset -= n * sizeof(MPT_STM_SIMPLE) / sizeof(u32);
		} else {
			/* we have to build a chain on top of the first SGE */
			length = le16_to_cpu(sge_chain->Length) -
				n * sizeof(MPT_STM_SIMPLE);
    464f:	8b 55 e8             	mov    -0x18(%ebp),%edx
			offset = sge_chain->NextChainOffset;
    4652:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
				sizeof(MPT_STM_SIMPLE));
			if (req->ChainOffset != 0)
				req->ChainOffset -= n * sizeof(MPT_STM_SIMPLE) / sizeof(u32);
		} else {
			/* we have to build a chain on top of the first SGE */
			length = le16_to_cpu(sge_chain->Length) -
    4656:	0f b7 00             	movzwl (%eax),%eax
				n * sizeof(MPT_STM_SIMPLE);
    4659:	8d 14 52             	lea    (%edx,%edx,2),%edx
    465c:	c1 e2 02             	shl    $0x2,%edx
				sizeof(MPT_STM_SIMPLE));
			if (req->ChainOffset != 0)
				req->ChainOffset -= n * sizeof(MPT_STM_SIMPLE) / sizeof(u32);
		} else {
			/* we have to build a chain on top of the first SGE */
			length = le16_to_cpu(sge_chain->Length) -
    465f:	29 d0                	sub    %edx,%eax
				n * sizeof(MPT_STM_SIMPLE);
			offset = sge_chain->NextChainOffset;
			sge_chain = (MPT_STM_CHAIN *)&req->SGL;
			sge_chain->Length = cpu_to_le16(length);
    4661:	8b 55 d0             	mov    -0x30(%ebp),%edx
    4664:	66 89 42 20          	mov    %ax,0x20(%edx)
			sge_chain->NextChainOffset = (u8)offset;
			sge_chain->Flags =
				(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
				     MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
			dma_addr = priv->hw_dma + ((u8 *)sge_simple - (u8 *)priv->hw);
    4668:	89 f8                	mov    %edi,%eax
			length = le16_to_cpu(sge_chain->Length) -
				n * sizeof(MPT_STM_SIMPLE);
			offset = sge_chain->NextChainOffset;
			sge_chain = (MPT_STM_CHAIN *)&req->SGL;
			sge_chain->Length = cpu_to_le16(length);
			sge_chain->NextChainOffset = (u8)offset;
    466a:	88 4a 22             	mov    %cl,0x22(%edx)
			sge_chain->Flags =
    466d:	89 d1                	mov    %edx,%ecx
    466f:	c6 42 23 32          	movb   $0x32,0x23(%edx)
				(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
				     MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
			dma_addr = priv->hw_dma + ((u8 *)sge_simple - (u8 *)priv->hw);
    4673:	2b 46 20             	sub    0x20(%esi),%eax
    4676:	99                   	cltd   
    4677:	03 46 24             	add    0x24(%esi),%eax
    467a:	13 56 28             	adc    0x28(%esi),%edx
			stm_set_dma_addr(sge_chain->Address, dma_addr);
			req->ChainOffset = (u32 *)sge_chain - (u32 *)req;
    467d:	c6 41 02 08          	movb   $0x8,0x2(%ecx)
			sge_chain->NextChainOffset = (u8)offset;
			sge_chain->Flags =
				(u8)(MPI_SGE_FLAGS_CHAIN_ELEMENT |
				     MPI_SGE_FLAGS_MPT_STM_ADDRESSING);
			dma_addr = priv->hw_dma + ((u8 *)sge_simple - (u8 *)priv->hw);
			stm_set_dma_addr(sge_chain->Address, dma_addr);
    4681:	89 41 24             	mov    %eax,0x24(%ecx)
    4684:	89 51 28             	mov    %edx,0x28(%ecx)
		}
	}

	/* fix up the offset and length */
	old_length = le32_to_cpu(req->DataLength);
	new_length = old_length - (new_offset - old_offset);
    4687:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    468a:	8b 45 c8             	mov    -0x38(%ebp),%eax
    468d:	03 41 1c             	add    0x1c(%ecx),%eax

	req->RelativeOffset = cpu_to_le32(new_offset);
    4690:	c7 41 18 00 00 00 00 	movl   $0x0,0x18(%ecx)
	req->DataLength = cpu_to_le32(new_length);
    4697:	89 41 1c             	mov    %eax,0x1c(%ecx)
    469a:	e9 9d fd ff ff       	jmp    443c <stm_target_reply_error+0x9c>
    469f:	90                   	nop
		flags_length = le32_to_cpu(sge_simple->FlagsLength);
		type = MPI_SGE_GET_FLAGS(flags_length) & MPI_SGE_FLAGS_ELEMENT_MASK;
		if (type == MPI_SGE_FLAGS_CHAIN_ELEMENT) {
			if (sge_chain == NULL) {
				sge_chain = (MPT_STM_CHAIN *)sge_simple;
				stm_get_dma_addr(dma_addr, sge_chain->Address);
    46a0:	8b 57 04             	mov    0x4(%edi),%edx
				sge_simple = (MPT_STM_SIMPLE *)
    46a3:	89 7d e0             	mov    %edi,-0x20(%ebp)
    46a6:	8b 7e 20             	mov    0x20(%esi),%edi
					((u8 *)priv->hw + (dma_addr - priv->hw_dma));
    46a9:	2b 56 24             	sub    0x24(%esi),%edx
			} else {
				sge_chain = (MPT_STM_CHAIN *)sge_simple;
				sge_simple = (MPT_STM_SIMPLE *)(sge_chain + 1);
			}
			n = 0;
    46ac:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		type = MPI_SGE_GET_FLAGS(flags_length) & MPI_SGE_FLAGS_ELEMENT_MASK;
		if (type == MPI_SGE_FLAGS_CHAIN_ELEMENT) {
			if (sge_chain == NULL) {
				sge_chain = (MPT_STM_CHAIN *)sge_simple;
				stm_get_dma_addr(dma_addr, sge_chain->Address);
				sge_simple = (MPT_STM_SIMPLE *)
    46b3:	01 d7                	add    %edx,%edi
    46b5:	e9 16 ff ff ff       	jmp    45d0 <stm_target_reply_error+0x230>
	if (sge_simple != (MPT_STM_SIMPLE *)&req->SGL) {
		/* see if we've already walked past a chain */
		if (sge_chain == NULL) {
			/* all we have to do here is move the SGEs in the request frame */
			memmove(&req->SGL, sge_simple,
				(priv->num_sge_target_assist - n) *
    46ba:	8b 46 10             	mov    0x10(%esi),%eax
	/* the new "first" SGE */
	if (sge_simple != (MPT_STM_SIMPLE *)&req->SGL) {
		/* see if we've already walked past a chain */
		if (sge_chain == NULL) {
			/* all we have to do here is move the SGEs in the request frame */
			memmove(&req->SGL, sge_simple,
    46bd:	89 fa                	mov    %edi,%edx
				(priv->num_sge_target_assist - n) *
    46bf:	2b 45 e8             	sub    -0x18(%ebp),%eax
	/* the new "first" SGE */
	if (sge_simple != (MPT_STM_SIMPLE *)&req->SGL) {
		/* see if we've already walked past a chain */
		if (sge_chain == NULL) {
			/* all we have to do here is move the SGEs in the request frame */
			memmove(&req->SGL, sge_simple,
    46c2:	8d 0c 40             	lea    (%eax,%eax,2),%ecx
    46c5:	8b 45 cc             	mov    -0x34(%ebp),%eax
    46c8:	c1 e1 02             	shl    $0x2,%ecx
    46cb:	e8 fc ff ff ff       	call   46cc <stm_target_reply_error+0x32c>
				(priv->num_sge_target_assist - n) *
				sizeof(MPT_STM_SIMPLE));
			if (req->ChainOffset != 0)
    46d0:	8b 45 d0             	mov    -0x30(%ebp),%eax
    46d3:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    46d7:	84 c0                	test   %al,%al
    46d9:	74 ac                	je     4687 <stm_target_reply_error+0x2e7>
				req->ChainOffset -= n * sizeof(MPT_STM_SIMPLE) / sizeof(u32);
    46db:	8b 7d e8             	mov    -0x18(%ebp),%edi
    46de:	8d 14 7f             	lea    (%edi,%edi,2),%edx
    46e1:	8b 7d d0             	mov    -0x30(%ebp),%edi
    46e4:	29 d0                	sub    %edx,%eax
    46e6:	88 47 02             	mov    %al,0x2(%edi)
    46e9:	eb 9c                	jmp    4687 <stm_target_reply_error+0x2e7>
    46eb:	90                   	nop
    46ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000046f0 <stm_reply>:
 *  called when any target mode reply is received
 *  if mf_req is null, then this is a turbo reply; otherwise it's not
 */
static int stm_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf_req,
		     MPT_FRAME_HDR *mf_rep)
{
    46f0:	55                   	push   %ebp
    46f1:	89 e5                	mov    %esp,%ebp
    46f3:	57                   	push   %edi
    46f4:	56                   	push   %esi
    46f5:	53                   	push   %ebx
    46f6:	83 ec 20             	sub    $0x20,%esp
    46f9:	e8 fc ff ff ff       	call   46fa <stm_reply+0xa>
    46fe:	89 c7                	mov    %eax,%edi
	MPT_STM_PRIV	*priv = mpt_stm_priv[ioc->id];
    4700:	8b 00                	mov    (%eax),%eax
	MPIDefaultReply_t	*rep = (MPIDefaultReply_t *)mf_rep;
	int	ioc_status;

	TRACE_ENTRY();
	if (mf_req == NULL) {
    4702:	85 d2                	test   %edx,%edx
 *  called when any target mode reply is received
 *  if mf_req is null, then this is a turbo reply; otherwise it's not
 */
static int stm_reply(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf_req,
		     MPT_FRAME_HDR *mf_rep)
{
    4704:	89 d6                	mov    %edx,%esi
    4706:	89 cb                	mov    %ecx,%ebx
	MPT_STM_PRIV	*priv = mpt_stm_priv[ioc->id];
    4708:	8b 04 85 20 00 00 00 	mov    0x20(,%eax,4),%eax
    470f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	MPIDefaultReply_t	*rep = (MPIDefaultReply_t *)mf_rep;
	int	ioc_status;

	TRACE_ENTRY();
	if (mf_req == NULL) {
    4712:	0f 84 98 03 00 00    	je     4ab0 <stm_reply+0x3c0>
			  ioc->name, rep->Function, ioc_status,
			  le32_to_cpu(rep->IOCLogInfo));
	}

	ioc_status &= MPI_IOCSTATUS_MASK;
	switch (rep->Function) {
    4718:	0f b6 53 03          	movzbl 0x3(%ebx),%edx
		TRACE_DBG("%s Function = %02x, IOCStatus = %04x, IOCLogInfo = %08x",
			  ioc->name, rep->Function, ioc_status,
			  le32_to_cpu(rep->IOCLogInfo));
	}

	ioc_status &= MPI_IOCSTATUS_MASK;
    471c:	0f b7 49 0e          	movzwl 0xe(%ecx),%ecx
	switch (rep->Function) {
    4720:	8d 42 fc             	lea    -0x4(%edx),%eax
		TRACE_DBG("%s Function = %02x, IOCStatus = %04x, IOCLogInfo = %08x",
			  ioc->name, rep->Function, ioc_status,
			  le32_to_cpu(rep->IOCLogInfo));
	}

	ioc_status &= MPI_IOCSTATUS_MASK;
    4723:	81 e1 ff 7f 00 00    	and    $0x7fff,%ecx
	switch (rep->Function) {
    4729:	3c 21                	cmp    $0x21,%al
    472b:	0f 87 ff 02 00 00    	ja     4a30 <stm_reply+0x340>
    4731:	0f b6 c0             	movzbl %al,%eax
    4734:	ff 24 85 04 02 00 00 	jmp    *0x204(,%eax,4)
    473b:	90                   	nop
    473c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	case MPI_FUNCTION_TARGET_CMD_BUF_BASE_POST:
		/*
		 *  this signals that the command buffer base post is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
    4740:	85 c9                	test   %ecx,%ecx
    4742:	0f 85 f4 05 00 00    	jne    4d3c <stm_reply+0x64c>
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s FcPrimitiveSend IOCStatus = %04x\n",
			       ioc->name, ioc_status);
		}
		priv->fc_primitive_send_pending = 0;
		return 1;
    4748:	b8 01 00 00 00       	mov    $0x1,%eax
		}
		break;
	}
	TRACE_EXIT();
	return 0;
}
    474d:	83 c4 20             	add    $0x20,%esp
    4750:	5b                   	pop    %ebx
    4751:	5e                   	pop    %esi
    4752:	5f                   	pop    %edi
    4753:	5d                   	pop    %ebp
    4754:	c3                   	ret    
    4755:	8d 76 00             	lea    0x0(%esi),%esi
	switch (rep->Function) {
	case MPI_FUNCTION_CONFIG:
		/*
		 *  this signals that the config is done
		 */
		priv->config_pending = 0;
    4758:	8b 4d f0             	mov    -0x10(%ebp),%ecx
		memcpy(&priv->config_rep, rep, sizeof(ConfigReply_t));
		/*
		 *  don't free the message frame, since we're remembering it
		 *  in priv->config_mf, and we'll be using it over and over
		 */
		return 0;
    475b:	31 c0                	xor    %eax,%eax
	switch (rep->Function) {
	case MPI_FUNCTION_CONFIG:
		/*
		 *  this signals that the config is done
		 */
		priv->config_pending = 0;
    475d:	c7 41 74 00 00 00 00 	movl   $0x0,0x74(%ecx)
		memcpy(&priv->config_rep, rep, sizeof(ConfigReply_t));
    4764:	8b 13                	mov    (%ebx),%edx
    4766:	89 91 88 00 00 00    	mov    %edx,0x88(%ecx)
    476c:	8b 53 04             	mov    0x4(%ebx),%edx
    476f:	89 91 8c 00 00 00    	mov    %edx,0x8c(%ecx)
    4775:	8b 53 08             	mov    0x8(%ebx),%edx
    4778:	89 91 90 00 00 00    	mov    %edx,0x90(%ecx)
    477e:	8b 53 0c             	mov    0xc(%ebx),%edx
    4781:	89 91 94 00 00 00    	mov    %edx,0x94(%ecx)
    4787:	8b 53 10             	mov    0x10(%ebx),%edx
    478a:	89 91 98 00 00 00    	mov    %edx,0x98(%ecx)
    4790:	8b 53 14             	mov    0x14(%ebx),%edx
    4793:	89 91 9c 00 00 00    	mov    %edx,0x9c(%ecx)
		/*
		 *  don't free the message frame, since we're remembering it
		 *  in priv->config_mf, and we'll be using it over and over
		 */
		return 0;
    4799:	eb b2                	jmp    474d <stm_reply+0x5d>
    479b:	90                   	nop
    479c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	case MPI_FUNCTION_PORT_ENABLE:
		/*
		 *  this signals that the port enable is done
		 */
		priv->port_enable_loginfo = le32_to_cpu(rep->IOCLogInfo);
    47a0:	8b 43 10             	mov    0x10(%ebx),%eax
    47a3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    47a6:	89 42 5c             	mov    %eax,0x5c(%edx)
		priv->port_enable_pending = 0;
		return 1;
    47a9:	b8 01 00 00 00       	mov    $0x1,%eax
	case MPI_FUNCTION_PORT_ENABLE:
		/*
		 *  this signals that the port enable is done
		 */
		priv->port_enable_loginfo = le32_to_cpu(rep->IOCLogInfo);
		priv->port_enable_pending = 0;
    47ae:	c7 42 60 00 00 00 00 	movl   $0x0,0x60(%edx)
		return 1;
    47b5:	eb 96                	jmp    474d <stm_reply+0x5d>
    47b7:	90                   	nop
		 *
		 *  we can also get here for High Priority I/O (such as getting
		 *  a command while not being allowed to disconnect from the SCSI
		 *  bus), and if we're shutting down
		 */
		if (ioc_status == MPI_IOCSTATUS_SUCCESS) {
    47b8:	85 c9                	test   %ecx,%ecx
    47ba:	74 8c                	je     4748 <stm_reply+0x58>
			TRACE_EXIT();
			return 1;
		}
		if (priv->target_mode_abort_pending &&
    47bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    47bf:	8b 40 64             	mov    0x64(%eax),%eax
    47c2:	85 c0                	test   %eax,%eax
    47c4:	74 09                	je     47cf <stm_reply+0xdf>
    47c6:	83 f9 63             	cmp    $0x63,%ecx
    47c9:	0f 84 d4 02 00 00    	je     4aa3 <stm_reply+0x3b3>
		    ioc_status == MPI_IOCSTATUS_TARGET_ABORTED) {
			TRACE_EXIT();
			return 0;
		}
		if (ioc_status == MPI_IOCSTATUS_TARGET_PRIORITY_IO) {
    47cf:	83 f9 60             	cmp    $0x60,%ecx
    47d2:	0f 84 1d 03 00 00    	je     4af5 <stm_reply+0x405>
			TRACE_EXIT();
			return 0;
		}
		TRACE_DBG(":%s TargetCmdBufPostReq IOCStatus = %04x",
			  ioc->name, ioc_status);
		if (ioc_status == MPI_IOCSTATUS_INSUFFICIENT_RESOURCES) {
    47d8:	83 f9 06             	cmp    $0x6,%ecx
    47db:	0f 84 42 04 00 00    	je     4c23 <stm_reply+0x533>
			 *  endless loop
			 */
			WARN_ON(1);
			return 0;
		}
		if (ioc_status == MPI_IOCSTATUS_TARGET_NO_CONNECTION) {
    47e1:	83 f9 65             	cmp    $0x65,%ecx
    47e4:	0f 84 ab 05 00 00    	je     4d95 <stm_reply+0x6a5>
			printk(KERN_ERR MYNAM
			       ": %s: Got MPI_IOCSTATUS_TARGET_NO_CONNECTION\n",
			       ioc->name);
			return 0;
		}
		if (rep->MsgLength > sizeof(*rep)/sizeof(u32)) {
    47ea:	80 7b 02 05          	cmpb   $0x5,0x2(%ebx)
    47ee:	0f 86 e8 02 00 00    	jbe    4adc <stm_reply+0x3ec>
			TRACE_DBG("MsgLength is %d, %zd",
				  rep->MsgLength, sizeof(*rep)/sizeof(u32));
			WARN_ON(1);
    47f4:	ba 3d 08 00 00       	mov    $0x83d,%edx
    47f9:	b8 8c 01 00 00       	mov    $0x18c,%eax
    47fe:	e8 fc ff ff ff       	call   47ff <stm_reply+0x10f>
			 *  structures are nearly identical; the exception is that
			 *  the former does not have a TransferCount field, while
			 *  the latter does; add one
			 */
			((TargetErrorReply_t *)rep)->TransferCount = 0;
			stm_target_reply_error(ioc, (TargetErrorReply_t *)rep);
    4803:	89 f8                	mov    %edi,%eax
    4805:	89 da                	mov    %ebx,%edx
			 *  the TargetCmdBufferPostErrorReply and TargetErrorReply
			 *  structures are nearly identical; the exception is that
			 *  the former does not have a TransferCount field, while
			 *  the latter does; add one
			 */
			((TargetErrorReply_t *)rep)->TransferCount = 0;
    4807:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
			stm_target_reply_error(ioc, (TargetErrorReply_t *)rep);
    480e:	e8 8d fb ff ff       	call   43a0 <stm_target_reply_error>
			return 0;
    4813:	31 c0                	xor    %eax,%eax
    4815:	e9 33 ff ff ff       	jmp    474d <stm_reply+0x5d>
    481a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		 *  only get here if an error occurred
		 *
		 *  at this point we need to clean up the remains of the I/O
		 *  and repost the command buffer
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
    4820:	85 c9                	test   %ecx,%ecx
    4822:	0f 85 9b 04 00 00    	jne    4cc3 <stm_reply+0x5d3>
			printk(KERN_ERR MYNAM ":%s TargetAssistReq IOCStatus = %04x\n",
			       ioc->name, ioc_status);
		}
		stm_target_reply_error(ioc, (TargetErrorReply_t *)rep);
    4828:	89 f8                	mov    %edi,%eax
    482a:	89 da                	mov    %ebx,%edx
    482c:	e8 6f fb ff ff       	call   43a0 <stm_target_reply_error>
		}
		break;
	}
	TRACE_EXIT();
	return 0;
}
    4831:	83 c4 20             	add    $0x20,%esp
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s TargetAssistReq IOCStatus = %04x\n",
			       ioc->name, ioc_status);
		}
		stm_target_reply_error(ioc, (TargetErrorReply_t *)rep);
		return 0;
    4834:	31 c0                	xor    %eax,%eax
		}
		break;
	}
	TRACE_EXIT();
	return 0;
}
    4836:	5b                   	pop    %ebx
    4837:	5e                   	pop    %esi
    4838:	5f                   	pop    %edi
    4839:	5d                   	pop    %ebp
    483a:	c3                   	ret    
    483b:	90                   	nop
    483c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		 *  only get here if an error occurred
		 *
		 *  at this point we need to clean up the remains of the I/O
		 *  and repost the command buffer
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
    4840:	85 c9                	test   %ecx,%ecx
    4842:	74 e4                	je     4828 <stm_reply+0x138>
			 * and we're SCSI, only print if we're debugging and
			 * tracing.  This is a normal consequence of attempting
			 * to send sense data and status in the same
			 * transaction.
			 */
			if (IsScsi(priv) &&
    4844:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4847:	8b 00                	mov    (%eax),%eax
    4849:	80 b8 69 03 00 00 01 	cmpb   $0x1,0x369(%eax)
    4850:	75 05                	jne    4857 <stm_reply+0x167>
    4852:	83 f9 6b             	cmp    $0x6b,%ecx
    4855:	74 d1                	je     4828 <stm_reply+0x138>
			    (ioc_status == MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT)) {
				TRACE_DBG(MYNAM ":%s TargetStatusSendReq IOCStatus = %04x\n",
					  ioc->name, ioc_status);
			} else {
				printk(KERN_ERR MYNAM ":%s TargetStatusSendReq IOCStatus = %04x\n",
				       ioc->name, ioc_status);
    4857:	8d 47 08             	lea    0x8(%edi),%eax
			if (IsScsi(priv) &&
			    (ioc_status == MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT)) {
				TRACE_DBG(MYNAM ":%s TargetStatusSendReq IOCStatus = %04x\n",
					  ioc->name, ioc_status);
			} else {
				printk(KERN_ERR MYNAM ":%s TargetStatusSendReq IOCStatus = %04x\n",
    485a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
				       ioc->name, ioc_status);
    485e:	89 44 24 04          	mov    %eax,0x4(%esp)
			if (IsScsi(priv) &&
			    (ioc_status == MPI_IOCSTATUS_TARGET_STS_DATA_NOT_SENT)) {
				TRACE_DBG(MYNAM ":%s TargetStatusSendReq IOCStatus = %04x\n",
					  ioc->name, ioc_status);
			} else {
				printk(KERN_ERR MYNAM ":%s TargetStatusSendReq IOCStatus = %04x\n",
    4862:	c7 04 24 78 0b 00 00 	movl   $0xb78,(%esp)
    4869:	e8 fc ff ff ff       	call   486a <stm_reply+0x17a>
    486e:	eb b8                	jmp    4828 <stm_reply+0x138>
		TargetModeAbort_t		*req = (TargetModeAbort_t *)mf_req;

		/*
		 *  this signals that the target mode abort is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
    4870:	85 c9                	test   %ecx,%ecx
    4872:	0f 85 01 05 00 00    	jne    4d79 <stm_reply+0x689>
			printk(KERN_ERR MYNAM ":%s TargetModeAbort IOCStatus = %04x\n",
			       ioc->name, ioc_status);
		}
		if (req->AbortType == TARGET_MODE_ABORT_TYPE_ALL_CMD_BUFFERS) {
    4878:	80 3e 00             	cmpb   $0x0,(%esi)
    487b:	90                   	nop
    487c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4880:	0f 84 42 02 00 00    	je     4ac8 <stm_reply+0x3d8>
			 *  have no outstanding target assist or target status send
			 *  at the time of the abort request) -- so pretend that
			 *  the error reply came in with a status indicating that
			 *  the I/O was aborted
			 */
			reply_word = le32_to_cpu(req->ReplyWord);
    4886:	8b 56 0c             	mov    0xc(%esi),%edx
    4889:	8b 45 f0             	mov    -0x10(%ebp),%eax
			index = GET_IO_INDEX(reply_word);
    488c:	89 d6                	mov    %edx,%esi
    488e:	81 e6 ff 3f 00 00    	and    $0x3fff,%esi
    4894:	8d 1c b0             	lea    (%eax,%esi,4),%ebx
			io_state = priv->io_state + index;
			if ((*io_state & IO_STATE_ABORTED) &&
    4897:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    489d:	a8 40                	test   $0x40,%al
    489f:	74 1f                	je     48c0 <stm_reply+0x1d0>
			    !(*io_state & IO_STATE_DATA_SENT) &&
    48a1:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
			 *  the I/O was aborted
			 */
			reply_word = le32_to_cpu(req->ReplyWord);
			index = GET_IO_INDEX(reply_word);
			io_state = priv->io_state + index;
			if ((*io_state & IO_STATE_ABORTED) &&
    48a7:	a8 02                	test   $0x2,%al
    48a9:	75 15                	jne    48c0 <stm_reply+0x1d0>
			    !(*io_state & IO_STATE_DATA_SENT) &&
			    !(*io_state & IO_STATE_STATUS_SENT)) {
    48ab:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
			 */
			reply_word = le32_to_cpu(req->ReplyWord);
			index = GET_IO_INDEX(reply_word);
			io_state = priv->io_state + index;
			if ((*io_state & IO_STATE_ABORTED) &&
			    !(*io_state & IO_STATE_DATA_SENT) &&
    48b1:	a8 04                	test   $0x4,%al
    48b3:	0f 84 4c 03 00 00    	je     4c05 <stm_reply+0x515>
    48b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			 *  status send, but the abort didn't work (if the abort had
			 *  worked, the flag we're checking would be clear) -- if so,
			 *  just clear the various SRR flags, and wait for the initiator
			 *  to retry the SRR
			 */
			if (*io_state & IO_STATE_REQUEST_ABORTED) {
    48c0:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    48c6:	f6 c4 01             	test   $0x1,%ah
    48c9:	0f 84 79 fe ff ff    	je     4748 <stm_reply+0x58>
				printk(KERN_ERR MYNAM ":%s index %d: io_state = %x\n",
    48cf:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
				       ioc->name, index, *io_state);
    48d5:	83 c7 08             	add    $0x8,%edi
			 *  worked, the flag we're checking would be clear) -- if so,
			 *  just clear the various SRR flags, and wait for the initiator
			 *  to retry the SRR
			 */
			if (*io_state & IO_STATE_REQUEST_ABORTED) {
				printk(KERN_ERR MYNAM ":%s index %d: io_state = %x\n",
    48d8:	89 74 24 08          	mov    %esi,0x8(%esp)
    48dc:	89 7c 24 04          	mov    %edi,0x4(%esp)
    48e0:	c7 04 24 dc 0b 00 00 	movl   $0xbdc,(%esp)
    48e7:	89 44 24 0c          	mov    %eax,0xc(%esp)
    48eb:	e8 fc ff ff ff       	call   48ec <stm_reply+0x1fc>
				       ioc->name, index, *io_state);
				printk(KERN_ERR MYNAM ":%s   request was not aborted\n",
    48f0:	89 7c 24 04          	mov    %edi,0x4(%esp)
    48f4:	c7 04 24 04 0c 00 00 	movl   $0xc04,(%esp)
    48fb:	e8 fc ff ff ff       	call   48fc <stm_reply+0x20c>
				       ioc->name);
				*io_state &= ~IO_STATE_REQUEST_ABORTED;
    4900:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    4906:	80 e4 fe             	and    $0xfe,%ah
    4909:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
				*io_state &= ~IO_STATE_REISSUE_REQUEST;
    490f:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    4915:	80 e4 fd             	and    $0xfd,%ah
    4918:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
				*io_state &= ~IO_STATE_ADJUST_OFFSET;
    491e:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    4924:	80 e4 fb             	and    $0xfb,%ah
    4927:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
				*io_state &= ~IO_STATE_CONVERT_TA_TO_TSS;
    492d:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    4933:	80 e4 f7             	and    $0xf7,%ah
    4936:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
				*io_state &= ~IO_STATE_REDO_COMMAND;
    493c:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    4942:	80 e4 ef             	and    $0xef,%ah
    4945:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
			}
		}
		TRACE_EXIT_RES(1);
		return 1;
    494b:	b8 01 00 00 00       	mov    $0x1,%eax
    4950:	e9 f8 fd ff ff       	jmp    474d <stm_reply+0x5d>
    4955:	8d 76 00             	lea    0x0(%esi),%esi
		 *  if the length is that of a default reply, then this is the
		 *  response to a link service buffer post -- do nothing except
		 *  report errors (none are expected); otherwise this is a
		 *  received ELS, so go handle it
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
    4958:	85 c9                	test   %ecx,%ecx
    495a:	74 2c                	je     4988 <stm_reply+0x298>
			if (priv->link_serv_abort_pending &&
    495c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    495f:	8b 40 68             	mov    0x68(%eax),%eax
    4962:	85 c0                	test   %eax,%eax
    4964:	74 09                	je     496f <stm_reply+0x27f>
    4966:	83 f9 66             	cmp    $0x66,%ecx
    4969:	0f 84 34 01 00 00    	je     4aa3 <stm_reply+0x3b3>
			    ioc_status == MPI_IOCSTATUS_FC_ABORTED) {
				return 0;
			}
			printk(KERN_ERR MYNAM ":%s FcLinkServBufPostReq IOCStatus = %04x\n",
			       ioc->name, ioc_status);
    496f:	8d 47 08             	lea    0x8(%edi),%eax
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			if (priv->link_serv_abort_pending &&
			    ioc_status == MPI_IOCSTATUS_FC_ABORTED) {
				return 0;
			}
			printk(KERN_ERR MYNAM ":%s FcLinkServBufPostReq IOCStatus = %04x\n",
    4972:	89 4c 24 08          	mov    %ecx,0x8(%esp)
			       ioc->name, ioc_status);
    4976:	89 44 24 04          	mov    %eax,0x4(%esp)
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			if (priv->link_serv_abort_pending &&
			    ioc_status == MPI_IOCSTATUS_FC_ABORTED) {
				return 0;
			}
			printk(KERN_ERR MYNAM ":%s FcLinkServBufPostReq IOCStatus = %04x\n",
    497a:	c7 04 24 30 0c 00 00 	movl   $0xc30,(%esp)
    4981:	e8 fc ff ff ff       	call   4982 <stm_reply+0x292>
    4986:	66 90                	xchg   %ax,%ax
			       ioc->name, ioc_status);
		}
		if (rep->MsgLength > sizeof(*rep)/sizeof(u32)) {
    4988:	80 7b 02 05          	cmpb   $0x5,0x2(%ebx)
    498c:	0f 86 b6 fd ff ff    	jbe    4748 <stm_reply+0x58>
			stm_link_service_reply(ioc,
    4992:	89 f8                	mov    %edi,%eax
    4994:	89 da                	mov    %ebx,%edx
    4996:	e8 55 da ff ff       	call   23f0 <stm_link_service_reply>
					       (LinkServiceBufferPostReply_t *)rep);
			return 0;
    499b:	31 c0                	xor    %eax,%eax
    499d:	e9 ab fd ff ff       	jmp    474d <stm_reply+0x5d>
    49a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	case MPI_FUNCTION_FC_LINK_SRVC_RSP:
		/*
		 *  this is the response to a link service send -- repost the
		 *  link service command buffer
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
    49a8:	85 c9                	test   %ecx,%ecx
    49aa:	0f 85 2f 03 00 00    	jne    4cdf <stm_reply+0x5ef>
    49b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
	int			init_index;

	TRACE_ENTRY();
	sge_simple = (MPT_STM_SIMPLE *)&req->SGL;
	p_index = (int *)(sge_simple + 1);
	index = *p_index;
    49b3:	8b 56 30             	mov    0x30(%esi),%edx
    49b6:	8d 0c 90             	lea    (%eax,%edx,4),%ecx
	els = priv->els_state[index];
    49b9:	8b 99 a0 02 00 00    	mov    0x2a0(%ecx),%ebx
	init_index = le32_to_cpu(rep->InitiatorIndex);
	/*
	 *  after our link service reponse has been sent, repost the link service
	 *  buffer
	 */
	priv->els_state[index] = 0;
    49bf:	c7 81 a0 02 00 00 00 	movl   $0x0,0x2a0(%ecx)
    49c6:	00 00 00 
	stm_link_serv_buf_post(priv, index);
    49c9:	e8 32 c1 ff ff       	call   b00 <stm_link_serv_buf_post>
			       ioc->name, ioc_status);
		}
		stm_link_service_rsp_reply(ioc,
					   (LinkServiceRspRequest_t *)mf_req,
					   (LinkServiceRspReply_t *)mf_rep);
		return 1;
    49ce:	b8 01 00 00 00       	mov    $0x1,%eax
    49d3:	e9 75 fd ff ff       	jmp    474d <stm_reply+0x5d>

	case MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:
		/*
		 *  this signals that the extended link service send is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
    49d8:	85 c9                	test   %ecx,%ecx
    49da:	0f 85 40 03 00 00    	jne    4d20 <stm_reply+0x630>
			printk(KERN_ERR MYNAM ":%s ExLinkServiceSend IOCStatus = %04x\n",
			       ioc->name, ioc_status);
		}
		priv->ex_link_service_send_pending = 0;
    49e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    49e3:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%eax)
		return 1;
    49ea:	b8 01 00 00 00       	mov    $0x1,%eax
    49ef:	e9 59 fd ff ff       	jmp    474d <stm_reply+0x5d>
    49f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	case MPI_FUNCTION_FC_ABORT:
		/*
		 *  this signals that the target mode abort is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
    49f8:	85 c9                	test   %ecx,%ecx
    49fa:	0f 85 04 03 00 00    	jne    4d04 <stm_reply+0x614>
			printk(KERN_ERR MYNAM ":%s FcAbort IOCStatus = %04x\n",
			       ioc->name, ioc_status);
		}
		priv->link_serv_abort_pending = 0;
    4a00:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4a03:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
		return 1;
    4a0a:	b8 01 00 00 00       	mov    $0x1,%eax
    4a0f:	e9 39 fd ff ff       	jmp    474d <stm_reply+0x5d>
    4a14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	case MPI_FUNCTION_FC_PRIMITIVE_SEND:
		/*
		 *  this signals that the FC primitive send is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
    4a18:	85 c9                	test   %ecx,%ecx
    4a1a:	0f 85 3d 03 00 00    	jne    4d5d <stm_reply+0x66d>
			printk(KERN_ERR MYNAM ":%s FcPrimitiveSend IOCStatus = %04x\n",
			       ioc->name, ioc_status);
		}
		priv->fc_primitive_send_pending = 0;
    4a20:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4a23:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
    4a2a:	e9 19 fd ff ff       	jmp    4748 <stm_reply+0x58>
    4a2f:	90                   	nop
	default:
		/*
		 *  don't understand this reply, so dump to the screen
		 */
		printk(KERN_ERR MYNAM ":%s got a reply (function %02x) that "
		       "I don't know what to do with\n", ioc->name, rep->Function);
    4a30:	83 c7 08             	add    $0x8,%edi

	default:
		/*
		 *  don't understand this reply, so dump to the screen
		 */
		printk(KERN_ERR MYNAM ":%s got a reply (function %02x) that "
    4a33:	89 54 24 08          	mov    %edx,0x8(%esp)
    4a37:	89 7c 24 04          	mov    %edi,0x4(%esp)
    4a3b:	c7 04 24 28 0d 00 00 	movl   $0xd28,(%esp)
    4a42:	e8 fc ff ff ff       	call   4a43 <stm_reply+0x353>
    4a47:	31 d2                	xor    %edx,%edx
    4a49:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    4a4c:	89 f3                	mov    %esi,%ebx
    4a4e:	89 d6                	mov    %edx,%esi
		if (1) {
			u32 *p = (u32 *)mf_req;
			int i;

			for (i = 0; i < 16; i++) {
				printk(KERN_ERR "%s mf_req[%02x] = %08x\n",
    4a50:	8b 04 33             	mov    (%ebx,%esi,1),%eax
    4a53:	89 74 24 08          	mov    %esi,0x8(%esp)
    4a57:	83 c6 04             	add    $0x4,%esi
    4a5a:	89 7c 24 04          	mov    %edi,0x4(%esp)
    4a5e:	c7 04 24 9e 01 00 00 	movl   $0x19e,(%esp)
    4a65:	89 44 24 0c          	mov    %eax,0xc(%esp)
    4a69:	e8 fc ff ff ff       	call   4a6a <stm_reply+0x37a>
		       "I don't know what to do with\n", ioc->name, rep->Function);
		if (1) {
			u32 *p = (u32 *)mf_req;
			int i;

			for (i = 0; i < 16; i++) {
    4a6e:	83 fe 40             	cmp    $0x40,%esi
    4a71:	75 dd                	jne    4a50 <stm_reply+0x360>
    4a73:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    4a76:	66 31 f6             	xor    %si,%si
    4a79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if (1) {
			u32 *p = (u32 *)mf_rep;
			int i;

			for (i = 0; i < 16; i++) {
				printk(KERN_ERR "%s mf_rep[%02x] = %08x\n",
    4a80:	8b 04 33             	mov    (%ebx,%esi,1),%eax
    4a83:	89 74 24 08          	mov    %esi,0x8(%esp)
    4a87:	83 c6 04             	add    $0x4,%esi
    4a8a:	89 7c 24 04          	mov    %edi,0x4(%esp)
    4a8e:	c7 04 24 b8 01 00 00 	movl   $0x1b8,(%esp)
    4a95:	89 44 24 0c          	mov    %eax,0xc(%esp)
    4a99:	e8 fc ff ff ff       	call   4a9a <stm_reply+0x3aa>
		}
		if (1) {
			u32 *p = (u32 *)mf_rep;
			int i;

			for (i = 0; i < 16; i++) {
    4a9e:	83 fe 40             	cmp    $0x40,%esi
    4aa1:	75 dd                	jne    4a80 <stm_reply+0x390>
		}
		if (ioc_status == MPI_IOCSTATUS_TARGET_PRIORITY_IO) {
			stm_tgt_reply_high_pri(ioc,
					       (TargetCmdBufferPostErrorReply_t *)rep);
			TRACE_EXIT();
			return 0;
    4aa3:	31 c0                	xor    %eax,%eax
		}
		break;
	}
	TRACE_EXIT();
	return 0;
}
    4aa5:	83 c4 20             	add    $0x20,%esp
    4aa8:	5b                   	pop    %ebx
    4aa9:	5e                   	pop    %esi
    4aaa:	5f                   	pop    %edi
    4aab:	5d                   	pop    %ebp
    4aac:	c3                   	ret    
    4aad:	8d 76 00             	lea    0x0(%esi),%esi
		TRACE_DBG("%s: got turbo reply, reply %x",
			  ioc->name, CAST_PTR_TO_U32(mf_rep));
		/*
		 *  this is a received SCSI command, so go handle it
		 */
		stm_tgt_reply(ioc, CAST_PTR_TO_U32(mf_rep));
    4ab0:	89 f8                	mov    %edi,%eax
    4ab2:	89 ca                	mov    %ecx,%edx
    4ab4:	e8 d7 ee ff ff       	call   3990 <stm_tgt_reply>
		}
		break;
	}
	TRACE_EXIT();
	return 0;
}
    4ab9:	83 c4 20             	add    $0x20,%esp
			  ioc->name, CAST_PTR_TO_U32(mf_rep));
		/*
		 *  this is a received SCSI command, so go handle it
		 */
		stm_tgt_reply(ioc, CAST_PTR_TO_U32(mf_rep));
		return 0;
    4abc:	31 c0                	xor    %eax,%eax
		}
		break;
	}
	TRACE_EXIT();
	return 0;
}
    4abe:	5b                   	pop    %ebx
    4abf:	5e                   	pop    %esi
    4ac0:	5f                   	pop    %edi
    4ac1:	5d                   	pop    %ebp
    4ac2:	c3                   	ret    
    4ac3:	90                   	nop
    4ac4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s TargetModeAbort IOCStatus = %04x\n",
			       ioc->name, ioc_status);
		}
		if (req->AbortType == TARGET_MODE_ABORT_TYPE_ALL_CMD_BUFFERS) {
			priv->target_mode_abort_pending = 0;
    4ac8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4acb:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
				*io_state &= ~IO_STATE_CONVERT_TA_TO_TSS;
				*io_state &= ~IO_STATE_REDO_COMMAND;
			}
		}
		TRACE_EXIT_RES(1);
		return 1;
    4ad2:	b8 01 00 00 00       	mov    $0x1,%eax
    4ad7:	e9 71 fc ff ff       	jmp    474d <stm_reply+0x5d>
			 */
			((TargetErrorReply_t *)rep)->TransferCount = 0;
			stm_target_reply_error(ioc, (TargetErrorReply_t *)rep);
			return 0;
		}
		WARN_ON(1);
    4adc:	b8 8c 01 00 00       	mov    $0x18c,%eax
    4ae1:	ba 48 08 00 00       	mov    $0x848,%edx
    4ae6:	e8 fc ff ff ff       	call   4ae7 <stm_reply+0x3f7>
		return 1;
    4aeb:	b8 01 00 00 00       	mov    $0x1,%eax
    4af0:	e9 58 fc ff ff       	jmp    474d <stm_reply+0x5d>
	u32			reply_word;
	int			reason;
	int			index;

	TRACE_ENTRY();
	reply_word = le32_to_cpu(rep->ReplyWord);
    4af5:	8b 73 14             	mov    0x14(%ebx),%esi
    4af8:	8b 45 f0             	mov    -0x10(%ebp),%eax
	reason = rep->PriorityReason;
    4afb:	0f b6 53 0c          	movzbl 0xc(%ebx),%edx

	index = GET_IO_INDEX(reply_word);
    4aff:	89 f3                	mov    %esi,%ebx
    4b01:	81 e3 ff 3f 00 00    	and    $0x3fff,%ebx
    4b07:	8d 0c 98             	lea    (%eax,%ebx,4),%ecx

	TRACE_DBG("%s: target reply high priority", ioc->name);
	TRACE_DBG("%s: ReplyWord = %08x, PriorityReason = %02x",
			ioc->name, reply_word, reason);

	priv->io_state[index] |= IO_STATE_HIGH_PRIORITY;
    4b0a:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
    4b10:	0c 80                	or     $0x80,%al
	if (reason == PRIORITY_REASON_NO_DISCONNECT ||
    4b12:	80 fa 01             	cmp    $0x1,%dl

	TRACE_DBG("%s: target reply high priority", ioc->name);
	TRACE_DBG("%s: ReplyWord = %08x, PriorityReason = %02x",
			ioc->name, reply_word, reason);

	priv->io_state[index] |= IO_STATE_HIGH_PRIORITY;
    4b15:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
	if (reason == PRIORITY_REASON_NO_DISCONNECT ||
    4b1b:	0f 86 36 01 00 00    	jbe    4c57 <stm_reply+0x567>
	int			reason;
	int			index;

	TRACE_ENTRY();
	reply_word = le32_to_cpu(rep->ReplyWord);
	reason = rep->PriorityReason;
    4b21:	0f b6 fa             	movzbl %dl,%edi
			reason == PRIORITY_REASON_SCSI_TASK_MANAGEMENT) {
		stm_tgt_reply(ioc, reply_word);
		goto out;
	}

	WARN_ON(1);
    4b24:	b8 8c 01 00 00       	mov    $0x18c,%eax
    4b29:	ba 36 09 00 00       	mov    $0x936,%edx
    4b2e:	89 4d ec             	mov    %ecx,-0x14(%ebp)
    4b31:	e8 fc ff ff ff       	call   4b32 <stm_reply+0x442>
	if (reason == PRIORITY_REASON_TARGET_BUSY) {
    4b36:	83 ff 09             	cmp    $0x9,%edi
    4b39:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4b3c:	0f 85 f7 00 00 00    	jne    4c39 <stm_reply+0x549>
		CMD		*cmd;
		int		lun;
		int		tag;

		priv->io_state[index] &= ~IO_STATE_POSTED;
    4b42:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
		cmd = priv->hw->cmd_buf + index;
    4b48:	69 d3 f0 03 00 00    	imul   $0x3f0,%ebx,%edx
	if (reason == PRIORITY_REASON_TARGET_BUSY) {
		CMD		*cmd;
		int		lun;
		int		tag;

		priv->io_state[index] &= ~IO_STATE_POSTED;
    4b4e:	83 e0 fe             	and    $0xfffffffe,%eax
    4b51:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
		cmd = priv->hw->cmd_buf + index;
    4b57:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b5a:	03 50 20             	add    0x20(%eax),%edx
		if (IsScsi(priv)) {
    4b5d:	8b 00                	mov    (%eax),%eax
    4b5f:	0f b6 80 69 03 00 00 	movzbl 0x369(%eax),%eax
    4b66:	3c 01                	cmp    $0x1,%al
    4b68:	0f 84 f9 00 00 00    	je     4c67 <stm_reply+0x577>
			SCSI_CMD	*scsi_cmd = (SCSI_CMD *)cmd->cmd;

			lun = get2bytes(scsi_cmd->LogicalUnitNumber, 0);
			tag = scsi_cmd->Tag;
		} else if (IsSas(priv)) {
    4b6e:	3c 30                	cmp    $0x30,%al
    4b70:	0f 84 0d 01 00 00    	je     4c83 <stm_reply+0x593>
			lun = get2bytes(ssp_cmd->LogicalUnitNumber, 0);
			tag = ssp_cmd->InitiatorTag;
		} else {
			FCP_CMD	*fcp_cmd = (FCP_CMD *)cmd->cmd;

			lun = get2bytes(fcp_cmd->FcpLun, 0);
    4b76:	0f b6 02             	movzbl (%edx),%eax
    4b79:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
			tag = 0;
    4b7d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			lun = get2bytes(ssp_cmd->LogicalUnitNumber, 0);
			tag = ssp_cmd->InitiatorTag;
		} else {
			FCP_CMD	*fcp_cmd = (FCP_CMD *)cmd->cmd;

			lun = get2bytes(fcp_cmd->FcpLun, 0);
    4b84:	c1 e0 08             	shl    $0x8,%eax
    4b87:	01 c8                	add    %ecx,%eax
    4b89:	89 45 e8             	mov    %eax,-0x18(%ebp)
			tag = 0;
		}
		memset(cmd->rsp, 0, sizeof(cmd->rsp));
    4b8c:	8d 7a 40             	lea    0x40(%edx),%edi
    4b8f:	f7 c7 01 00 00 00    	test   $0x1,%edi
    4b95:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)
    4b9c:	0f 85 0e 01 00 00    	jne    4cb0 <stm_reply+0x5c0>
    4ba2:	f7 c7 02 00 00 00    	test   $0x2,%edi
    4ba8:	0f 85 f1 00 00 00    	jne    4c9f <stm_reply+0x5af>
    4bae:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4bb1:	31 c0                	xor    %eax,%eax
    4bb3:	c1 e9 02             	shr    $0x2,%ecx
    4bb6:	f3 ab                	rep stos %eax,%es:(%edi)
    4bb8:	f6 45 ec 02          	testb  $0x2,-0x14(%ebp)
    4bbc:	74 08                	je     4bc6 <stm_reply+0x4d6>
    4bbe:	66 c7 07 00 00       	movw   $0x0,(%edi)
    4bc3:	83 c7 02             	add    $0x2,%edi
    4bc6:	f6 45 ec 01          	testb  $0x1,-0x14(%ebp)
    4bca:	74 03                	je     4bcf <stm_reply+0x4df>
    4bcc:	c6 07 00             	movb   $0x0,(%edi)
		stmapp_set_status(priv, cmd, STS_TASK_SET_FULL);
    4bcf:	8b 7d f0             	mov    -0x10(%ebp),%edi
    4bd2:	b9 28 00 00 00       	mov    $0x28,%ecx
    4bd7:	89 f8                	mov    %edi,%eax
    4bd9:	e8 92 ba ff ff       	call   670 <stmapp_set_status>
		stm_send_target_status(priv, reply_word, index, 0, lun, tag);
    4bde:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4be1:	89 d9                	mov    %ebx,%ecx
    4be3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    4bea:	89 f2                	mov    %esi,%edx
    4bec:	89 44 24 08          	mov    %eax,0x8(%esp)
    4bf0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4bf3:	89 44 24 04          	mov    %eax,0x4(%esp)
    4bf7:	89 f8                	mov    %edi,%eax
    4bf9:	e8 c2 c3 ff ff       	call   fc0 <stm_send_target_status>
		}
		if (ioc_status == MPI_IOCSTATUS_TARGET_PRIORITY_IO) {
			stm_tgt_reply_high_pri(ioc,
					       (TargetCmdBufferPostErrorReply_t *)rep);
			TRACE_EXIT();
			return 0;
    4bfe:	31 c0                	xor    %eax,%eax
    4c00:	e9 48 fb ff ff       	jmp    474d <stm_reply+0x5d>
			index = GET_IO_INDEX(reply_word);
			io_state = priv->io_state + index;
			if ((*io_state & IO_STATE_ABORTED) &&
			    !(*io_state & IO_STATE_DATA_SENT) &&
			    !(*io_state & IO_STATE_STATUS_SENT)) {
				stmapp_target_error(priv, reply_word, index,
    4c05:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c08:	89 f1                	mov    %esi,%ecx
    4c0a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    4c11:	00 
    4c12:	c7 04 24 63 00 00 00 	movl   $0x63,(%esp)
    4c19:	e8 12 f1 ff ff       	call   3d30 <stmapp_target_error>
    4c1e:	e9 9d fc ff ff       	jmp    48c0 <stm_reply+0x1d0>
			 *  this should never happen since we carefully count
			 *  our resources, but if it does, tolerate it -- don't
			 *  repost the errant command buffer, lest we create an
			 *  endless loop
			 */
			WARN_ON(1);
    4c23:	b8 8c 01 00 00       	mov    $0x18c,%eax
    4c28:	ba 31 08 00 00       	mov    $0x831,%edx
    4c2d:	e8 fc ff ff ff       	call   4c2e <stm_reply+0x53e>
			return 0;
    4c32:	31 c0                	xor    %eax,%eax
    4c34:	e9 14 fb ff ff       	jmp    474d <stm_reply+0x5d>
		}
		memset(cmd->rsp, 0, sizeof(cmd->rsp));
		stmapp_set_status(priv, cmd, STS_TASK_SET_FULL);
		stm_send_target_status(priv, reply_word, index, 0, lun, tag);
	} else {
		stmapp_target_error(priv, reply_word, index,
    4c39:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c3c:	89 d9                	mov    %ebx,%ecx
    4c3e:	89 f2                	mov    %esi,%edx
    4c40:	89 7c 24 04          	mov    %edi,0x4(%esp)
    4c44:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
    4c4b:	e8 e0 f0 ff ff       	call   3d30 <stmapp_target_error>
		}
		if (ioc_status == MPI_IOCSTATUS_TARGET_PRIORITY_IO) {
			stm_tgt_reply_high_pri(ioc,
					       (TargetCmdBufferPostErrorReply_t *)rep);
			TRACE_EXIT();
			return 0;
    4c50:	31 c0                	xor    %eax,%eax
    4c52:	e9 f6 fa ff ff       	jmp    474d <stm_reply+0x5d>
			ioc->name, reply_word, reason);

	priv->io_state[index] |= IO_STATE_HIGH_PRIORITY;
	if (reason == PRIORITY_REASON_NO_DISCONNECT ||
			reason == PRIORITY_REASON_SCSI_TASK_MANAGEMENT) {
		stm_tgt_reply(ioc, reply_word);
    4c57:	89 f8                	mov    %edi,%eax
    4c59:	89 f2                	mov    %esi,%edx
    4c5b:	e8 30 ed ff ff       	call   3990 <stm_tgt_reply>
		}
		if (ioc_status == MPI_IOCSTATUS_TARGET_PRIORITY_IO) {
			stm_tgt_reply_high_pri(ioc,
					       (TargetCmdBufferPostErrorReply_t *)rep);
			TRACE_EXIT();
			return 0;
    4c60:	31 c0                	xor    %eax,%eax
    4c62:	e9 3e fe ff ff       	jmp    4aa5 <stm_reply+0x3b5>
		priv->io_state[index] &= ~IO_STATE_POSTED;
		cmd = priv->hw->cmd_buf + index;
		if (IsScsi(priv)) {
			SCSI_CMD	*scsi_cmd = (SCSI_CMD *)cmd->cmd;

			lun = get2bytes(scsi_cmd->LogicalUnitNumber, 0);
    4c67:	0f b6 42 04          	movzbl 0x4(%edx),%eax
    4c6b:	0f b6 4a 05          	movzbl 0x5(%edx),%ecx
    4c6f:	c1 e0 08             	shl    $0x8,%eax
    4c72:	01 c8                	add    %ecx,%eax
    4c74:	89 45 e8             	mov    %eax,-0x18(%ebp)
			tag = scsi_cmd->Tag;
    4c77:	0f b7 42 02          	movzwl 0x2(%edx),%eax
    4c7b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    4c7e:	e9 09 ff ff ff       	jmp    4b8c <stm_reply+0x49c>
		} else if (IsSas(priv)) {
			SSP_CMD	*ssp_cmd = (SSP_CMD *)cmd->cmd;

			lun = get2bytes(ssp_cmd->LogicalUnitNumber, 0);
    4c83:	0f b6 42 08          	movzbl 0x8(%edx),%eax
    4c87:	0f b6 4a 09          	movzbl 0x9(%edx),%ecx
    4c8b:	c1 e0 08             	shl    $0x8,%eax
    4c8e:	01 c8                	add    %ecx,%eax
    4c90:	89 45 e8             	mov    %eax,-0x18(%ebp)
			tag = ssp_cmd->InitiatorTag;
    4c93:	0f b7 42 04          	movzwl 0x4(%edx),%eax
    4c97:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    4c9a:	e9 ed fe ff ff       	jmp    4b8c <stm_reply+0x49c>
			FCP_CMD	*fcp_cmd = (FCP_CMD *)cmd->cmd;

			lun = get2bytes(fcp_cmd->FcpLun, 0);
			tag = 0;
		}
		memset(cmd->rsp, 0, sizeof(cmd->rsp));
    4c9f:	66 c7 07 00 00       	movw   $0x0,(%edi)
    4ca4:	83 c7 02             	add    $0x2,%edi
    4ca7:	83 6d ec 02          	subl   $0x2,-0x14(%ebp)
    4cab:	e9 fe fe ff ff       	jmp    4bae <stm_reply+0x4be>
    4cb0:	c6 42 40 00          	movb   $0x0,0x40(%edx)
    4cb4:	8d 7a 41             	lea    0x41(%edx),%edi
    4cb7:	c7 45 ec 3f 00 00 00 	movl   $0x3f,-0x14(%ebp)
    4cbe:	e9 df fe ff ff       	jmp    4ba2 <stm_reply+0x4b2>
		 *  at this point we need to clean up the remains of the I/O
		 *  and repost the command buffer
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s TargetAssistReq IOCStatus = %04x\n",
			       ioc->name, ioc_status);
    4cc3:	8d 47 08             	lea    0x8(%edi),%eax
		 *
		 *  at this point we need to clean up the remains of the I/O
		 *  and repost the command buffer
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s TargetAssistReq IOCStatus = %04x\n",
    4cc6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
			       ioc->name, ioc_status);
    4cca:	89 44 24 04          	mov    %eax,0x4(%esp)
		 *
		 *  at this point we need to clean up the remains of the I/O
		 *  and repost the command buffer
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s TargetAssistReq IOCStatus = %04x\n",
    4cce:	c7 04 24 48 0b 00 00 	movl   $0xb48,(%esp)
    4cd5:	e8 fc ff ff ff       	call   4cd6 <stm_reply+0x5e6>
    4cda:	e9 49 fb ff ff       	jmp    4828 <stm_reply+0x138>
		 *  this is the response to a link service send -- repost the
		 *  link service command buffer
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s FcLinkServRspReq IOCStatus = %04x\n",
			       ioc->name, ioc_status);
    4cdf:	8d 47 08             	lea    0x8(%edi),%eax
		/*
		 *  this is the response to a link service send -- repost the
		 *  link service command buffer
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s FcLinkServRspReq IOCStatus = %04x\n",
    4ce2:	89 4c 24 08          	mov    %ecx,0x8(%esp)
			       ioc->name, ioc_status);
    4ce6:	89 44 24 04          	mov    %eax,0x4(%esp)
		/*
		 *  this is the response to a link service send -- repost the
		 *  link service command buffer
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s FcLinkServRspReq IOCStatus = %04x\n",
    4cea:	c7 04 24 68 0c 00 00 	movl   $0xc68,(%esp)
    4cf1:	e8 fc ff ff ff       	call   4cf2 <stm_reply+0x602>
    4cf6:	8b 07                	mov    (%edi),%eax
    4cf8:	8b 04 85 20 00 00 00 	mov    0x20(,%eax,4),%eax
    4cff:	e9 af fc ff ff       	jmp    49b3 <stm_reply+0x2c3>
		/*
		 *  this signals that the target mode abort is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s FcAbort IOCStatus = %04x\n",
			       ioc->name, ioc_status);
    4d04:	83 c7 08             	add    $0x8,%edi
	case MPI_FUNCTION_FC_ABORT:
		/*
		 *  this signals that the target mode abort is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s FcAbort IOCStatus = %04x\n",
    4d07:	89 4c 24 08          	mov    %ecx,0x8(%esp)
			       ioc->name, ioc_status);
    4d0b:	89 7c 24 04          	mov    %edi,0x4(%esp)
	case MPI_FUNCTION_FC_ABORT:
		/*
		 *  this signals that the target mode abort is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s FcAbort IOCStatus = %04x\n",
    4d0f:	c7 04 24 9c 0c 00 00 	movl   $0xc9c,(%esp)
    4d16:	e8 fc ff ff ff       	call   4d17 <stm_reply+0x627>
    4d1b:	e9 e0 fc ff ff       	jmp    4a00 <stm_reply+0x310>
		/*
		 *  this signals that the extended link service send is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s ExLinkServiceSend IOCStatus = %04x\n",
			       ioc->name, ioc_status);
    4d20:	83 c7 08             	add    $0x8,%edi
	case MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:
		/*
		 *  this signals that the extended link service send is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s ExLinkServiceSend IOCStatus = %04x\n",
    4d23:	89 4c 24 08          	mov    %ecx,0x8(%esp)
			       ioc->name, ioc_status);
    4d27:	89 7c 24 04          	mov    %edi,0x4(%esp)
	case MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:
		/*
		 *  this signals that the extended link service send is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s ExLinkServiceSend IOCStatus = %04x\n",
    4d2b:	c7 04 24 f4 0c 00 00 	movl   $0xcf4,(%esp)
    4d32:	e8 fc ff ff ff       	call   4d33 <stm_reply+0x643>
    4d37:	e9 a4 fc ff ff       	jmp    49e0 <stm_reply+0x2f0>
		/*
		 *  this signals that the command buffer base post is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s TargetCmdBufPostBaseReq IOCStatus = %04x\n",
			       ioc->name, ioc_status);
    4d3c:	83 c7 08             	add    $0x8,%edi
	case MPI_FUNCTION_TARGET_CMD_BUF_BASE_POST:
		/*
		 *  this signals that the command buffer base post is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s TargetCmdBufPostBaseReq IOCStatus = %04x\n",
    4d3f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
			       ioc->name, ioc_status);
    4d43:	89 7c 24 04          	mov    %edi,0x4(%esp)
	case MPI_FUNCTION_TARGET_CMD_BUF_BASE_POST:
		/*
		 *  this signals that the command buffer base post is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s TargetCmdBufPostBaseReq IOCStatus = %04x\n",
    4d47:	c7 04 24 10 0b 00 00 	movl   $0xb10,(%esp)
    4d4e:	e8 fc ff ff ff       	call   4d4f <stm_reply+0x65f>
			       ioc->name, ioc_status);
		}
		return 1;
    4d53:	b8 01 00 00 00       	mov    $0x1,%eax
    4d58:	e9 f0 f9 ff ff       	jmp    474d <stm_reply+0x5d>
		/*
		 *  this signals that the FC primitive send is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s FcPrimitiveSend IOCStatus = %04x\n",
			       ioc->name, ioc_status);
    4d5d:	83 c7 08             	add    $0x8,%edi
	case MPI_FUNCTION_FC_PRIMITIVE_SEND:
		/*
		 *  this signals that the FC primitive send is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s FcPrimitiveSend IOCStatus = %04x\n",
    4d60:	89 4c 24 08          	mov    %ecx,0x8(%esp)
			       ioc->name, ioc_status);
    4d64:	89 7c 24 04          	mov    %edi,0x4(%esp)
	case MPI_FUNCTION_FC_PRIMITIVE_SEND:
		/*
		 *  this signals that the FC primitive send is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s FcPrimitiveSend IOCStatus = %04x\n",
    4d68:	c7 04 24 c4 0c 00 00 	movl   $0xcc4,(%esp)
    4d6f:	e8 fc ff ff ff       	call   4d70 <stm_reply+0x680>
    4d74:	e9 a7 fc ff ff       	jmp    4a20 <stm_reply+0x330>
		/*
		 *  this signals that the target mode abort is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s TargetModeAbort IOCStatus = %04x\n",
			       ioc->name, ioc_status);
    4d79:	8d 47 08             	lea    0x8(%edi),%eax

		/*
		 *  this signals that the target mode abort is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s TargetModeAbort IOCStatus = %04x\n",
    4d7c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
			       ioc->name, ioc_status);
    4d80:	89 44 24 04          	mov    %eax,0x4(%esp)

		/*
		 *  this signals that the target mode abort is done
		 */
		if (ioc_status != MPI_IOCSTATUS_SUCCESS) {
			printk(KERN_ERR MYNAM ":%s TargetModeAbort IOCStatus = %04x\n",
    4d84:	c7 04 24 ac 0b 00 00 	movl   $0xbac,(%esp)
    4d8b:	e8 fc ff ff ff       	call   4d8c <stm_reply+0x69c>
    4d90:	e9 e3 fa ff ff       	jmp    4878 <stm_reply+0x188>
			return 0;
		}
		if (ioc_status == MPI_IOCSTATUS_TARGET_NO_CONNECTION) {
			printk(KERN_ERR MYNAM
			       ": %s: Got MPI_IOCSTATUS_TARGET_NO_CONNECTION\n",
			       ioc->name);
    4d95:	83 c7 08             	add    $0x8,%edi
    4d98:	89 7c 24 04          	mov    %edi,0x4(%esp)
			 */
			WARN_ON(1);
			return 0;
		}
		if (ioc_status == MPI_IOCSTATUS_TARGET_NO_CONNECTION) {
			printk(KERN_ERR MYNAM
    4d9c:	c7 04 24 d8 0a 00 00 	movl   $0xad8,(%esp)
    4da3:	e8 fc ff ff ff       	call   4da4 <stm_reply+0x6b4>
			       ": %s: Got MPI_IOCSTATUS_TARGET_NO_CONNECTION\n",
			       ioc->name);
			return 0;
    4da8:	31 c0                	xor    %eax,%eax
    4daa:	e9 9e f9 ff ff       	jmp    474d <stm_reply+0x5d>
    4daf:	90                   	nop

00004db0 <mpt_rdy_to_xfer>:
 * "atomic" attribute of the command, which can be get via
 * scst_cmd_get_atomic(): it is true if the function called in the
 * atomic (non-sleeping) context. Must be defined.
 */
static int mpt_rdy_to_xfer(struct scst_cmd *scst_cmd)
{
    4db0:	55                   	push   %ebp
    4db1:	89 e5                	mov    %esp,%ebp
    4db3:	57                   	push   %edi
    4db4:	56                   	push   %esi
    4db5:	53                   	push   %ebx
    4db6:	83 ec 3c             	sub    $0x3c,%esp
    4db9:	e8 fc ff ff ff       	call   4dba <mpt_rdy_to_xfer+0xa>
	int res = SCST_TGT_RES_SUCCESS;
	struct mpt_sess *sess;
	/*unsigned long flags = 0;*/
	struct mpt_prm prm = { NULL };
    4dbe:	b9 0a 00 00 00       	mov    $0xa,%ecx
    4dc3:	8d 75 cc             	lea    -0x34(%ebp),%esi
 * "atomic" attribute of the command, which can be get via
 * scst_cmd_get_atomic(): it is true if the function called in the
 * atomic (non-sleeping) context. Must be defined.
 */
static int mpt_rdy_to_xfer(struct scst_cmd *scst_cmd)
{
    4dc6:	89 c3                	mov    %eax,%ebx
	int res = SCST_TGT_RES_SUCCESS;
	struct mpt_sess *sess;
	/*unsigned long flags = 0;*/
	struct mpt_prm prm = { NULL };
    4dc8:	89 f7                	mov    %esi,%edi
    4dca:	31 c0                	xor    %eax,%eax
    4dcc:	f3 ab                	rep stos %eax,%es:(%edi)
#ifdef DEBUG_WORK_IN_THREAD
	if (scst_cmd_atomic(scst_cmd))
		return SCST_TGT_RES_NEED_THREAD_CTX;
#endif

	prm.cmd = (struct mpt_cmd *)scst_cmd_get_tgt_priv(scst_cmd);
    4dce:	8b 83 44 01 00 00    	mov    0x144(%ebx),%eax
    4dd4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	sess = (struct mpt_sess *)
		scst_sess_get_tgt_priv(scst_cmd_get_session(scst_cmd));
    4dd7:	8b 43 10             	mov    0x10(%ebx),%eax
    4dda:	8b 78 08             	mov    0x8(%eax),%edi
	mpt_inquiry_no_tagged_commands(sess->tgt->priv, scst_cmd);
    4ddd:	8b 47 04             	mov    0x4(%edi),%eax
	/*
	 * only modify INQUIRY if we're on a SCSI bus,
	 * and we are handling a standard INQUIRY command
	 * (EVPD = 0)
	 */
	if (IsScsi(priv) && (scst_cmd->cdb[0] == INQUIRY) &&
    4de0:	8b 40 04             	mov    0x4(%eax),%eax
    4de3:	8b 00                	mov    (%eax),%eax
    4de5:	80 b8 69 03 00 00 01 	cmpb   $0x1,0x369(%eax)
    4dec:	74 7a                	je     4e68 <mpt_rdy_to_xfer+0xb8>
    4dee:	8b 93 d8 00 00 00    	mov    0xd8(%ebx),%edx
    4df4:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
	mpt_inquiry_no_tagged_commands(sess->tgt->priv, scst_cmd);

	prm.sg = (struct scatterlist *)NULL;
	prm.bufflen = scst_cmd->bufflen;
	prm.buffer = scst_cmd->sg;
	prm.use_sg = scst_cmd->sg_cnt;
    4dfa:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
	sess = (struct mpt_sess *)
		scst_sess_get_tgt_priv(scst_cmd_get_session(scst_cmd));
	mpt_inquiry_no_tagged_commands(sess->tgt->priv, scst_cmd);

	prm.sg = (struct scatterlist *)NULL;
	prm.bufflen = scst_cmd->bufflen;
    4dfe:	8b 8b d0 00 00 00    	mov    0xd0(%ebx),%ecx
	prm.buffer = scst_cmd->sg;
	prm.use_sg = scst_cmd->sg_cnt;
	prm.data_direction = scst_cmd_get_data_direction(scst_cmd);
    4e04:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
		scst_sess_get_tgt_priv(scst_cmd_get_session(scst_cmd));
	mpt_inquiry_no_tagged_commands(sess->tgt->priv, scst_cmd);

	prm.sg = (struct scatterlist *)NULL;
	prm.bufflen = scst_cmd->bufflen;
	prm.buffer = scst_cmd->sg;
    4e0a:	89 55 dc             	mov    %edx,-0x24(%ebp)
	prm.cmd = (struct mpt_cmd *)scst_cmd_get_tgt_priv(scst_cmd);
	sess = (struct mpt_sess *)
		scst_sess_get_tgt_priv(scst_cmd_get_session(scst_cmd));
	mpt_inquiry_no_tagged_commands(sess->tgt->priv, scst_cmd);

	prm.sg = (struct scatterlist *)NULL;
    4e0d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
	prm.bufflen = scst_cmd->bufflen;
    4e14:	89 4d d8             	mov    %ecx,-0x28(%ebp)
	prm.buffer = scst_cmd->sg;
	prm.use_sg = scst_cmd->sg_cnt;
	prm.data_direction = scst_cmd_get_data_direction(scst_cmd);
    4e17:	89 45 e0             	mov    %eax,-0x20(%ebp)
	prm.tgt = sess->tgt;
    4e1a:	8b 47 04             	mov    0x4(%edi),%eax
    4e1d:	89 45 cc             	mov    %eax,-0x34(%ebp)
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    4e20:	8b 47 0c             	mov    0xc(%edi),%eax

	if (test_bit(MPT_SESS_SHUTDOWN, &sess->sess_flags)) {
    4e23:	a8 02                	test   $0x2,%al
    4e25:	74 21                	je     4e48 <mpt_rdy_to_xfer+0x98>
		TRACE_DBG("cmd %p while session %p is shutting down",
			  prm.cmd, sess);
		scst_rx_data(scst_cmd, SCST_RX_STATUS_ERROR_FATAL,
    4e27:	89 d8                	mov    %ebx,%eax
    4e29:	b9 04 00 00 00       	mov    $0x4,%ecx
    4e2e:	ba 03 00 00 00       	mov    $0x3,%edx
    4e33:	e8 fc ff ff ff       	call   4e34 <mpt_rdy_to_xfer+0x84>

out:
	TRACE_EXIT_RES(res);

	return res;
}
    4e38:	83 c4 3c             	add    $0x3c,%esp
    4e3b:	31 c0                	xor    %eax,%eax
    4e3d:	5b                   	pop    %ebx
    4e3e:	5e                   	pop    %esi
    4e3f:	5f                   	pop    %edi
    4e40:	5d                   	pop    %ebp
    4e41:	c3                   	ret    
    4e42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			     SCST_CONTEXT_SAME);
		res = SCST_TGT_RES_SUCCESS;
		goto out;
	}

	prm.cmd->state = MPT_STATE_NEED_DATA;
    4e48:	8b 45 f0             	mov    -0x10(%ebp),%eax

	mpt_send_target_data(&prm, 0);
    4e4b:	31 d2                	xor    %edx,%edx
			     SCST_CONTEXT_SAME);
		res = SCST_TGT_RES_SUCCESS;
		goto out;
	}

	prm.cmd->state = MPT_STATE_NEED_DATA;
    4e4d:	c7 40 1c 02 00 00 00 	movl   $0x2,0x1c(%eax)

	mpt_send_target_data(&prm, 0);
    4e54:	89 f0                	mov    %esi,%eax
    4e56:	e8 95 db ff ff       	call   29f0 <mpt_send_target_data>

out:
	TRACE_EXIT_RES(res);

	return res;
}
    4e5b:	83 c4 3c             	add    $0x3c,%esp
    4e5e:	31 c0                	xor    %eax,%eax
    4e60:	5b                   	pop    %ebx
    4e61:	5e                   	pop    %esi
    4e62:	5f                   	pop    %edi
    4e63:	5d                   	pop    %ebp
    4e64:	c3                   	ret    
    4e65:	8d 76 00             	lea    0x0(%esi),%esi
	/*
	 * only modify INQUIRY if we're on a SCSI bus,
	 * and we are handling a standard INQUIRY command
	 * (EVPD = 0)
	 */
	if (IsScsi(priv) && (scst_cmd->cdb[0] == INQUIRY) &&
    4e68:	8b 43 78             	mov    0x78(%ebx),%eax
    4e6b:	80 38 12             	cmpb   $0x12,(%eax)
    4e6e:	0f 85 7a ff ff ff    	jne    4dee <mpt_rdy_to_xfer+0x3e>
    4e74:	f6 40 01 01          	testb  $0x1,0x1(%eax)
    4e78:	0f 85 70 ff ff ff    	jne    4dee <mpt_rdy_to_xfer+0x3e>
			!(scst_cmd->cdb[1] & 0x1)) {
		sBUG_ON(scst_cmd->sg_cnt == 0);
    4e7e:	8b 83 d4 00 00 00    	mov    0xd4(%ebx),%eax
    4e84:	85 c0                	test   %eax,%eax
    4e86:	74 72                	je     4efa <mpt_rdy_to_xfer+0x14a>
	return res;
}

static inline int scst_get_buf_first(struct scst_cmd *cmd, uint8_t **buf)
{
	if (unlikely(cmd->sg == NULL)) {
    4e88:	8b 93 d8 00 00 00    	mov    0xd8(%ebx),%edx
    4e8e:	85 d2                	test   %edx,%edx
    4e90:	0f 84 64 ff ff ff    	je     4dfa <mpt_rdy_to_xfer+0x4a>
		*buf = NULL;
		return 0;
	}
	cmd->get_sg_buf_entry_num = 0;
	cmd->get_sg_buf_cur_sg_entry = cmd->sg;
	cmd->may_need_dma_sync = 1;
    4e96:	80 4b 1f 08          	orb    $0x8,0x1f(%ebx)
	uint8_t **buf)
{
	int res = 0;
	struct scatterlist *sg = cmd->get_sg_buf_cur_sg_entry;

	if (cmd->get_sg_buf_entry_num >= sg_cnt) {
    4e9a:	85 c0                	test   %eax,%eax
{
	if (unlikely(cmd->sg == NULL)) {
		*buf = NULL;
		return 0;
	}
	cmd->get_sg_buf_entry_num = 0;
    4e9c:	c7 83 00 01 00 00 00 	movl   $0x0,0x100(%ebx)
    4ea3:	00 00 00 
	cmd->get_sg_buf_cur_sg_entry = cmd->sg;
    4ea6:	89 93 fc 00 00 00    	mov    %edx,0xfc(%ebx)
	uint8_t **buf)
{
	int res = 0;
	struct scatterlist *sg = cmd->get_sg_buf_cur_sg_entry;

	if (cmd->get_sg_buf_entry_num >= sg_cnt) {
    4eac:	0f 8e 48 ff ff ff    	jle    4dfa <mpt_rdy_to_xfer+0x4a>
{
#ifdef CONFIG_DEBUG_SG
	BUG_ON(sg->sg_magic != SG_MAGIC);
	BUG_ON(sg_is_chain(sg));
#endif
	return (struct page *)((sg)->page_link & ~0x3);
    4eb2:	8b 02                	mov    (%edx),%eax
    4eb4:	89 55 c8             	mov    %edx,-0x38(%ebp)
    4eb7:	83 e0 fc             	and    $0xfffffffc,%eax
		*buf = NULL;
		goto out;
	}

	*buf = page_address(sg_page(sg));
    4eba:	e8 fc ff ff ff       	call   4ebb <mpt_rdy_to_xfer+0x10b>
	*buf += sg->offset;
    4ebf:	8b 55 c8             	mov    -0x38(%ebp),%edx

	res = sg->length;
    4ec2:	8b 4a 08             	mov    0x8(%edx),%ecx
		*buf = NULL;
		goto out;
	}

	*buf = page_address(sg_page(sg));
	*buf += sg->offset;
    4ec5:	03 42 04             	add    0x4(%edx),%eax

	res = sg->length;

	cmd->get_sg_buf_entry_num++;
    4ec8:	83 83 00 01 00 00 01 	addl   $0x1,0x100(%ebx)
	}

	*buf = page_address(sg_page(sg));
	*buf += sg->offset;

	res = sg->length;
    4ecf:	89 4d c8             	mov    %ecx,-0x38(%ebp)

#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24) */

static inline struct scatterlist *__sg_next_inline(struct scatterlist *sg)
{
	sg++;
    4ed2:	8d 4a 18             	lea    0x18(%edx),%ecx
	if (unlikely(sg_is_chain(sg)))
    4ed5:	8b 52 18             	mov    0x18(%edx),%edx
    4ed8:	f6 c2 01             	test   $0x1,%dl
    4edb:	75 65                	jne    4f42 <mpt_rdy_to_xfer+0x192>
		length = scst_get_buf_first(scst_cmd, &address);
		if (length >= 8) {
    4edd:	83 7d c8 07          	cmpl   $0x7,-0x38(%ebp)
	*buf += sg->offset;

	res = sg->length;

	cmd->get_sg_buf_entry_num++;
	cmd->get_sg_buf_cur_sg_entry = __sg_next_inline(sg);
    4ee1:	89 8b fc 00 00 00    	mov    %ecx,0xfc(%ebx)
    4ee7:	0f 8e 01 ff ff ff    	jle    4dee <mpt_rdy_to_xfer+0x3e>
			TRACE_DBG("clearing BQUE + CMDQUE 0x%p", address);
			address[6] &= ~0x80; /* turn off BQUE */
    4eed:	80 60 06 7f          	andb   $0x7f,0x6(%eax)
			address[7] &= ~0x02; /* turn off CMDQUE */
    4ef1:	80 60 07 fd          	andb   $0xfd,0x7(%eax)
    4ef5:	e9 f4 fe ff ff       	jmp    4dee <mpt_rdy_to_xfer+0x3e>
	 * and we are handling a standard INQUIRY command
	 * (EVPD = 0)
	 */
	if (IsScsi(priv) && (scst_cmd->cdb[0] == INQUIRY) &&
			!(scst_cmd->cdb[1] & 0x1)) {
		sBUG_ON(scst_cmd->sg_cnt == 0);
    4efa:	c7 44 24 0c d2 01 00 	movl   $0x1d2,0xc(%esp)
    4f01:	00 
    4f02:	c7 44 24 08 d6 06 00 	movl   $0x6d6,0x8(%esp)
    4f09:	00 
    4f0a:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
    4f11:	00 
    4f12:	c7 04 24 b3 00 00 00 	movl   $0xb3,(%esp)
    4f19:	e8 fc ff ff ff       	call   4f1a <mpt_rdy_to_xfer+0x16a>
    4f1e:	ff 15 0c 00 00 00    	call   *0xc
    4f24:	eb 0f                	jmp    4f35 <mpt_rdy_to_xfer+0x185>
    4f26:	ba 00 02 00 00       	mov    $0x200,%edx
    4f2b:	b8 26 4f 00 00       	mov    $0x4f26,%eax
    4f30:	e8 fc ff ff ff       	call   4f31 <mpt_rdy_to_xfer+0x181>
    4f35:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
    4f3b:	f6 c4 ff             	test   $0xff,%ah
    4f3e:	75 e6                	jne    4f26 <mpt_rdy_to_xfer+0x176>
    4f40:	0f 0b                	ud2    

static inline struct scatterlist *__sg_next_inline(struct scatterlist *sg)
{
	sg++;
	if (unlikely(sg_is_chain(sg)))
		sg = sg_chain_ptr(sg);
    4f42:	83 e2 fc             	and    $0xfffffffc,%edx
    4f45:	89 d1                	mov    %edx,%ecx
    4f47:	eb 94                	jmp    4edd <mpt_rdy_to_xfer+0x12d>
    4f49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00004f50 <mpt_xmit_response>:
 * this function is equivalent to the SCSI queuecommand(). The target should
 * transmit the response data and the status in the struct scst_cmd. See
 * below for details. Must be defined.
 */
static int mpt_xmit_response(struct scst_cmd *scst_cmd)
{
    4f50:	55                   	push   %ebp
    4f51:	89 e5                	mov    %esp,%ebp
    4f53:	57                   	push   %edi
    4f54:	56                   	push   %esi
    4f55:	53                   	push   %ebx
    4f56:	83 ec 4c             	sub    $0x4c,%esp
    4f59:	e8 fc ff ff ff       	call   4f5a <mpt_xmit_response+0xa>
	int res = SCST_TGT_RES_SUCCESS;
	struct mpt_sess *sess;
	struct mpt_prm prm = { NULL };
    4f5e:	b9 0a 00 00 00       	mov    $0xa,%ecx
 * this function is equivalent to the SCSI queuecommand(). The target should
 * transmit the response data and the status in the struct scst_cmd. See
 * below for details. Must be defined.
 */
static int mpt_xmit_response(struct scst_cmd *scst_cmd)
{
    4f63:	89 c3                	mov    %eax,%ebx
	int res = SCST_TGT_RES_SUCCESS;
	struct mpt_sess *sess;
	struct mpt_prm prm = { NULL };
    4f65:	31 c0                	xor    %eax,%eax
    4f67:	8d 7d cc             	lea    -0x34(%ebp),%edi
	sess = (struct mpt_sess *)
		scst_sess_get_tgt_priv(scst_cmd_get_session(scst_cmd));

	prm.sg = NULL;
	prm.bufflen = scst_cmd_get_resp_data_len(scst_cmd);
	prm.buffer = scst_cmd->sg;
    4f6a:	8b 93 d8 00 00 00    	mov    0xd8(%ebx),%edx
 */
static int mpt_xmit_response(struct scst_cmd *scst_cmd)
{
	int res = SCST_TGT_RES_SUCCESS;
	struct mpt_sess *sess;
	struct mpt_prm prm = { NULL };
    4f70:	f3 ab                	rep stos %eax,%es:(%edi)
/*
 * this function is equivalent to the SCSI queuecommand(). The target should
 * transmit the response data and the status in the struct scst_cmd. See
 * below for details. Must be defined.
 */
static int mpt_xmit_response(struct scst_cmd *scst_cmd)
    4f72:	8b 83 44 01 00 00    	mov    0x144(%ebx),%eax
	prm.buffer = scst_cmd->sg;
	prm.use_sg = scst_cmd->sg_cnt;
	prm.data_direction = scst_cmd_get_data_direction(scst_cmd);
	prm.rq_result = scst_cmd_get_status(scst_cmd);
	prm.sense_buffer = scst_cmd_get_sense_buffer(scst_cmd);
	prm.sense_buffer_len = scst_cmd_get_sense_buffer_len(scst_cmd);
    4f78:	0f b7 8b 3c 01 00 00 	movzwl 0x13c(%ebx),%ecx
/*
 * this function is equivalent to the SCSI queuecommand(). The target should
 * transmit the response data and the status in the struct scst_cmd. See
 * below for details. Must be defined.
 */
static int mpt_xmit_response(struct scst_cmd *scst_cmd)
    4f7f:	8b bb e8 00 00 00    	mov    0xe8(%ebx),%edi
	prm.sg = NULL;
	prm.bufflen = scst_cmd_get_resp_data_len(scst_cmd);
	prm.buffer = scst_cmd->sg;
	prm.use_sg = scst_cmd->sg_cnt;
	prm.data_direction = scst_cmd_get_data_direction(scst_cmd);
	prm.rq_result = scst_cmd_get_status(scst_cmd);
    4f85:	0f b6 b3 2c 01 00 00 	movzbl 0x12c(%ebx),%esi
#ifdef DEBUG_WORK_IN_THREAD
	if (scst_cmd_atomic(scst_cmd))
		return SCST_TGT_RES_NEED_THREAD_CTX;
#endif

	prm.cmd = (struct mpt_cmd *)scst_cmd_get_tgt_priv(scst_cmd);
    4f8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/*
 * this function is equivalent to the SCSI queuecommand(). The target should
 * transmit the response data and the status in the struct scst_cmd. See
 * below for details. Must be defined.
 */
static int mpt_xmit_response(struct scst_cmd *scst_cmd)
    4f8f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		return SCST_TGT_RES_NEED_THREAD_CTX;
#endif

	prm.cmd = (struct mpt_cmd *)scst_cmd_get_tgt_priv(scst_cmd);
	sess = (struct mpt_sess *)
		scst_sess_get_tgt_priv(scst_cmd_get_session(scst_cmd));
    4f92:	8b 43 10             	mov    0x10(%ebx),%eax
	prm.buffer = scst_cmd->sg;
	prm.use_sg = scst_cmd->sg_cnt;
	prm.data_direction = scst_cmd_get_data_direction(scst_cmd);
	prm.rq_result = scst_cmd_get_status(scst_cmd);
	prm.sense_buffer = scst_cmd_get_sense_buffer(scst_cmd);
	prm.sense_buffer_len = scst_cmd_get_sense_buffer_len(scst_cmd);
    4f95:	89 4d c8             	mov    %ecx,-0x38(%ebp)
	TRACE_DBG("rq_result=%x, is_send_status=%x, %x, %d", prm.rq_result,
			is_send_status, prm.bufflen, prm.sense_buffer_len);
	if ((prm.rq_result != 0) && (prm.sense_buffer != NULL))
		TRACE_BUFFER("Sense", prm.sense_buffer, prm.sense_buffer_len);

	if (!is_send_status) {
    4f98:	f6 43 1d 01          	testb  $0x1,0x1d(%ebx)
		return SCST_TGT_RES_NEED_THREAD_CTX;
#endif

	prm.cmd = (struct mpt_cmd *)scst_cmd_get_tgt_priv(scst_cmd);
	sess = (struct mpt_sess *)
		scst_sess_get_tgt_priv(scst_cmd_get_session(scst_cmd));
    4f9c:	8b 40 08             	mov    0x8(%eax),%eax

	prm.sg = NULL;
	prm.bufflen = scst_cmd_get_resp_data_len(scst_cmd);
	prm.buffer = scst_cmd->sg;
    4f9f:	89 55 dc             	mov    %edx,-0x24(%ebp)
	prm.use_sg = scst_cmd->sg_cnt;
    4fa2:	8b 93 d4 00 00 00    	mov    0xd4(%ebx),%edx
	prm.cmd = (struct mpt_cmd *)scst_cmd_get_tgt_priv(scst_cmd);
	sess = (struct mpt_sess *)
		scst_sess_get_tgt_priv(scst_cmd_get_session(scst_cmd));

	prm.sg = NULL;
	prm.bufflen = scst_cmd_get_resp_data_len(scst_cmd);
    4fa8:	89 7d d8             	mov    %edi,-0x28(%ebp)
	prm.buffer = scst_cmd->sg;
	prm.use_sg = scst_cmd->sg_cnt;
	prm.data_direction = scst_cmd_get_data_direction(scst_cmd);
	prm.rq_result = scst_cmd_get_status(scst_cmd);
    4fab:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
	prm.sense_buffer = scst_cmd_get_sense_buffer(scst_cmd);
	prm.sense_buffer_len = scst_cmd_get_sense_buffer_len(scst_cmd);
    4faf:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		scst_sess_get_tgt_priv(scst_cmd_get_session(scst_cmd));

	prm.sg = NULL;
	prm.bufflen = scst_cmd_get_resp_data_len(scst_cmd);
	prm.buffer = scst_cmd->sg;
	prm.use_sg = scst_cmd->sg_cnt;
    4fb2:	66 89 55 d2          	mov    %dx,-0x2e(%ebp)
	prm.data_direction = scst_cmd_get_data_direction(scst_cmd);
    4fb6:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    4fbc:	89 55 e0             	mov    %edx,-0x20(%ebp)
/*
 * this function is equivalent to the SCSI queuecommand(). The target should
 * transmit the response data and the status in the struct scst_cmd. See
 * below for details. Must be defined.
 */
static int mpt_xmit_response(struct scst_cmd *scst_cmd)
    4fbf:	8b 93 38 01 00 00    	mov    0x138(%ebx),%edx
	prm.bufflen = scst_cmd_get_resp_data_len(scst_cmd);
	prm.buffer = scst_cmd->sg;
	prm.use_sg = scst_cmd->sg_cnt;
	prm.data_direction = scst_cmd_get_data_direction(scst_cmd);
	prm.rq_result = scst_cmd_get_status(scst_cmd);
	prm.sense_buffer = scst_cmd_get_sense_buffer(scst_cmd);
    4fc5:	89 55 e8             	mov    %edx,-0x18(%ebp)
	prm.sense_buffer_len = scst_cmd_get_sense_buffer_len(scst_cmd);
	prm.tgt = sess->tgt;
    4fc8:	8b 48 04             	mov    0x4(%eax),%ecx
    4fcb:	89 4d cc             	mov    %ecx,-0x34(%ebp)
	TRACE_DBG("rq_result=%x, is_send_status=%x, %x, %d", prm.rq_result,
			is_send_status, prm.bufflen, prm.sense_buffer_len);
	if ((prm.rq_result != 0) && (prm.sense_buffer != NULL))
		TRACE_BUFFER("Sense", prm.sense_buffer, prm.sense_buffer_len);

	if (!is_send_status) {
    4fce:	0f 84 cc 00 00 00    	je     50a0 <mpt_xmit_response+0x150>
    4fd4:	8b 40 0c             	mov    0xc(%eax),%eax
			    "feature not implemented %p", scst_cmd);
		res = SCST_TGT_RES_FATAL_ERROR;
		goto out_tgt_free;
	}

	if (test_bit(MPT_SESS_SHUTDOWN, &sess->sess_flags)) {
    4fd7:	a8 02                	test   $0x2,%al
    4fd9:	0f 85 a9 00 00 00    	jne    5088 <mpt_xmit_response+0x138>
 *************************************************************/
#define SCST_LOAD_SENSE(key_asc_ascq) key_asc_ascq

static inline int scst_sense_valid(const uint8_t *sense)
{
	return (sense != NULL) && ((sense[0] & 0x70) == 0x70);
    4fdf:	85 d2                	test   %edx,%edx
    4fe1:	74 0e                	je     4ff1 <mpt_xmit_response+0xa1>
    4fe3:	0f b6 02             	movzbl (%edx),%eax
    4fe6:	83 e0 70             	and    $0x70,%eax
    4fe9:	3c 70                	cmp    $0x70,%al
    4feb:	0f 84 3f 01 00 00    	je     5130 <mpt_xmit_response+0x1e0>
	if (scst_sense_valid(prm.sense_buffer)) {
		mpt_set_sense_info(prm.tgt->priv, prm.cmd->CMD,
				prm.sense_buffer_len, prm.sense_buffer);
	}

	if (scst_cmd_get_resp_data_len(scst_cmd) > 0) {
    4ff1:	85 ff                	test   %edi,%edi
    4ff3:	7e 28                	jle    501d <mpt_xmit_response+0xcd>
		int flags = 0;

		if (prm.rq_result == 0)
			flags |= TARGET_ASSIST_FLAGS_AUTO_STATUS;
    4ff5:	66 83 fe 01          	cmp    $0x1,%si
    4ff9:	19 f6                	sbb    %esi,%esi
    4ffb:	83 e6 02             	and    $0x2,%esi
		if (scst_get_may_need_dma_sync(scst_cmd)) {
    4ffe:	f6 43 1f 08          	testb  $0x8,0x1f(%ebx)
    5002:	0f 85 d8 00 00 00    	jne    50e0 <mpt_xmit_response+0x190>
			dma_sync_sg_for_cpu(&(prm.tgt->priv->ioc->pcidev->dev),
				scst_cmd->sg, scst_cmd->sg_cnt,
				scst_to_tgt_dma_dir(scst_cmd_get_data_direction(scst_cmd)));
		}
		mpt_send_target_data(&prm, flags);
    5008:	89 f2                	mov    %esi,%edx
 * transmit the response data and the status in the struct scst_cmd. See
 * below for details. Must be defined.
 */
static int mpt_xmit_response(struct scst_cmd *scst_cmd)
{
	int res = SCST_TGT_RES_SUCCESS;
    500a:	31 ff                	xor    %edi,%edi
		if (scst_get_may_need_dma_sync(scst_cmd)) {
			dma_sync_sg_for_cpu(&(prm.tgt->priv->ioc->pcidev->dev),
				scst_cmd->sg, scst_cmd->sg_cnt,
				scst_to_tgt_dma_dir(scst_cmd_get_data_direction(scst_cmd)));
		}
		mpt_send_target_data(&prm, flags);
    500c:	8d 45 cc             	lea    -0x34(%ebp),%eax
    500f:	e8 dc d9 ff ff       	call   29f0 <mpt_send_target_data>

		if (prm.rq_result == 0)
    5014:	0f b7 75 e4          	movzwl -0x1c(%ebp),%esi
    5018:	66 85 f6             	test   %si,%si
    501b:	74 79                	je     5096 <mpt_xmit_response+0x146>
			goto out;
	}
	{
		int flags = 0;
		u32 reply_word = prm.cmd->CMD->reply_word;
    501d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5020:	8b 40 0c             	mov    0xc(%eax),%eax
		int index = GET_IO_INDEX(reply_word);
		int lun = prm.cmd->CMD->lun;
    5023:	8b b8 e8 03 00 00    	mov    0x3e8(%eax),%edi
		if (prm.rq_result == 0)
			goto out;
	}
	{
		int flags = 0;
		u32 reply_word = prm.cmd->CMD->reply_word;
    5029:	8b 90 e0 03 00 00    	mov    0x3e0(%eax),%edx
		int index = GET_IO_INDEX(reply_word);
		int lun = prm.cmd->CMD->lun;
		int tag = prm.cmd->CMD->tag;
    502f:	8b 80 ec 03 00 00    	mov    0x3ec(%eax),%eax
	}
	{
		int flags = 0;
		u32 reply_word = prm.cmd->CMD->reply_word;
		int index = GET_IO_INDEX(reply_word);
		int lun = prm.cmd->CMD->lun;
    5035:	89 7d c8             	mov    %edi,-0x38(%ebp)
			goto out;
	}
	{
		int flags = 0;
		u32 reply_word = prm.cmd->CMD->reply_word;
		int index = GET_IO_INDEX(reply_word);
    5038:	89 d1                	mov    %edx,%ecx
		int lun = prm.cmd->CMD->lun;
		int tag = prm.cmd->CMD->tag;
    503a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		MPT_STM_PRIV *priv = prm.tgt->priv;
    503d:	8b 45 cc             	mov    -0x34(%ebp),%eax
			goto out;
	}
	{
		int flags = 0;
		u32 reply_word = prm.cmd->CMD->reply_word;
		int index = GET_IO_INDEX(reply_word);
    5040:	81 e1 ff 3f 00 00    	and    $0x3fff,%ecx
		int lun = prm.cmd->CMD->lun;
		int tag = prm.cmd->CMD->tag;
		MPT_STM_PRIV *priv = prm.tgt->priv;
    5046:	8b 40 04             	mov    0x4(%eax),%eax
    5049:	8d 3c 88             	lea    (%eax,%ecx,4),%edi

		if (prm.rq_result == 0)
			flags |= TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS;

		flags |= TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER;
		priv->io_state[index] |= IO_STATE_AUTO_REPOST;
    504c:	8b 9f a0 00 00 00    	mov    0xa0(%edi),%ebx
    5052:	83 cb 20             	or     $0x20,%ebx
    5055:	89 9f a0 00 00 00    	mov    %ebx,0xa0(%edi)

		TRACE_DBG("scst cmd %p, index %d, flags %d", scst_cmd, index,
			  flags);

		stm_send_target_status(priv, reply_word, index, flags, lun,
    505b:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
    505e:	8b 7d c8             	mov    -0x38(%ebp),%edi
    5061:	89 5c 24 08          	mov    %ebx,0x8(%esp)
		int index = GET_IO_INDEX(reply_word);
		int lun = prm.cmd->CMD->lun;
		int tag = prm.cmd->CMD->tag;
		MPT_STM_PRIV *priv = prm.tgt->priv;

		if (prm.rq_result == 0)
    5065:	31 db                	xor    %ebx,%ebx
    5067:	66 85 f6             	test   %si,%si
    506a:	0f 94 c3             	sete   %bl
			flags |= TARGET_STATUS_SEND_FLAGS_AUTO_GOOD_STATUS;

		flags |= TARGET_STATUS_SEND_FLAGS_REPOST_CMD_BUFFER;
    506d:	80 cb 80             	or     $0x80,%bl
		priv->io_state[index] |= IO_STATE_AUTO_REPOST;

		TRACE_DBG("scst cmd %p, index %d, flags %d", scst_cmd, index,
			  flags);

		stm_send_target_status(priv, reply_word, index, flags, lun,
    5070:	89 7c 24 04          	mov    %edi,0x4(%esp)
 * transmit the response data and the status in the struct scst_cmd. See
 * below for details. Must be defined.
 */
static int mpt_xmit_response(struct scst_cmd *scst_cmd)
{
	int res = SCST_TGT_RES_SUCCESS;
    5074:	31 ff                	xor    %edi,%edi
		priv->io_state[index] |= IO_STATE_AUTO_REPOST;

		TRACE_DBG("scst cmd %p, index %d, flags %d", scst_cmd, index,
			  flags);

		stm_send_target_status(priv, reply_word, index, flags, lun,
    5076:	89 1c 24             	mov    %ebx,(%esp)
    5079:	e8 42 bf ff ff       	call   fc0 <stm_send_target_status>

out_tgt_free:
	/* ToDo: check and set scst_set_delivery_status(), if necessary */
	scst_tgt_cmd_done(scst_cmd, SCST_CONTEXT_SAME);
	goto out;
}
    507e:	83 c4 4c             	add    $0x4c,%esp
    5081:	89 f8                	mov    %edi,%eax
    5083:	5b                   	pop    %ebx
    5084:	5e                   	pop    %esi
    5085:	5f                   	pop    %edi
    5086:	5d                   	pop    %ebp
    5087:	c3                   	ret    
	}

	if (test_bit(MPT_SESS_SHUTDOWN, &sess->sess_flags)) {
		TRACE_DBG("cmd %p while session %p is shutting down",
			  prm.cmd, sess);
		res = SCST_TGT_RES_SUCCESS;
    5088:	31 ff                	xor    %edi,%edi

	return res;

out_tgt_free:
	/* ToDo: check and set scst_set_delivery_status(), if necessary */
	scst_tgt_cmd_done(scst_cmd, SCST_CONTEXT_SAME);
    508a:	ba 04 00 00 00       	mov    $0x4,%edx
    508f:	89 d8                	mov    %ebx,%eax
    5091:	e8 fc ff ff ff       	call   5092 <mpt_xmit_response+0x142>
	goto out;
}
    5096:	83 c4 4c             	add    $0x4c,%esp
    5099:	89 f8                	mov    %edi,%eax
    509b:	5b                   	pop    %ebx
    509c:	5e                   	pop    %esi
    509d:	5f                   	pop    %edi
    509e:	5d                   	pop    %ebp
    509f:	c3                   	ret    
	if ((prm.rq_result != 0) && (prm.sense_buffer != NULL))
		TRACE_BUFFER("Sense", prm.sense_buffer, prm.sense_buffer_len);

	if (!is_send_status) {
		/* ToDo, after it's done in SCST */
		PRINT_ERROR(MYNAM ": is_send_status not set: "
    50a0:	89 5c 24 18          	mov    %ebx,0x18(%esp)
			    "feature not implemented %p", scst_cmd);
		res = SCST_TGT_RES_FATAL_ERROR;
    50a4:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
	if ((prm.rq_result != 0) && (prm.sense_buffer != NULL))
		TRACE_BUFFER("Sense", prm.sense_buffer, prm.sense_buffer_len);

	if (!is_send_status) {
		/* ToDo, after it's done in SCST */
		PRINT_ERROR(MYNAM ": is_send_status not set: "
    50a9:	c7 44 24 14 78 0d 00 	movl   $0xd78,0x14(%esp)
    50b0:	00 
    50b1:	c7 44 24 10 81 06 00 	movl   $0x681,0x10(%esp)
    50b8:	00 
    50b9:	c7 44 24 0c 9c 02 00 	movl   $0x29c,0xc(%esp)
    50c0:	00 
    50c1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    50c8:	00 
    50c9:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
    50d0:	00 
    50d1:	c7 04 24 02 21 00 00 	movl   $0x2102,(%esp)
    50d8:	e8 fc ff ff ff       	call   50d9 <mpt_xmit_response+0x189>
			    "feature not implemented %p", scst_cmd);
		res = SCST_TGT_RES_FATAL_ERROR;
		goto out_tgt_free;
    50dd:	eb ab                	jmp    508a <mpt_xmit_response+0x13a>
    50df:	90                   	nop
		int flags = 0;

		if (prm.rq_result == 0)
			flags |= TARGET_ASSIST_FLAGS_AUTO_STATUS;
		if (scst_get_may_need_dma_sync(scst_cmd)) {
			dma_sync_sg_for_cpu(&(prm.tgt->priv->ioc->pcidev->dev),
    50e0:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    50e6:	e8 fc ff ff ff       	call   50e7 <mpt_xmit_response+0x197>
    50eb:	8b 8b d4 00 00 00    	mov    0xd4(%ebx),%ecx
    50f1:	8b 93 d8 00 00 00    	mov    0xd8(%ebx),%edx
    50f7:	8b 5d cc             	mov    -0x34(%ebp),%ebx
    50fa:	8b 5b 04             	mov    0x4(%ebx),%ebx
    50fd:	8b 1b                	mov    (%ebx),%ebx
    50ff:	8b bb 48 01 00 00    	mov    0x148(%ebx),%edi
    5105:	8b 1d 00 00 00 00    	mov    0x0,%ebx
    510b:	83 c7 64             	add    $0x64,%edi
dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
		    int nelems, enum dma_data_direction dir)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
    510e:	83 f8 02             	cmp    $0x2,%eax
    5111:	0f 87 e9 00 00 00    	ja     5200 <mpt_xmit_response+0x2b0>
	if (ops->sync_sg_for_cpu)
    5117:	8b 5b 28             	mov    0x28(%ebx),%ebx
    511a:	85 db                	test   %ebx,%ebx
    511c:	0f 84 e6 fe ff ff    	je     5008 <mpt_xmit_response+0xb8>
		ops->sync_sg_for_cpu(dev, sg, nelems, dir);
    5122:	89 04 24             	mov    %eax,(%esp)
    5125:	89 f8                	mov    %edi,%eax
    5127:	ff d3                	call   *%ebx
    5129:	e9 da fe ff ff       	jmp    5008 <mpt_xmit_response+0xb8>
    512e:	66 90                	xchg   %ax,%ax
		res = SCST_TGT_RES_SUCCESS;
		goto out_tgt_free;
	}

	if (scst_sense_valid(prm.sense_buffer)) {
		mpt_set_sense_info(prm.tgt->priv, prm.cmd->CMD,
    5130:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5133:	8b 78 0c             	mov    0xc(%eax),%edi
{
	u8 *info = NULL;

	TRACE_ENTRY();

	if (IsScsi(priv)) {
    5136:	8b 41 04             	mov    0x4(%ecx),%eax
    5139:	8b 00                	mov    (%eax),%eax
    513b:	0f b6 80 69 03 00 00 	movzbl 0x369(%eax),%eax
    5142:	3c 01                	cmp    $0x1,%al
    5144:	74 5a                	je     51a0 <mpt_xmit_response+0x250>
		rsp->Valid |= SCSI_SENSE_LEN_VALID;
		rsp->SenseDataListLength = cpu_to_be32(len);
		info = rsp->SenseData;
		if (rsp->Valid & SCSI_RSP_LEN_VALID)
			info += be32_to_cpu(rsp->PktFailuresListLength);
	} else if (IsSas(priv)) {
    5146:	3c 30                	cmp    $0x30,%al
    5148:	0f 84 82 00 00 00    	je     51d0 <mpt_xmit_response+0x280>
			info += be32_to_cpu(rsp->ResponseDataLength);
	} else {
		FCP_RSP *rsp = (FCP_RSP *)cmd->rsp;

		rsp->FcpStatus = STS_CHECK_CONDITION;
		rsp->FcpFlags |= FCP_SENSE_LEN_VALID;
    514e:	0f b6 77 4a          	movzbl 0x4a(%edi),%esi
		if (rsp->DataPres & SSP_RSP_LEN_VALID)
			info += be32_to_cpu(rsp->ResponseDataLength);
	} else {
		FCP_RSP *rsp = (FCP_RSP *)cmd->rsp;

		rsp->FcpStatus = STS_CHECK_CONDITION;
    5152:	c6 47 4b 02          	movb   $0x2,0x4b(%edi)
		rsp->FcpFlags |= FCP_SENSE_LEN_VALID;
    5156:	89 f0                	mov    %esi,%eax
    5158:	83 c8 02             	or     $0x2,%eax
		rsp->FcpSenseLength = cpu_to_be32(len);
		info = rsp->FcpSenseData - sizeof(rsp->FcpResponseData);
		if (rsp->FcpFlags & FCP_RSP_LEN_VALID)
    515b:	83 e6 01             	and    $0x1,%esi
			info += be32_to_cpu(rsp->ResponseDataLength);
	} else {
		FCP_RSP *rsp = (FCP_RSP *)cmd->rsp;

		rsp->FcpStatus = STS_CHECK_CONDITION;
		rsp->FcpFlags |= FCP_SENSE_LEN_VALID;
    515e:	88 47 4a             	mov    %al,0x4a(%edi)
    5161:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5164:	0f c8                	bswap  %eax
		rsp->FcpSenseLength = cpu_to_be32(len);
    5166:	89 47 50             	mov    %eax,0x50(%edi)
		info = rsp->FcpSenseData - sizeof(rsp->FcpResponseData);
    5169:	8d 47 58             	lea    0x58(%edi),%eax
		if (rsp->FcpFlags & FCP_RSP_LEN_VALID)
    516c:	75 22                	jne    5190 <mpt_xmit_response+0x240>
			info += be32_to_cpu(rsp->FcpResponseLength);
	}

	sBUG_ON(info == NULL);
    516e:	85 c0                	test   %eax,%eax
    5170:	0f 84 8f 00 00 00    	je     5205 <mpt_xmit_response+0x2b5>
	memcpy(info, sense_buf, len);
    5176:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    5179:	e8 fc ff ff ff       	call   517a <mpt_xmit_response+0x22a>
    517e:	8b bb e8 00 00 00    	mov    0xe8(%ebx),%edi
    5184:	0f b7 75 e4          	movzwl -0x1c(%ebp),%esi
    5188:	e9 64 fe ff ff       	jmp    4ff1 <mpt_xmit_response+0xa1>
    518d:	8d 76 00             	lea    0x0(%esi),%esi
    5190:	8b 77 54             	mov    0x54(%edi),%esi
    5193:	0f ce                	bswap  %esi
		rsp->FcpStatus = STS_CHECK_CONDITION;
		rsp->FcpFlags |= FCP_SENSE_LEN_VALID;
		rsp->FcpSenseLength = cpu_to_be32(len);
		info = rsp->FcpSenseData - sizeof(rsp->FcpResponseData);
		if (rsp->FcpFlags & FCP_RSP_LEN_VALID)
			info += be32_to_cpu(rsp->FcpResponseLength);
    5195:	01 f0                	add    %esi,%eax
    5197:	eb d5                	jmp    516e <mpt_xmit_response+0x21e>
    5199:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	if (IsScsi(priv)) {
		SCSI_RSP *rsp = (SCSI_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
		rsp->Valid |= SCSI_SENSE_LEN_VALID;
    51a0:	0f b6 77 42          	movzbl 0x42(%edi),%esi
	TRACE_ENTRY();

	if (IsScsi(priv)) {
		SCSI_RSP *rsp = (SCSI_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
    51a4:	c6 47 43 02          	movb   $0x2,0x43(%edi)
		rsp->Valid |= SCSI_SENSE_LEN_VALID;
    51a8:	89 f0                	mov    %esi,%eax
    51aa:	83 c8 02             	or     $0x2,%eax
		rsp->SenseDataListLength = cpu_to_be32(len);
		info = rsp->SenseData;
		if (rsp->Valid & SCSI_RSP_LEN_VALID)
    51ad:	83 e6 01             	and    $0x1,%esi

	if (IsScsi(priv)) {
		SCSI_RSP *rsp = (SCSI_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
		rsp->Valid |= SCSI_SENSE_LEN_VALID;
    51b0:	88 47 42             	mov    %al,0x42(%edi)
    51b3:	8b 45 c8             	mov    -0x38(%ebp),%eax
    51b6:	0f c8                	bswap  %eax
		rsp->SenseDataListLength = cpu_to_be32(len);
    51b8:	89 47 44             	mov    %eax,0x44(%edi)
		info = rsp->SenseData;
    51bb:	8d 47 4c             	lea    0x4c(%edi),%eax
		if (rsp->Valid & SCSI_RSP_LEN_VALID)
    51be:	74 ae                	je     516e <mpt_xmit_response+0x21e>
    51c0:	8b 77 48             	mov    0x48(%edi),%esi
    51c3:	0f ce                	bswap  %esi
			info += be32_to_cpu(rsp->PktFailuresListLength);
    51c5:	01 f0                	add    %esi,%eax
    51c7:	eb a5                	jmp    516e <mpt_xmit_response+0x21e>
    51c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	} else if (IsSas(priv)) {
		SSP_RSP *rsp = (SSP_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
		rsp->DataPres |= SSP_SENSE_LEN_VALID;
    51d0:	0f b6 77 62          	movzbl 0x62(%edi),%esi
		if (rsp->Valid & SCSI_RSP_LEN_VALID)
			info += be32_to_cpu(rsp->PktFailuresListLength);
	} else if (IsSas(priv)) {
		SSP_RSP *rsp = (SSP_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
    51d4:	c6 47 63 02          	movb   $0x2,0x63(%edi)
		rsp->DataPres |= SSP_SENSE_LEN_VALID;
    51d8:	89 f0                	mov    %esi,%eax
    51da:	83 c8 02             	or     $0x2,%eax
		rsp->SenseDataLength = cpu_to_be32(len);
		info = rsp->ResponseSenseData;
		if (rsp->DataPres & SSP_RSP_LEN_VALID)
    51dd:	83 e6 01             	and    $0x1,%esi
			info += be32_to_cpu(rsp->PktFailuresListLength);
	} else if (IsSas(priv)) {
		SSP_RSP *rsp = (SSP_RSP *)cmd->rsp;

		rsp->Status = STS_CHECK_CONDITION;
		rsp->DataPres |= SSP_SENSE_LEN_VALID;
    51e0:	88 47 62             	mov    %al,0x62(%edi)
    51e3:	8b 45 c8             	mov    -0x38(%ebp),%eax
    51e6:	0f c8                	bswap  %eax
		rsp->SenseDataLength = cpu_to_be32(len);
    51e8:	89 47 68             	mov    %eax,0x68(%edi)
		info = rsp->ResponseSenseData;
    51eb:	8d 47 70             	lea    0x70(%edi),%eax
		if (rsp->DataPres & SSP_RSP_LEN_VALID)
    51ee:	0f 84 7a ff ff ff    	je     516e <mpt_xmit_response+0x21e>
    51f4:	8b 77 6c             	mov    0x6c(%edi),%esi
    51f7:	0f ce                	bswap  %esi
			info += be32_to_cpu(rsp->ResponseDataLength);
    51f9:	01 f0                	add    %esi,%eax
    51fb:	e9 6e ff ff ff       	jmp    516e <mpt_xmit_response+0x21e>
    5200:	e8 0f 00 00 00       	call   5214 <mpt_xmit_response+0x2c4>
		info = rsp->FcpSenseData - sizeof(rsp->FcpResponseData);
		if (rsp->FcpFlags & FCP_RSP_LEN_VALID)
			info += be32_to_cpu(rsp->FcpResponseLength);
	}

	sBUG_ON(info == NULL);
    5205:	c7 44 24 0c e8 01 00 	movl   $0x1e8,0xc(%esp)
    520c:	00 
    520d:	c7 44 24 08 b4 04 00 	movl   $0x4b4,0x8(%esp)
    5214:	00 
    5215:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
    521c:	00 
    521d:	c7 04 24 b3 00 00 00 	movl   $0xb3,(%esp)
    5224:	e8 fc ff ff ff       	call   5225 <mpt_xmit_response+0x2d5>
    5229:	ff 15 0c 00 00 00    	call   *0xc
    522f:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
    5235:	f6 c4 ff             	test   $0xff,%ah
    5238:	74 11                	je     524b <mpt_xmit_response+0x2fb>
    523a:	ba 00 02 00 00       	mov    $0x200,%edx
    523f:	b8 3a 52 00 00       	mov    $0x523a,%eax
    5244:	e8 fc ff ff ff       	call   5245 <mpt_xmit_response+0x2f5>
    5249:	eb e4                	jmp    522f <mpt_xmit_response+0x2df>
    524b:	0f 0b                	ud2    
    524d:	8d 76 00             	lea    0x0(%esi),%esi

00005250 <mpt_stm_adapter_online>:

	return 0;
}

static int mpt_stm_adapter_online(MPT_STM_PRIV *priv)
{
    5250:	55                   	push   %ebp
    5251:	89 e5                	mov    %esp,%ebp
    5253:	57                   	push   %edi
    5254:	56                   	push   %esi
    5255:	53                   	push   %ebx
    5256:	83 ec 38             	sub    $0x38,%esp
    5259:	e8 fc ff ff ff       	call   525a <mpt_stm_adapter_online+0xa>
	priv->port_speed = 0;

	priv->in_reset = 0;
	priv->poll_enabled = 1;

	for (i = 0; i < priv->num_cmd_buffers; i++)
    525e:	8b 48 14             	mov    0x14(%eax),%ecx
	default:
		break;
	}
#endif

	priv->port_enable_pending = 0;
    5261:	c7 40 60 00 00 00 00 	movl   $0x0,0x60(%eax)
	priv->port_speed = 0;

	priv->in_reset = 0;
	priv->poll_enabled = 1;

	for (i = 0; i < priv->num_cmd_buffers; i++)
    5268:	85 c9                	test   %ecx,%ecx
		break;
	}
#endif

	priv->port_enable_pending = 0;
	priv->target_mode_abort_pending = 0;
    526a:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)

	return 0;
}

static int mpt_stm_adapter_online(MPT_STM_PRIV *priv)
{
    5271:	89 45 f0             	mov    %eax,-0x10(%ebp)
	}
#endif

	priv->port_enable_pending = 0;
	priv->target_mode_abort_pending = 0;
	priv->link_serv_abort_pending = 0;
    5274:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
	int			i;

	TRACE_ENTRY();
	ioc = priv->ioc;

	priv->fcp2_capable = 0;
    527b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
#endif

	priv->port_enable_pending = 0;
	priv->target_mode_abort_pending = 0;
	priv->link_serv_abort_pending = 0;
	priv->fc_primitive_send_pending = 0;
    5282:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)

	priv->config_pending = 0;
	priv->config_mf = NULL;
    5289:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
    5290:	00 00 00 
	priv->port_enable_pending = 0;
	priv->target_mode_abort_pending = 0;
	priv->link_serv_abort_pending = 0;
	priv->fc_primitive_send_pending = 0;

	priv->config_pending = 0;
    5293:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	priv->config_mf = NULL;

	priv->port_flags = 0;
    529a:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
	priv->port_speed = 0;
    52a1:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)

	priv->in_reset = 0;
    52a8:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	priv->poll_enabled = 1;
    52af:	c7 40 7c 01 00 00 00 	movl   $0x1,0x7c(%eax)

	for (i = 0; i < priv->num_cmd_buffers; i++)
    52b6:	7e 19                	jle    52d1 <mpt_stm_adapter_online+0x81>
    52b8:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    52bb:	31 c0                	xor    %eax,%eax
    52bd:	8d 76 00             	lea    0x0(%esi),%esi
		priv->io_state[i] = 0;
    52c0:	8d 50 28             	lea    0x28(%eax),%edx
	priv->port_speed = 0;

	priv->in_reset = 0;
	priv->poll_enabled = 1;

	for (i = 0; i < priv->num_cmd_buffers; i++)
    52c3:	83 c0 01             	add    $0x1,%eax
    52c6:	39 c8                	cmp    %ecx,%eax
		priv->io_state[i] = 0;
    52c8:	c7 04 93 00 00 00 00 	movl   $0x0,(%ebx,%edx,4)
	priv->port_speed = 0;

	priv->in_reset = 0;
	priv->poll_enabled = 1;

	for (i = 0; i < priv->num_cmd_buffers; i++)
    52cf:	75 ef                	jne    52c0 <mpt_stm_adapter_online+0x70>
		priv->io_state[i] = 0;

	if (IsScsi(priv))
    52d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    52d4:	8b 18                	mov    (%eax),%ebx
    52d6:	80 bb 69 03 00 00 01 	cmpb   $0x1,0x369(%ebx)
    52dd:	0f 84 e4 02 00 00    	je     55c7 <mpt_stm_adapter_online+0x377>
		stm_scsi_configuration(priv, NO_SLEEP);

	if (IsSas(priv))
		stm_sas_configuration(priv, NO_SLEEP);

	if (priv->enable_target_mode) {
    52e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    52e6:	8b 48 04             	mov    0x4(%eax),%ecx
    52e9:	85 c9                	test   %ecx,%ecx
    52eb:	74 44                	je     5331 <mpt_stm_adapter_online+0xe1>
		if (IsSas(priv)) {
    52ed:	0f b6 83 69 03 00 00 	movzbl 0x369(%ebx),%eax
    52f4:	3c 30                	cmp    $0x30,%al
    52f6:	0f 84 f2 01 00 00    	je     54ee <mpt_stm_adapter_online+0x29e>
			stm_cmd_buf_post_base(priv, 1);
		} else {
			for (i = 0; i < priv->num_cmd_buffers; i++)
    52fc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    52ff:	31 f6                	xor    %esi,%esi
    5301:	8b 51 14             	mov    0x14(%ecx),%edx
    5304:	85 d2                	test   %edx,%edx
    5306:	7e 25                	jle    532d <mpt_stm_adapter_online+0xdd>
    5308:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    530b:	90                   	nop
    530c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				stm_cmd_buf_post(priv, i);
    5310:	89 f2                	mov    %esi,%edx
    5312:	89 d8                	mov    %ebx,%eax
    5314:	e8 17 c1 ff ff       	call   1430 <stm_cmd_buf_post>

	if (priv->enable_target_mode) {
		if (IsSas(priv)) {
			stm_cmd_buf_post_base(priv, 1);
		} else {
			for (i = 0; i < priv->num_cmd_buffers; i++)
    5319:	83 c6 01             	add    $0x1,%esi
    531c:	39 73 14             	cmp    %esi,0x14(%ebx)
    531f:	7f ef                	jg     5310 <mpt_stm_adapter_online+0xc0>
    5321:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5324:	8b 18                	mov    (%eax),%ebx
    5326:	0f b6 83 69 03 00 00 	movzbl 0x369(%ebx),%eax
				stm_cmd_buf_post(priv, i);
		}

		if (IsFc(priv)) {
    532d:	3c 10                	cmp    $0x10,%al
    532f:	74 70                	je     53a1 <mpt_stm_adapter_online+0x151>
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    5331:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    5338:	89 da                	mov    %ebx,%edx
    533a:	e8 fc ff ff ff       	call   533b <mpt_stm_adapter_online+0xeb>

	sBUG_ON(mf == NULL);
    533f:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    5341:	89 c1                	mov    %eax,%ecx

	sBUG_ON(mf == NULL);
    5343:	0f 84 41 0a 00 00    	je     5d8a <mpt_stm_adapter_online+0xb3a>
	req = (PortEnable_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));

	req->Function = MPI_FUNCTION_PORT_ENABLE;

	priv->port_enable_pending = 1;
    5349:	8b 75 f0             	mov    -0x10(%ebp),%esi

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    534c:	89 da                	mov    %ebx,%edx
	PortEnable_t	*req;
	int ret;

	TRACE_ENTRY();
	req = (PortEnable_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
    534e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5354:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    535b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	req->Function = MPI_FUNCTION_PORT_ENABLE;
    5362:	c6 40 03 06          	movb   $0x6,0x3(%eax)

	priv->port_enable_pending = 1;

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    5366:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
	req = (PortEnable_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));

	req->Function = MPI_FUNCTION_PORT_ENABLE;

	priv->port_enable_pending = 1;
    536d:	c7 46 60 01 00 00 00 	movl   $0x1,0x60(%esi)

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    5374:	e8 fc ff ff ff       	call   5375 <mpt_stm_adapter_online+0x125>

	ret = stm_wait_for(priv, &priv->port_enable_pending, 60, NO_SLEEP);
    5379:	89 f0                	mov    %esi,%eax
    537b:	b9 3c 00 00 00       	mov    $0x3c,%ecx
    5380:	8d 56 60             	lea    0x60(%esi),%edx
    5383:	e8 58 b5 ff ff       	call   8e0 <stm_wait_for.constprop.52>
		}
	}

	stm_port_enable(priv);

	if (IsFc(priv))
    5388:	8b 1e                	mov    (%esi),%ebx
    538a:	80 bb 69 03 00 00 10 	cmpb   $0x10,0x369(%ebx)
    5391:	0f 84 f8 05 00 00    	je     598f <mpt_stm_adapter_online+0x73f>
		}
	}
	TRACE_EXIT();

	return 0;
}
    5397:	83 c4 38             	add    $0x38,%esp
    539a:	31 c0                	xor    %eax,%eax
    539c:	5b                   	pop    %ebx
    539d:	5e                   	pop    %esi
    539e:	5f                   	pop    %edi
    539f:	5d                   	pop    %ebp
    53a0:	c3                   	ret    
			for (i = 0; i < priv->num_cmd_buffers; i++)
				stm_cmd_buf_post(priv, i);
		}

		if (IsFc(priv)) {
			for (i = 0; i < priv->num_els_buffers; i++)
    53a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    53a4:	31 db                	xor    %ebx,%ebx
    53a6:	8b 75 f0             	mov    -0x10(%ebp),%esi
    53a9:	8b 50 18             	mov    0x18(%eax),%edx
    53ac:	85 d2                	test   %edx,%edx
    53ae:	7e 11                	jle    53c1 <mpt_stm_adapter_online+0x171>
				stm_link_serv_buf_post(priv, i);
    53b0:	89 da                	mov    %ebx,%edx
    53b2:	89 f0                	mov    %esi,%eax
    53b4:	e8 47 b7 ff ff       	call   b00 <stm_link_serv_buf_post>
			for (i = 0; i < priv->num_cmd_buffers; i++)
				stm_cmd_buf_post(priv, i);
		}

		if (IsFc(priv)) {
			for (i = 0; i < priv->num_els_buffers; i++)
    53b9:	83 c3 01             	add    $0x1,%ebx
    53bc:	39 5e 18             	cmp    %ebx,0x18(%esi)
    53bf:	7f ef                	jg     53b0 <mpt_stm_adapter_online+0x160>
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_fc_enable_els(MPT_STM_PRIV *priv, int els, int sleep)
{
	FCPortPage8_t	*FcPort8;
	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    53c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    53c4:	ba 00 04 00 00       	mov    $0x400,%edx
    53c9:	8b 40 20             	mov    0x20(%eax),%eax
    53cc:	8d b8 00 18 02 00    	lea    0x21800(%eax),%edi
    53d2:	f7 c7 01 00 00 00    	test   $0x1,%edi
    53d8:	0f 85 96 09 00 00    	jne    5d74 <mpt_stm_adapter_online+0xb24>
    53de:	f7 c7 02 00 00 00    	test   $0x2,%edi
    53e4:	0f 85 17 0b 00 00    	jne    5f01 <mpt_stm_adapter_online+0xcb1>
    53ea:	89 d1                	mov    %edx,%ecx
    53ec:	31 c0                	xor    %eax,%eax
    53ee:	c1 e9 02             	shr    $0x2,%ecx
    53f1:	f6 c2 02             	test   $0x2,%dl
    53f4:	f3 ab                	rep stos %eax,%es:(%edi)
    53f6:	74 09                	je     5401 <mpt_stm_adapter_online+0x1b1>
    53f8:	31 c0                	xor    %eax,%eax
    53fa:	83 c7 02             	add    $0x2,%edi
    53fd:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    5401:	83 e2 01             	and    $0x1,%edx
    5404:	74 03                	je     5409 <mpt_stm_adapter_online+0x1b9>
    5406:	c6 07 00             	movb   $0x0,(%edi)
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_FC_PORT, 8, 0, sleep))
    5409:	8b 45 f0             	mov    -0x10(%ebp),%eax
    540c:	b9 08 00 00 00       	mov    $0x8,%ecx
    5411:	ba 05 00 00 00       	mov    $0x5,%edx
    5416:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    541d:	e8 ae c5 ff ff       	call   19d0 <stm_get_config_page.constprop.50>
    5422:	85 c0                	test   %eax,%eax
    5424:	75 25                	jne    544b <mpt_stm_adapter_online+0x1fb>
		return -1;
	FcPort8 = (FCPortPage8_t *)priv->hw->config_buf;
    5426:	8b 75 f0             	mov    -0x10(%ebp),%esi
	/* clear the ELS bit */
	FcPort8->BitVector[els / 32] &= ~cpu_to_le32(1 << (els & 31));
	if (stm_set_config_page(priv, MPI_CONFIG_PAGETYPE_FC_PORT, 8, 0, sleep))
    5429:	b9 08 00 00 00       	mov    $0x8,%ecx
    542e:	ba 05 00 00 00       	mov    $0x5,%edx
	FCPortPage8_t	*FcPort8;
	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_FC_PORT, 8, 0, sleep))
		return -1;
	FcPort8 = (FCPortPage8_t *)priv->hw->config_buf;
    5433:	8b 46 20             	mov    0x20(%esi),%eax
	/* clear the ELS bit */
	FcPort8->BitVector[els / 32] &= ~cpu_to_le32(1 << (els & 31));
    5436:	83 a0 10 18 02 00 fd 	andl   $0xfffffffd,0x21810(%eax)
	if (stm_set_config_page(priv, MPI_CONFIG_PAGETYPE_FC_PORT, 8, 0, sleep))
    543d:	89 f0                	mov    %esi,%eax
    543f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    5446:	e8 e5 cc ff ff       	call   2130 <stm_set_config_page.constprop.47>

#ifdef STMAPP_VERIFY_OXIDS
			stm_fc_enable_target_mode_oxid(priv, NO_SLEEP);
#endif

			stm_fc_enable_aliases(priv, priv->num_aliases, NO_SLEEP);
    544b:	8b 45 f0             	mov    -0x10(%ebp),%eax
static int stm_fc_enable_aliases(MPT_STM_PRIV *priv, int num_aliases, int sleep)
{
	FCPortPage1_t	*FcPort1;

	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    544e:	ba 00 04 00 00       	mov    $0x400,%edx

#ifdef STMAPP_VERIFY_OXIDS
			stm_fc_enable_target_mode_oxid(priv, NO_SLEEP);
#endif

			stm_fc_enable_aliases(priv, priv->num_aliases, NO_SLEEP);
    5453:	8b 58 1c             	mov    0x1c(%eax),%ebx
static int stm_fc_enable_aliases(MPT_STM_PRIV *priv, int num_aliases, int sleep)
{
	FCPortPage1_t	*FcPort1;

	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5456:	8b 40 20             	mov    0x20(%eax),%eax
    5459:	8d b8 00 18 02 00    	lea    0x21800(%eax),%edi
    545f:	f7 c7 01 00 00 00    	test   $0x1,%edi
    5465:	0f 85 80 0a 00 00    	jne    5eeb <mpt_stm_adapter_online+0xc9b>
    546b:	f7 c7 02 00 00 00    	test   $0x2,%edi
    5471:	0f 85 63 0a 00 00    	jne    5eda <mpt_stm_adapter_online+0xc8a>
    5477:	89 d1                	mov    %edx,%ecx
    5479:	31 c0                	xor    %eax,%eax
    547b:	c1 e9 02             	shr    $0x2,%ecx
    547e:	f6 c2 02             	test   $0x2,%dl
    5481:	f3 ab                	rep stos %eax,%es:(%edi)
    5483:	74 09                	je     548e <mpt_stm_adapter_online+0x23e>
    5485:	31 c0                	xor    %eax,%eax
    5487:	83 c7 02             	add    $0x2,%edi
    548a:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    548e:	83 e2 01             	and    $0x1,%edx
    5491:	74 03                	je     5496 <mpt_stm_adapter_online+0x246>
    5493:	c6 07 00             	movb   $0x0,(%edi)
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_FC_PORT, 1, 0, sleep))
    5496:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5499:	b9 01 00 00 00       	mov    $0x1,%ecx
    549e:	ba 05 00 00 00       	mov    $0x5,%edx
    54a3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    54aa:	e8 21 c5 ff ff       	call   19d0 <stm_get_config_page.constprop.50>
    54af:	85 c0                	test   %eax,%eax
    54b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    54b4:	75 31                	jne    54e7 <mpt_stm_adapter_online+0x297>
		return -1;
	FcPort1 = (FCPortPage1_t *)priv->hw->config_buf;
    54b6:	8b 40 20             	mov    0x20(%eax),%eax
		/* make sure the value in the page is low enough */
		if (FcPort1->NumRequestedAliases > NUM_ALIASES)
			FcPort1->NumRequestedAliases = NUM_ALIASES;
	}

	if (num_aliases > 0)
    54b9:	85 db                	test   %ebx,%ebx
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_FC_PORT, 1, 0, sleep))
		return -1;
	FcPort1 = (FCPortPage1_t *)priv->hw->config_buf;
	if (set_aliases_in_fcportpage1) {
		/* set the number of aliases requested */
		FcPort1->NumRequestedAliases = (u8)num_aliases;
    54bb:	88 98 1c 18 02 00    	mov    %bl,0x2181c(%eax)
		/* make sure the value in the page is low enough */
		if (FcPort1->NumRequestedAliases > NUM_ALIASES)
			FcPort1->NumRequestedAliases = NUM_ALIASES;
	}

	if (num_aliases > 0)
    54c1:	7e 07                	jle    54ca <mpt_stm_adapter_online+0x27a>
		FcPort1->TopologyConfig = MPI_FCPORTPAGE1_TOPOLOGY_NLPORT;
    54c3:	c6 80 1a 18 02 00 01 	movb   $0x1,0x2181a(%eax)
	if (stm_set_config_page(priv, MPI_CONFIG_PAGETYPE_FC_PORT, 1, 0, sleep))
    54ca:	8b 75 f0             	mov    -0x10(%ebp),%esi
    54cd:	b9 01 00 00 00       	mov    $0x1,%ecx
    54d2:	ba 05 00 00 00       	mov    $0x5,%edx
    54d7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    54de:	89 f0                	mov    %esi,%eax
    54e0:	e8 4b cc ff ff       	call   2130 <stm_set_config_page.constprop.47>
    54e5:	89 f0                	mov    %esi,%eax
    54e7:	8b 18                	mov    (%eax),%ebx
    54e9:	e9 43 fe ff ff       	jmp    5331 <mpt_stm_adapter_online+0xe1>
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    54ee:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    54f5:	89 da                	mov    %ebx,%edx
    54f7:	e8 fc ff ff ff       	call   54f8 <mpt_stm_adapter_online+0x2a8>

	sBUG_ON(mf == NULL);
    54fc:	85 c0                	test   %eax,%eax
    54fe:	0f 84 86 08 00 00    	je     5d8a <mpt_stm_adapter_online+0xb3a>
	int					i;
	dma_addr_t				dma_addr;

	TRACE_ENTRY();
	req = (TargetCmdBufferPostBaseRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
    5504:	a8 01                	test   $0x1,%al
    5506:	89 c2                	mov    %eax,%edx
    5508:	b9 1c 00 00 00       	mov    $0x1c,%ecx
    550d:	0f 85 ba 09 00 00    	jne    5ecd <mpt_stm_adapter_online+0xc7d>
    5513:	f6 c2 02             	test   $0x2,%dl
    5516:	0f 85 a0 09 00 00    	jne    5ebc <mpt_stm_adapter_online+0xc6c>
    551c:	89 cf                	mov    %ecx,%edi
    551e:	31 f6                	xor    %esi,%esi
    5520:	83 e7 fc             	and    $0xfffffffc,%edi
    5523:	c7 04 32 00 00 00 00 	movl   $0x0,(%edx,%esi,1)
    552a:	83 c6 04             	add    $0x4,%esi
    552d:	39 fe                	cmp    %edi,%esi
    552f:	72 f2                	jb     5523 <mpt_stm_adapter_online+0x2d3>
    5531:	01 f2                	add    %esi,%edx
    5533:	f6 c1 02             	test   $0x2,%cl
    5536:	74 09                	je     5541 <mpt_stm_adapter_online+0x2f1>
    5538:	31 f6                	xor    %esi,%esi
    553a:	83 c2 02             	add    $0x2,%edx
    553d:	66 89 72 fe          	mov    %si,-0x2(%edx)
    5541:	83 e1 01             	and    $0x1,%ecx
    5544:	74 03                	je     5549 <mpt_stm_adapter_online+0x2f9>
    5546:	c6 02 00             	movb   $0x0,(%edx)

	if (post_all)
		req->BufferPostFlags = CMD_BUFFER_POST_BASE_FLAGS_AUTO_POST_ALL;
	req->Function = MPI_FUNCTION_TARGET_CMD_BUF_BASE_POST;
	req->TotalCmdBuffers = cpu_to_le16(priv->num_cmd_buffers);
    5549:	8b 75 f0             	mov    -0x10(%ebp),%esi
	req->CmdBufferLength = cpu_to_le16(sizeof(priv->hw->cmd_buf[0].cmd));
    554c:	b9 40 00 00 00       	mov    $0x40,%ecx
	req->NextCmdBufferOffset = cpu_to_le16(sizeof(priv->hw->cmd_buf[0]));
    5551:	bf f0 03 00 00       	mov    $0x3f0,%edi
	TRACE_ENTRY();
	req = (TargetCmdBufferPostBaseRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));

	if (post_all)
		req->BufferPostFlags = CMD_BUFFER_POST_BASE_FLAGS_AUTO_POST_ALL;
    5556:	c6 00 01             	movb   $0x1,(%eax)
	req->Function = MPI_FUNCTION_TARGET_CMD_BUF_BASE_POST;
    5559:	c6 40 03 24          	movb   $0x24,0x3(%eax)
	req->TotalCmdBuffers = cpu_to_le16(priv->num_cmd_buffers);
    555d:	8b 56 14             	mov    0x14(%esi),%edx
	req->CmdBufferLength = cpu_to_le16(sizeof(priv->hw->cmd_buf[0].cmd));
    5560:	66 89 48 10          	mov    %cx,0x10(%eax)
	req->NextCmdBufferOffset = cpu_to_le16(sizeof(priv->hw->cmd_buf[0]));
    5564:	66 89 78 12          	mov    %di,0x12(%eax)
	memset(req, 0, sizeof(*req));

	if (post_all)
		req->BufferPostFlags = CMD_BUFFER_POST_BASE_FLAGS_AUTO_POST_ALL;
	req->Function = MPI_FUNCTION_TARGET_CMD_BUF_BASE_POST;
	req->TotalCmdBuffers = cpu_to_le16(priv->num_cmd_buffers);
    5568:	66 89 50 04          	mov    %dx,0x4(%eax)
	req->CmdBufferLength = cpu_to_le16(sizeof(priv->hw->cmd_buf[0].cmd));
	req->NextCmdBufferOffset = cpu_to_le16(sizeof(priv->hw->cmd_buf[0]));
	dma_addr = priv->hw_dma +
    556c:	8b 4e 24             	mov    0x24(%esi),%ecx
    556f:	8b 56 28             	mov    0x28(%esi),%edx
		((u8 *)priv->hw->cmd_buf[0].cmd - (u8 *)priv->hw);
	req->BaseAddressLow = cpu_to_le32(dma_addr);
    5572:	89 48 14             	mov    %ecx,0x14(%eax)
#if MPT_STM_64_BIT_DMA
	req->BaseAddressHigh = cpu_to_le32((u64)dma_addr>>32);
    5575:	89 50 18             	mov    %edx,0x18(%eax)
#endif

	if (post_all)
		for (i = 0; i < priv->num_cmd_buffers; i++)
    5578:	8b 4e 14             	mov    0x14(%esi),%ecx
    557b:	85 c9                	test   %ecx,%ecx
    557d:	7e 25                	jle    55a4 <mpt_stm_adapter_online+0x354>
    557f:	8b 7d f0             	mov    -0x10(%ebp),%edi
    5582:	31 d2                	xor    %edx,%edx
    5584:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    5587:	90                   	nop
    5588:	8d 34 97             	lea    (%edi,%edx,4),%esi
    558b:	83 c2 01             	add    $0x1,%edx
			priv->io_state[i] |= IO_STATE_POSTED;
    558e:	8b 9e a0 00 00 00    	mov    0xa0(%esi),%ebx
    5594:	83 cb 01             	or     $0x1,%ebx
#if MPT_STM_64_BIT_DMA
	req->BaseAddressHigh = cpu_to_le32((u64)dma_addr>>32);
#endif

	if (post_all)
		for (i = 0; i < priv->num_cmd_buffers; i++)
    5597:	39 ca                	cmp    %ecx,%edx
			priv->io_state[i] |= IO_STATE_POSTED;
    5599:	89 9e a0 00 00 00    	mov    %ebx,0xa0(%esi)
#if MPT_STM_64_BIT_DMA
	req->BaseAddressHigh = cpu_to_le32((u64)dma_addr>>32);
#endif

	if (post_all)
		for (i = 0; i < priv->num_cmd_buffers; i++)
    559f:	75 e7                	jne    5588 <mpt_stm_adapter_online+0x338>
    55a1:	8b 5d ec             	mov    -0x14(%ebp),%ebx
			      ioc->name, i * 4, le32_to_cpu(p[i]));
		}
	}
#endif

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    55a4:	0f b6 35 14 00 00 00 	movzbl 0x14,%esi
    55ab:	89 c1                	mov    %eax,%ecx
    55ad:	89 da                	mov    %ebx,%edx
    55af:	89 f0                	mov    %esi,%eax
    55b1:	e8 fc ff ff ff       	call   55b2 <mpt_stm_adapter_online+0x362>
    55b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    55b9:	8b 18                	mov    (%eax),%ebx
    55bb:	0f b6 83 69 03 00 00 	movzbl 0x369(%ebx),%eax
    55c2:	e9 66 fd ff ff       	jmp    532d <mpt_stm_adapter_online+0xdd>
	int			sync;
	int			flags;
	int			i;

	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    55c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    55ca:	ba 00 04 00 00       	mov    $0x400,%edx
    55cf:	8b 40 20             	mov    0x20(%eax),%eax
    55d2:	8d b8 00 18 02 00    	lea    0x21800(%eax),%edi
    55d8:	f7 c7 01 00 00 00    	test   $0x1,%edi
    55de:	0f 85 c2 08 00 00    	jne    5ea6 <mpt_stm_adapter_online+0xc56>
    55e4:	f7 c7 02 00 00 00    	test   $0x2,%edi
    55ea:	0f 85 a5 08 00 00    	jne    5e95 <mpt_stm_adapter_online+0xc45>
    55f0:	89 d1                	mov    %edx,%ecx
    55f2:	31 c0                	xor    %eax,%eax
    55f4:	c1 e9 02             	shr    $0x2,%ecx
    55f7:	f6 c2 02             	test   $0x2,%dl
    55fa:	f3 ab                	rep stos %eax,%es:(%edi)
    55fc:	74 09                	je     5607 <mpt_stm_adapter_online+0x3b7>
    55fe:	31 f6                	xor    %esi,%esi
    5600:	83 c7 02             	add    $0x2,%edi
    5603:	66 89 77 fe          	mov    %si,-0x2(%edi)
    5607:	83 e2 01             	and    $0x1,%edx
    560a:	74 03                	je     560f <mpt_stm_adapter_online+0x3bf>
    560c:	c6 07 00             	movb   $0x0,(%edi)
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_PORT, 2, 0, sleep))
    560f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5612:	b9 02 00 00 00       	mov    $0x2,%ecx
    5617:	ba 03 00 00 00       	mov    $0x3,%edx
    561c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    5623:	e8 a8 c3 ff ff       	call   19d0 <stm_get_config_page.constprop.50>
    5628:	85 c0                	test   %eax,%eax
    562a:	0f 85 55 03 00 00    	jne    5985 <mpt_stm_adapter_online+0x735>
		return -1;
	ScsiPort2 = &priv->SCSIPortPage2;
	memcpy(&priv->SCSIPortPage2, priv->hw->config_buf, sizeof(SCSIPortPage2_t));
    5630:	8b 75 f0             	mov    -0x10(%ebp),%esi
    5633:	89 f0                	mov    %esi,%eax
    5635:	8b 56 20             	mov    0x20(%esi),%edx
    5638:	05 c0 0a 00 00       	add    $0xac0,%eax
    563d:	89 c1                	mov    %eax,%ecx
    563f:	89 c7                	mov    %eax,%edi
    5641:	83 e1 01             	and    $0x1,%ecx
    5644:	89 45 dc             	mov    %eax,-0x24(%ebp)
    5647:	8d b2 00 18 02 00    	lea    0x21800(%edx),%esi
    564d:	b8 4c 00 00 00       	mov    $0x4c,%eax
    5652:	0f 85 17 08 00 00    	jne    5e6f <mpt_stm_adapter_online+0xc1f>
    5658:	f7 c7 02 00 00 00    	test   $0x2,%edi
    565e:	0f 85 f6 07 00 00    	jne    5e5a <mpt_stm_adapter_online+0xc0a>
    5664:	89 c1                	mov    %eax,%ecx
    5666:	31 d2                	xor    %edx,%edx
    5668:	c1 e9 02             	shr    $0x2,%ecx
    566b:	a8 02                	test   $0x2,%al
    566d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    566f:	74 0b                	je     567c <mpt_stm_adapter_online+0x42c>
    5671:	0f b7 16             	movzwl (%esi),%edx
    5674:	66 89 17             	mov    %dx,(%edi)
    5677:	ba 02 00 00 00       	mov    $0x2,%edx
    567c:	a8 01                	test   $0x1,%al
    567e:	74 07                	je     5687 <mpt_stm_adapter_online+0x437>
    5680:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
    5684:	88 04 17             	mov    %al,(%edi,%edx,1)

	TRACE_DBG("%s scsi id is %d", ioc->name, priv->port_id);

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5687:	8b 45 f0             	mov    -0x10(%ebp),%eax
    568a:	ba 00 04 00 00       	mov    $0x400,%edx
    568f:	8b 40 20             	mov    0x20(%eax),%eax
    5692:	8d b8 00 18 02 00    	lea    0x21800(%eax),%edi
    5698:	f7 c7 01 00 00 00    	test   $0x1,%edi
    569e:	0f 85 a0 07 00 00    	jne    5e44 <mpt_stm_adapter_online+0xbf4>
    56a4:	f7 c7 02 00 00 00    	test   $0x2,%edi
    56aa:	0f 85 83 07 00 00    	jne    5e33 <mpt_stm_adapter_online+0xbe3>
    56b0:	89 d1                	mov    %edx,%ecx
    56b2:	31 c0                	xor    %eax,%eax
    56b4:	c1 e9 02             	shr    $0x2,%ecx
    56b7:	f6 c2 02             	test   $0x2,%dl
    56ba:	f3 ab                	rep stos %eax,%es:(%edi)
    56bc:	74 09                	je     56c7 <mpt_stm_adapter_online+0x477>
    56be:	31 c0                	xor    %eax,%eax
    56c0:	83 c7 02             	add    $0x2,%edi
    56c3:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    56c7:	83 e2 01             	and    $0x1,%edx
    56ca:	74 03                	je     56cf <mpt_stm_adapter_online+0x47f>
    56cc:	c6 07 00             	movb   $0x0,(%edi)
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_PORT, 0, 0, sleep))
    56cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    56d2:	31 c9                	xor    %ecx,%ecx
    56d4:	ba 03 00 00 00       	mov    $0x3,%edx
    56d9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    56e0:	e8 eb c2 ff ff       	call   19d0 <stm_get_config_page.constprop.50>
    56e5:	85 c0                	test   %eax,%eax
    56e7:	0f 85 98 02 00 00    	jne    5985 <mpt_stm_adapter_online+0x735>
		return -1;
	memcpy(&priv->SCSIPortPage0, priv->hw->config_buf, sizeof(SCSIPortPage0_t));
    56ed:	8b 75 f0             	mov    -0x10(%ebp),%esi
    56f0:	8b 4e 20             	mov    0x20(%esi),%ecx
#ifdef CONFIG_SCST_DEBUG
	MPT_ADAPTER		*ioc = priv->ioc;
#endif
	SCSIPortPage1_t *ScsiPort1;
	int i;
	int id = priv->port_id;
    56f3:	8b 46 3c             	mov    0x3c(%esi),%eax
	TRACE_DBG("%s scsi id is %d", ioc->name, priv->port_id);

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_PORT, 0, 0, sleep))
		return -1;
	memcpy(&priv->SCSIPortPage0, priv->hw->config_buf, sizeof(SCSIPortPage0_t));
    56f6:	8d 91 00 18 02 00    	lea    0x21800(%ecx),%edx
    56fc:	8b 89 00 18 02 00    	mov    0x21800(%ecx),%ecx
#ifdef CONFIG_SCST_DEBUG
	MPT_ADAPTER		*ioc = priv->ioc;
#endif
	SCSIPortPage1_t *ScsiPort1;
	int i;
	int id = priv->port_id;
    5702:	89 45 ec             	mov    %eax,-0x14(%ebp)

	TRACE_ENTRY();

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5705:	8b 46 20             	mov    0x20(%esi),%eax
	TRACE_DBG("%s scsi id is %d", ioc->name, priv->port_id);

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_PORT, 0, 0, sleep))
		return -1;
	memcpy(&priv->SCSIPortPage0, priv->hw->config_buf, sizeof(SCSIPortPage0_t));
    5708:	89 8e a4 0a 00 00    	mov    %ecx,0xaa4(%esi)
    570e:	8b 4a 04             	mov    0x4(%edx),%ecx
	int i;
	int id = priv->port_id;

	TRACE_ENTRY();

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5711:	8d b8 00 18 02 00    	lea    0x21800(%eax),%edi
    5717:	f7 c7 01 00 00 00    	test   $0x1,%edi
	TRACE_DBG("%s scsi id is %d", ioc->name, priv->port_id);

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_PORT, 0, 0, sleep))
		return -1;
	memcpy(&priv->SCSIPortPage0, priv->hw->config_buf, sizeof(SCSIPortPage0_t));
    571d:	89 8e a8 0a 00 00    	mov    %ecx,0xaa8(%esi)
    5723:	8b 52 08             	mov    0x8(%edx),%edx
	ScsiPort0 = &priv->SCSIPortPage0;

	cap = le32_to_cpu(ScsiPort0->Capabilities);
    5726:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	TRACE_DBG("%s scsi id is %d", ioc->name, priv->port_id);

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_PORT, 0, 0, sleep))
		return -1;
	memcpy(&priv->SCSIPortPage0, priv->hw->config_buf, sizeof(SCSIPortPage0_t));
    5729:	89 96 ac 0a 00 00    	mov    %edx,0xaac(%esi)
	int i;
	int id = priv->port_id;

	TRACE_ENTRY();

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    572f:	ba 00 04 00 00       	mov    $0x400,%edx
    5734:	0f 85 e3 06 00 00    	jne    5e1d <mpt_stm_adapter_online+0xbcd>
    573a:	f7 c7 02 00 00 00    	test   $0x2,%edi
    5740:	0f 85 c6 06 00 00    	jne    5e0c <mpt_stm_adapter_online+0xbbc>
    5746:	89 d1                	mov    %edx,%ecx
    5748:	31 c0                	xor    %eax,%eax
    574a:	c1 e9 02             	shr    $0x2,%ecx
    574d:	f6 c2 02             	test   $0x2,%dl
    5750:	f3 ab                	rep stos %eax,%es:(%edi)
    5752:	74 09                	je     575d <mpt_stm_adapter_online+0x50d>
    5754:	31 c0                	xor    %eax,%eax
    5756:	83 c7 02             	add    $0x2,%edi
    5759:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    575d:	83 e2 01             	and    $0x1,%edx
    5760:	74 03                	je     5765 <mpt_stm_adapter_online+0x515>
    5762:	c6 07 00             	movb   $0x0,(%edi)
	memset(&priv->SCSIPortPage1, 0, sizeof(priv->SCSIPortPage1));
	ScsiPort1 = &priv->SCSIPortPage1;
	ScsiPort1->Configuration = cpu_to_le32(id | (1 << (id + 16)));
    5765:	8b 7d ec             	mov    -0x14(%ebp),%edi
    5768:	be 01 00 00 00       	mov    $0x1,%esi
	int id = priv->port_id;

	TRACE_ENTRY();

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	memset(&priv->SCSIPortPage1, 0, sizeof(priv->SCSIPortPage1));
    576d:	8b 45 f0             	mov    -0x10(%ebp),%eax
	ScsiPort1 = &priv->SCSIPortPage1;
	ScsiPort1->Configuration = cpu_to_le32(id | (1 << (id + 16)));
    5770:	8d 4f 10             	lea    0x10(%edi),%ecx
	int id = priv->port_id;

	TRACE_ENTRY();

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	memset(&priv->SCSIPortPage1, 0, sizeof(priv->SCSIPortPage1));
    5773:	8d 90 b0 0a 00 00    	lea    0xab0(%eax),%edx
	ScsiPort1 = &priv->SCSIPortPage1;
	ScsiPort1->Configuration = cpu_to_le32(id | (1 << (id + 16)));
    5779:	d3 e6                	shl    %cl,%esi
    577b:	09 fe                	or     %edi,%esi
	int id = priv->port_id;

	TRACE_ENTRY();

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	memset(&priv->SCSIPortPage1, 0, sizeof(priv->SCSIPortPage1));
    577d:	c7 80 b0 0a 00 00 00 	movl   $0x0,0xab0(%eax)
    5784:	00 00 00 
    5787:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
    578e:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
	ScsiPort1 = &priv->SCSIPortPage1;
	ScsiPort1->Configuration = cpu_to_le32(id | (1 << (id + 16)));
	for (i = 1; i <= priv->num_aliases; i++) {
    5795:	8b 78 1c             	mov    0x1c(%eax),%edi
	TRACE_ENTRY();

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	memset(&priv->SCSIPortPage1, 0, sizeof(priv->SCSIPortPage1));
	ScsiPort1 = &priv->SCSIPortPage1;
	ScsiPort1->Configuration = cpu_to_le32(id | (1 << (id + 16)));
    5798:	89 b0 b4 0a 00 00    	mov    %esi,0xab4(%eax)
	for (i = 1; i <= priv->num_aliases; i++) {
    579e:	85 ff                	test   %edi,%edi
    57a0:	7e 3e                	jle    57e0 <mpt_stm_adapter_online+0x590>
    57a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
		id = (priv->port_id + i) & 15;
		TRACE_DBG("%s alias %d is target %d",
			  ioc->name, i, id);
		ScsiPort1->Configuration |= cpu_to_le32(1 << (id + 16));
    57a5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    57a8:	8b 40 3c             	mov    0x3c(%eax),%eax
    57ab:	89 45 ec             	mov    %eax,-0x14(%ebp)

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	memset(&priv->SCSIPortPage1, 0, sizeof(priv->SCSIPortPage1));
	ScsiPort1 = &priv->SCSIPortPage1;
	ScsiPort1->Configuration = cpu_to_le32(id | (1 << (id + 16)));
	for (i = 1; i <= priv->num_aliases; i++) {
    57ae:	b8 01 00 00 00       	mov    $0x1,%eax
    57b3:	eb 02                	jmp    57b7 <mpt_stm_adapter_online+0x567>
    57b5:	89 ce                	mov    %ecx,%esi
    57b7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
		id = (priv->port_id + i) & 15;
		TRACE_DBG("%s alias %d is target %d",
			  ioc->name, i, id);
		ScsiPort1->Configuration |= cpu_to_le32(1 << (id + 16));
    57ba:	ba 01 00 00 00       	mov    $0x1,%edx
    57bf:	01 c1                	add    %eax,%ecx

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	memset(&priv->SCSIPortPage1, 0, sizeof(priv->SCSIPortPage1));
	ScsiPort1 = &priv->SCSIPortPage1;
	ScsiPort1->Configuration = cpu_to_le32(id | (1 << (id + 16)));
	for (i = 1; i <= priv->num_aliases; i++) {
    57c1:	83 c0 01             	add    $0x1,%eax
		id = (priv->port_id + i) & 15;
    57c4:	83 e1 0f             	and    $0xf,%ecx
		TRACE_DBG("%s alias %d is target %d",
			  ioc->name, i, id);
		ScsiPort1->Configuration |= cpu_to_le32(1 << (id + 16));
    57c7:	83 c1 10             	add    $0x10,%ecx
    57ca:	d3 e2                	shl    %cl,%edx
    57cc:	89 d1                	mov    %edx,%ecx
    57ce:	09 f1                	or     %esi,%ecx

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	memset(&priv->SCSIPortPage1, 0, sizeof(priv->SCSIPortPage1));
	ScsiPort1 = &priv->SCSIPortPage1;
	ScsiPort1->Configuration = cpu_to_le32(id | (1 << (id + 16)));
	for (i = 1; i <= priv->num_aliases; i++) {
    57d0:	39 c7                	cmp    %eax,%edi
    57d2:	7d e1                	jge    57b5 <mpt_stm_adapter_online+0x565>
    57d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    57d7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    57da:	89 88 b4 0a 00 00    	mov    %ecx,0xab4(%eax)
		id = (priv->port_id + i) & 15;
		TRACE_DBG("%s alias %d is target %d",
			  ioc->name, i, id);
		ScsiPort1->Configuration |= cpu_to_le32(1 << (id + 16));
	}
	ScsiPort1->TargetConfig = priv->scsi_port_config;
    57e0:	8b 7d f0             	mov    -0x10(%ebp),%edi
    57e3:	8b 47 40             	mov    0x40(%edi),%eax
	ScsiPort1->IDConfig = priv->scsi_id_config;
	memcpy(priv->hw->config_buf, (u32 *)ScsiPort1, sizeof(*ScsiPort1));
    57e6:	8b 4f 20             	mov    0x20(%edi),%ecx
    57e9:	8b b7 b0 0a 00 00    	mov    0xab0(%edi),%esi
		id = (priv->port_id + i) & 15;
		TRACE_DBG("%s alias %d is target %d",
			  ioc->name, i, id);
		ScsiPort1->Configuration |= cpu_to_le32(1 << (id + 16));
	}
	ScsiPort1->TargetConfig = priv->scsi_port_config;
    57ef:	88 87 bc 0a 00 00    	mov    %al,0xabc(%edi)
	ScsiPort1->IDConfig = priv->scsi_id_config;
    57f5:	8b 47 44             	mov    0x44(%edi),%eax
    57f8:	66 89 87 be 0a 00 00 	mov    %ax,0xabe(%edi)
	memcpy(priv->hw->config_buf, (u32 *)ScsiPort1, sizeof(*ScsiPort1));
    57ff:	8d 81 00 18 02 00    	lea    0x21800(%ecx),%eax
    5805:	89 b1 00 18 02 00    	mov    %esi,0x21800(%ecx)
    580b:	8b 4a 04             	mov    0x4(%edx),%ecx
    580e:	89 48 04             	mov    %ecx,0x4(%eax)
    5811:	8b 4a 08             	mov    0x8(%edx),%ecx
    5814:	89 48 08             	mov    %ecx,0x8(%eax)
    5817:	8b 52 0c             	mov    0xc(%edx),%edx
	stm_set_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_PORT, 1, 0, sleep);
    581a:	b9 01 00 00 00       	mov    $0x1,%ecx
			  ioc->name, i, id);
		ScsiPort1->Configuration |= cpu_to_le32(1 << (id + 16));
	}
	ScsiPort1->TargetConfig = priv->scsi_port_config;
	ScsiPort1->IDConfig = priv->scsi_id_config;
	memcpy(priv->hw->config_buf, (u32 *)ScsiPort1, sizeof(*ScsiPort1));
    581f:	89 50 0c             	mov    %edx,0xc(%eax)
	stm_set_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_PORT, 1, 0, sleep);
    5822:	ba 03 00 00 00       	mov    $0x3,%edx
    5827:	89 f8                	mov    %edi,%eax
    5829:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    5830:	e8 fb c8 ff ff       	call   2130 <stm_set_config_page.constprop.47>
	TRACE_DBG("%s target %d capabilities = %08x",
		  ioc->name, priv->port_id, cap);

	stm_set_scsi_port_page1(priv, sleep);

	wcap = cap & ~MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK;
    5835:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	ncap = wcap & ~MPI_SCSIPORTPAGE0_CAP_WIDE;

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5838:	ba 00 04 00 00       	mov    $0x400,%edx
	TRACE_DBG("%s target %d capabilities = %08x",
		  ioc->name, priv->port_id, cap);

	stm_set_scsi_port_page1(priv, sleep);

	wcap = cap & ~MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK;
    583d:	89 c8                	mov    %ecx,%eax
    583f:	30 ec                	xor    %ch,%ah
    5841:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	ncap = wcap & ~MPI_SCSIPORTPAGE0_CAP_WIDE;
    5844:	89 c8                	mov    %ecx,%eax
    5846:	25 ff 00 ff df       	and    $0xdfff00ff,%eax
    584b:	89 45 e0             	mov    %eax,-0x20(%ebp)

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    584e:	8b 47 20             	mov    0x20(%edi),%eax
    5851:	8d b8 00 18 02 00    	lea    0x21800(%eax),%edi
    5857:	f7 c7 01 00 00 00    	test   $0x1,%edi
    585d:	0f 85 93 05 00 00    	jne    5df6 <mpt_stm_adapter_online+0xba6>
    5863:	f7 c7 02 00 00 00    	test   $0x2,%edi
    5869:	0f 85 76 05 00 00    	jne    5de5 <mpt_stm_adapter_online+0xb95>
    586f:	89 d1                	mov    %edx,%ecx
    5871:	31 c0                	xor    %eax,%eax
    5873:	c1 e9 02             	shr    $0x2,%ecx
    5876:	f6 c2 02             	test   $0x2,%dl
    5879:	f3 ab                	rep stos %eax,%es:(%edi)
    587b:	74 09                	je     5886 <mpt_stm_adapter_online+0x636>
    587d:	31 c0                	xor    %eax,%eax
    587f:	83 c7 02             	add    $0x2,%edi
    5882:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    5886:	83 e2 01             	and    $0x1,%edx
    5889:	74 03                	je     588e <mpt_stm_adapter_online+0x63e>
    588b:	c6 07 00             	movb   $0x0,(%edi)
	memset(priv->SCSIDevicePage1, 0, sizeof(SCSIDevicePage1_t) * NUM_SCSI_DEVICES);
    588e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5891:	ba 00 01 00 00       	mov    $0x100,%edx
    5896:	05 0c 0b 00 00       	add    $0xb0c,%eax
    589b:	a8 01                	test   $0x1,%al
    589d:	89 c7                	mov    %eax,%edi
    589f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    58a2:	0f 85 24 05 00 00    	jne    5dcc <mpt_stm_adapter_online+0xb7c>
    58a8:	f7 c7 02 00 00 00    	test   $0x2,%edi
    58ae:	0f 85 07 05 00 00    	jne    5dbb <mpt_stm_adapter_online+0xb6b>
    58b4:	89 d1                	mov    %edx,%ecx
    58b6:	31 c0                	xor    %eax,%eax
    58b8:	c1 e9 02             	shr    $0x2,%ecx
    58bb:	f6 c2 02             	test   $0x2,%dl
    58be:	f3 ab                	rep stos %eax,%es:(%edi)
    58c0:	74 09                	je     58cb <mpt_stm_adapter_online+0x67b>
    58c2:	31 f6                	xor    %esi,%esi
    58c4:	83 c7 02             	add    $0x2,%edi
    58c7:	66 89 77 fe          	mov    %si,-0x2(%edi)
    58cb:	83 e2 01             	and    $0x1,%edx
    58ce:	74 03                	je     58d3 <mpt_stm_adapter_online+0x683>
    58d0:	c6 07 00             	movb   $0x0,(%edi)
    58d3:	8b 45 f0             	mov    -0x10(%ebp),%eax

	for (i = 0; i < NUM_SCSI_DEVICES; i++) {
    58d6:	31 ff                	xor    %edi,%edi

	wcap = cap & ~MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK;
	ncap = wcap & ~MPI_SCSIPORTPAGE0_CAP_WIDE;

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	memset(priv->SCSIDevicePage1, 0, sizeof(SCSIDevicePage1_t) * NUM_SCSI_DEVICES);
    58d8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    58db:	89 5d d8             	mov    %ebx,-0x28(%ebp)
    58de:	8d b0 1c 0b 00 00    	lea    0xb1c(%eax),%esi
    58e4:	89 75 ec             	mov    %esi,-0x14(%ebp)
    58e7:	8d b0 cd 0a 00 00    	lea    0xacd(%eax),%esi
    58ed:	89 45 e8             	mov    %eax,-0x18(%ebp)
    58f0:	eb 0d                	jmp    58ff <mpt_stm_adapter_online+0x6af>
    58f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    58f8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    58fb:	83 45 ec 10          	addl   $0x10,-0x14(%ebp)

	for (i = 0; i < NUM_SCSI_DEVICES; i++) {
		int wide = 0;
		SCSIDevicePage1_t *ScsiDevice1 = &priv->SCSIDevicePage1[i];
		sync = ScsiPort2->DeviceSettings[i].SyncFactor;
		if (ioc->facts.FWVersion.Word >= 0x01032900) {
    58ff:	8b 45 d8             	mov    -0x28(%ebp),%eax
	memset(priv->SCSIDevicePage1, 0, sizeof(SCSIDevicePage1_t) * NUM_SCSI_DEVICES);

	for (i = 0; i < NUM_SCSI_DEVICES; i++) {
		int wide = 0;
		SCSIDevicePage1_t *ScsiDevice1 = &priv->SCSIDevicePage1[i];
		sync = ScsiPort2->DeviceSettings[i].SyncFactor;
    5902:	0f b6 0e             	movzbl (%esi),%ecx
		if (ioc->facts.FWVersion.Word >= 0x01032900) {
    5905:	8b 80 3c 03 00 00    	mov    0x33c(%eax),%eax
    590b:	3d ff 28 03 01       	cmp    $0x10328ff,%eax
    5910:	0f 87 79 04 00 00    	ja     5d8f <mpt_stm_adapter_online+0xb3f>
			printk(KERN_ERR "forcing FAST-5 negotiation due to broken fw 0x%08X\n",
			       ioc->facts.FWVersion.Word);
		}
		flags = le16_to_cpu(ScsiPort2->DeviceSettings[i].DeviceFlags);
		if (flags & MPI_SCSIPORTPAGE2_DEVICE_WIDE_DISABLE) {
			cap = ncap;
    5916:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5919:	f6 46 01 10          	testb  $0x10,0x1(%esi)
    591d:	0f 44 45 e4          	cmove  -0x1c(%ebp),%eax
			wide = 1;
		}
		/*cap &= ~MPI_SCSIDEVPAGE1_RP_IU;
		  cap &= ~MPI_SCSIDEVPAGE1_RP_DT;
		  cap &= ~MPI_SCSIDEVPAGE1_RP_QAS;*/
		ScsiDevice1->RequestedParameters = cpu_to_le32(cap | (sync << 8));
    5921:	c1 e1 08             	shl    $0x8,%ecx
		TRACE_DBG("%s initiator %d parameters = %08x, %s %s",
			  ioc->name, i, le32_to_cpu(ScsiDevice1->RequestedParameters),
			  sync ? "SYNC" : " ",
			  wide ? "WIDE" : " ");
		memcpy(priv->hw->config_buf, ScsiDevice1, sizeof(*ScsiDevice1));
    5924:	8b 1a                	mov    (%edx),%ebx
			wide = 1;
		}
		/*cap &= ~MPI_SCSIDEVPAGE1_RP_IU;
		  cap &= ~MPI_SCSIDEVPAGE1_RP_DT;
		  cap &= ~MPI_SCSIDEVPAGE1_RP_QAS;*/
		ScsiDevice1->RequestedParameters = cpu_to_le32(cap | (sync << 8));
    5926:	09 c8                	or     %ecx,%eax
		TRACE_DBG("%s initiator %d parameters = %08x, %s %s",
			  ioc->name, i, le32_to_cpu(ScsiDevice1->RequestedParameters),
			  sync ? "SYNC" : " ",
			  wide ? "WIDE" : " ");
		memcpy(priv->hw->config_buf, ScsiDevice1, sizeof(*ScsiDevice1));
    5928:	8b 4d e8             	mov    -0x18(%ebp),%ecx
			wide = 1;
		}
		/*cap &= ~MPI_SCSIDEVPAGE1_RP_IU;
		  cap &= ~MPI_SCSIDEVPAGE1_RP_DT;
		  cap &= ~MPI_SCSIDEVPAGE1_RP_QAS;*/
		ScsiDevice1->RequestedParameters = cpu_to_le32(cap | (sync << 8));
    592b:	89 42 04             	mov    %eax,0x4(%edx)
		TRACE_DBG("%s initiator %d parameters = %08x, %s %s",
			  ioc->name, i, le32_to_cpu(ScsiDevice1->RequestedParameters),
			  sync ? "SYNC" : " ",
			  wide ? "WIDE" : " ");
		memcpy(priv->hw->config_buf, ScsiDevice1, sizeof(*ScsiDevice1));
    592e:	8b 49 20             	mov    0x20(%ecx),%ecx
    5931:	89 99 00 18 02 00    	mov    %ebx,0x21800(%ecx)
    5937:	8d 81 00 18 02 00    	lea    0x21800(%ecx),%eax
    593d:	8b 4a 04             	mov    0x4(%edx),%ecx
		stm_set_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_DEVICE, 1, i, sleep);
    5940:	8b 5d e8             	mov    -0x18(%ebp),%ebx
		ScsiDevice1->RequestedParameters = cpu_to_le32(cap | (sync << 8));
		TRACE_DBG("%s initiator %d parameters = %08x, %s %s",
			  ioc->name, i, le32_to_cpu(ScsiDevice1->RequestedParameters),
			  sync ? "SYNC" : " ",
			  wide ? "WIDE" : " ");
		memcpy(priv->hw->config_buf, ScsiDevice1, sizeof(*ScsiDevice1));
    5943:	89 48 04             	mov    %ecx,0x4(%eax)
    5946:	8b 4a 08             	mov    0x8(%edx),%ecx
    5949:	89 48 08             	mov    %ecx,0x8(%eax)
    594c:	8b 52 0c             	mov    0xc(%edx),%edx
		stm_set_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_DEVICE, 1, i, sleep);
    594f:	b9 01 00 00 00       	mov    $0x1,%ecx
		ScsiDevice1->RequestedParameters = cpu_to_le32(cap | (sync << 8));
		TRACE_DBG("%s initiator %d parameters = %08x, %s %s",
			  ioc->name, i, le32_to_cpu(ScsiDevice1->RequestedParameters),
			  sync ? "SYNC" : " ",
			  wide ? "WIDE" : " ");
		memcpy(priv->hw->config_buf, ScsiDevice1, sizeof(*ScsiDevice1));
    5954:	89 50 0c             	mov    %edx,0xc(%eax)
		stm_set_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_DEVICE, 1, i, sleep);
    5957:	ba 04 00 00 00       	mov    $0x4,%edx
    595c:	89 d8                	mov    %ebx,%eax
    595e:	89 3c 24             	mov    %edi,(%esp)
	ncap = wcap & ~MPI_SCSIPORTPAGE0_CAP_WIDE;

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	memset(priv->SCSIDevicePage1, 0, sizeof(SCSIDevicePage1_t) * NUM_SCSI_DEVICES);

	for (i = 0; i < NUM_SCSI_DEVICES; i++) {
    5961:	83 c7 01             	add    $0x1,%edi
		TRACE_DBG("%s initiator %d parameters = %08x, %s %s",
			  ioc->name, i, le32_to_cpu(ScsiDevice1->RequestedParameters),
			  sync ? "SYNC" : " ",
			  wide ? "WIDE" : " ");
		memcpy(priv->hw->config_buf, ScsiDevice1, sizeof(*ScsiDevice1));
		stm_set_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_DEVICE, 1, i, sleep);
    5964:	e8 c7 c7 ff ff       	call   2130 <stm_set_config_page.constprop.47>
    5969:	89 f0                	mov    %esi,%eax
    596b:	83 c6 04             	add    $0x4,%esi
    596e:	2b 45 dc             	sub    -0x24(%ebp),%eax
	ncap = wcap & ~MPI_SCSIPORTPAGE0_CAP_WIDE;

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	memset(priv->SCSIDevicePage1, 0, sizeof(SCSIDevicePage1_t) * NUM_SCSI_DEVICES);

	for (i = 0; i < NUM_SCSI_DEVICES; i++) {
    5971:	83 ff 10             	cmp    $0x10,%edi
    5974:	c7 84 03 03 0e 00 00 	movl   $0x0,0xe03(%ebx,%eax,1)
    597b:	00 00 00 00 
    597f:	0f 85 73 ff ff ff    	jne    58f8 <mpt_stm_adapter_online+0x6a8>
    5985:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5988:	8b 18                	mov    (%eax),%ebx
    598a:	e9 54 f9 ff ff       	jmp    52e3 <mpt_stm_adapter_online+0x93>
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    598f:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
    5996:	89 da                	mov    %ebx,%edx
    5998:	e8 fc ff ff ff       	call   5999 <mpt_stm_adapter_online+0x749>

	sBUG_ON(mf == NULL);
    599d:	85 c0                	test   %eax,%eax
		TRACE_DBG("%s: current_mf %p, index %d",
				ioc->name, priv->current_mf[index], index);
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);
    599f:	89 c1                	mov    %eax,%ecx

	sBUG_ON(mf == NULL);
    59a1:	0f 84 e3 03 00 00    	je     5d8a <mpt_stm_adapter_online+0xb3a>
	memset(req, 0, sizeof(*req));

	req->SendFlags = MPI_FC_PRIM_SEND_FLAGS_RESET_LINK;
	req->Function = MPI_FUNCTION_FC_PRIMITIVE_SEND;

	priv->fc_primitive_send_pending = 1;
    59a7:	8b 75 f0             	mov    -0x10(%ebp),%esi

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    59aa:	89 da                	mov    %ebx,%edx
	FcPrimitiveSendRequest_t	*req;
	int ret;

	TRACE_ENTRY();
	req = (FcPrimitiveSendRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
    59ac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    59b2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    59b9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    59c0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	req->SendFlags = MPI_FC_PRIM_SEND_FLAGS_RESET_LINK;
    59c7:	c6 00 04             	movb   $0x4,(%eax)
	req->Function = MPI_FUNCTION_FC_PRIMITIVE_SEND;
    59ca:	c6 40 03 14          	movb   $0x14,0x3(%eax)

	priv->fc_primitive_send_pending = 1;

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    59ce:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
	memset(req, 0, sizeof(*req));

	req->SendFlags = MPI_FC_PRIM_SEND_FLAGS_RESET_LINK;
	req->Function = MPI_FUNCTION_FC_PRIMITIVE_SEND;

	priv->fc_primitive_send_pending = 1;
    59d5:	c7 46 6c 01 00 00 00 	movl   $0x1,0x6c(%esi)

	mpt_put_msg_frame(stm_context, _IOC_ID, (MPT_FRAME_HDR *)req);
    59dc:	e8 fc ff ff ff       	call   59dd <mpt_stm_adapter_online+0x78d>

	ret = stm_wait_for(priv, &priv->fc_primitive_send_pending, 60, NO_SLEEP);
    59e1:	89 f0                	mov    %esi,%eax
    59e3:	b9 3c 00 00 00       	mov    $0x3c,%ecx
    59e8:	8d 56 6c             	lea    0x6c(%esi),%edx
    59eb:	e8 f0 ae ff ff       	call   8e0 <stm_wait_for.constprop.52>
	stm_port_enable(priv);

	if (IsFc(priv))
		stm_reset_link(priv);

	if (IsFc(priv)) {
    59f0:	8b 06                	mov    (%esi),%eax
    59f2:	80 b8 69 03 00 00 10 	cmpb   $0x10,0x369(%eax)
    59f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    59fc:	0f 85 95 f9 ff ff    	jne    5397 <mpt_stm_adapter_online+0x147>
    5a02:	c7 45 dc 32 00 00 00 	movl   $0x32,-0x24(%ebp)
	FCPortPage0_t	*FcPort0;
	FCDevicePage0_t	*FcDevice0;
	int			page;

	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5a09:	31 f6                	xor    %esi,%esi
    5a0b:	90                   	nop
    5a0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    5a10:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5a13:	ba 00 04 00 00       	mov    $0x400,%edx
    5a18:	8b 40 20             	mov    0x20(%eax),%eax
    5a1b:	8d b8 00 18 02 00    	lea    0x21800(%eax),%edi
    5a21:	f7 c7 01 00 00 00    	test   $0x1,%edi
    5a27:	0f 85 31 03 00 00    	jne    5d5e <mpt_stm_adapter_online+0xb0e>
    5a2d:	f7 c7 02 00 00 00    	test   $0x2,%edi
    5a33:	0f 85 14 03 00 00    	jne    5d4d <mpt_stm_adapter_online+0xafd>
    5a39:	89 d1                	mov    %edx,%ecx
    5a3b:	89 f0                	mov    %esi,%eax
    5a3d:	c1 e9 02             	shr    $0x2,%ecx
    5a40:	f6 c2 02             	test   $0x2,%dl
    5a43:	f3 ab                	rep stos %eax,%es:(%edi)
    5a45:	74 09                	je     5a50 <mpt_stm_adapter_online+0x800>
    5a47:	31 c0                	xor    %eax,%eax
    5a49:	83 c7 02             	add    $0x2,%edi
    5a4c:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    5a50:	83 e2 01             	and    $0x1,%edx
    5a53:	74 03                	je     5a58 <mpt_stm_adapter_online+0x808>
    5a55:	c6 07 00             	movb   $0x0,(%edi)
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_FC_PORT, 0, 0, sleep))
    5a58:	8b 7d f0             	mov    -0x10(%ebp),%edi
    5a5b:	31 c9                	xor    %ecx,%ecx
    5a5d:	ba 05 00 00 00       	mov    $0x5,%edx
    5a62:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    5a69:	89 f8                	mov    %edi,%eax
    5a6b:	e8 60 bf ff ff       	call   19d0 <stm_get_config_page.constprop.50>
    5a70:	85 c0                	test   %eax,%eax
    5a72:	0f 85 d8 01 00 00    	jne    5c50 <mpt_stm_adapter_online+0xa00>
		return -1;
	FcPort0 = (FCPortPage0_t *)priv->hw->config_buf;
    5a78:	8b 5f 20             	mov    0x20(%edi),%ebx
	flags = le32_to_cpu(FcPort0->Flags) &
    5a7b:	8b 83 04 18 02 00    	mov    0x21804(%ebx),%eax
		MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK;
	current_speed = le32_to_cpu(FcPort0->CurrentSpeed);
	port_state = FcPort0->PortState;
    5a81:	0f b6 8b 0a 18 02 00 	movzbl 0x2180a(%ebx),%ecx
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_FC_PORT, 0, 0, sleep))
		return -1;
	FcPort0 = (FCPortPage0_t *)priv->hw->config_buf;
	flags = le32_to_cpu(FcPort0->Flags) &
		MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK;
	current_speed = le32_to_cpu(FcPort0->CurrentSpeed);
    5a88:	8b bb 28 18 02 00    	mov    0x21828(%ebx),%edi
	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_FC_PORT, 0, 0, sleep))
		return -1;
	FcPort0 = (FCPortPage0_t *)priv->hw->config_buf;
	flags = le32_to_cpu(FcPort0->Flags) &
    5a8e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5a91:	25 00 0f 00 00       	and    $0xf00,%eax
		MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK;
	current_speed = le32_to_cpu(FcPort0->CurrentSpeed);
	port_state = FcPort0->PortState;

	switch (flags) {
    5a96:	3d 00 02 00 00       	cmp    $0x200,%eax
		return -1;
	FcPort0 = (FCPortPage0_t *)priv->hw->config_buf;
	flags = le32_to_cpu(FcPort0->Flags) &
		MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK;
	current_speed = le32_to_cpu(FcPort0->CurrentSpeed);
	port_state = FcPort0->PortState;
    5a9b:	89 4d e0             	mov    %ecx,-0x20(%ebp)

	switch (flags) {
    5a9e:	0f 84 9d 02 00 00    	je     5d41 <mpt_stm_adapter_online+0xaf1>
    5aa4:	0f 8f e4 01 00 00    	jg     5c8e <mpt_stm_adapter_online+0xa3e>
    5aaa:	85 c0                	test   %eax,%eax
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_NO_INIT:
		attach = NULL;
    5aac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	flags = le32_to_cpu(FcPort0->Flags) &
		MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK;
	current_speed = le32_to_cpu(FcPort0->CurrentSpeed);
	port_state = FcPort0->PortState;

	switch (flags) {
    5ab3:	74 13                	je     5ac8 <mpt_stm_adapter_online+0x878>
    5ab5:	3d 00 01 00 00       	cmp    $0x100,%eax
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_NO_INIT:
		attach = NULL;
		break;
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_POINT_TO_POINT:
		attach = "point to point";
    5aba:	c7 45 ec f5 01 00 00 	movl   $0x1f5,-0x14(%ebp)
	flags = le32_to_cpu(FcPort0->Flags) &
		MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK;
	current_speed = le32_to_cpu(FcPort0->CurrentSpeed);
	port_state = FcPort0->PortState;

	switch (flags) {
    5ac1:	0f 85 eb 01 00 00    	jne    5cb2 <mpt_stm_adapter_online+0xa62>
    5ac7:	90                   	nop
    5ac8:	8d 57 ff             	lea    -0x1(%edi),%edx
		break;
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_PUBLIC_LOOP:
		attach = "public loop";
		break;
	default:
		attach = "unknown";
    5acb:	b9 2a 00 00 00       	mov    $0x2a,%ecx
    5ad0:	83 fa 03             	cmp    $0x3,%edx
    5ad3:	77 07                	ja     5adc <mpt_stm_adapter_online+0x88c>
    5ad5:	8b 0c 95 8c 02 00 00 	mov    0x28c(,%edx,4),%ecx
	default:
		speed = "unknown";
		break;
	}

	if (priv->port_flags != flags ||
    5adc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5adf:	8b 52 4c             	mov    0x4c(%edx),%edx
    5ae2:	39 d0                	cmp    %edx,%eax
    5ae4:	0f 84 ee 01 00 00    	je     5cd8 <mpt_stm_adapter_online+0xa88>
	    priv->port_speed != current_speed ||
	    priv->port_state != port_state) {
		priv->port_flags = flags;
    5aea:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5aed:	89 42 4c             	mov    %eax,0x4c(%edx)
		priv->port_speed = current_speed;
		priv->port_state = port_state;
    5af0:	8b 45 e0             	mov    -0x20(%ebp),%eax

	if (priv->port_flags != flags ||
	    priv->port_speed != current_speed ||
	    priv->port_state != port_state) {
		priv->port_flags = flags;
		priv->port_speed = current_speed;
    5af3:	89 7a 50             	mov    %edi,0x50(%edx)
		priv->port_state = port_state;
    5af6:	89 42 54             	mov    %eax,0x54(%edx)
		priv->device_changed = 1;
		if (attach)
    5af9:	8b 45 ec             	mov    -0x14(%ebp),%eax
	    priv->port_speed != current_speed ||
	    priv->port_state != port_state) {
		priv->port_flags = flags;
		priv->port_speed = current_speed;
		priv->port_state = port_state;
		priv->device_changed = 1;
    5afc:	c7 42 58 01 00 00 00 	movl   $0x1,0x58(%edx)
		if (attach)
    5b03:	85 c0                	test   %eax,%eax
    5b05:	0f 84 12 02 00 00    	je     5d1d <mpt_stm_adapter_online+0xacd>
			printk(KERN_INFO "%s link is online, type is %s, speed is %s\n",
    5b0b:	89 44 24 08          	mov    %eax,0x8(%esp)
			       ioc->name, attach, speed);
    5b0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		priv->port_flags = flags;
		priv->port_speed = current_speed;
		priv->port_state = port_state;
		priv->device_changed = 1;
		if (attach)
			printk(KERN_INFO "%s link is online, type is %s, speed is %s\n",
    5b12:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    5b16:	c7 04 24 fc 0d 00 00 	movl   $0xdfc,(%esp)
			       ioc->name, attach, speed);
    5b1d:	83 c0 08             	add    $0x8,%eax
    5b20:	89 44 24 04          	mov    %eax,0x4(%esp)
		priv->port_flags = flags;
		priv->port_speed = current_speed;
		priv->port_state = port_state;
		priv->device_changed = 1;
		if (attach)
			printk(KERN_INFO "%s link is online, type is %s, speed is %s\n",
    5b24:	e8 fc ff ff ff       	call   5b25 <mpt_stm_adapter_online+0x8d5>
    5b29:	8b 83 04 18 02 00    	mov    0x21804(%ebx),%eax
    5b2f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	wwnn.Low = le32_to_cpu(FcPort0->WWNN.Low);
	wwnn.High = le32_to_cpu(FcPort0->WWNN.High);
	wwpn.Low = le32_to_cpu(FcPort0->WWPN.Low);
	wwpn.High = le32_to_cpu(FcPort0->WWPN.High);
	port_id = le32_to_cpu(FcPort0->PortIdentifier);
	protocol = le32_to_cpu(FcPort0->Flags) & MPI_FCPORTPAGE0_FLAGS_PROT_MASK;
    5b32:	8b 7d e8             	mov    -0x18(%ebp),%edi
		else
			printk(KERN_INFO "%s link is offline\n", ioc->name);
	}

	wwnn.Low = le32_to_cpu(FcPort0->WWNN.Low);
	wwnn.High = le32_to_cpu(FcPort0->WWNN.High);
    5b35:	8b 83 14 18 02 00    	mov    0x21814(%ebx),%eax
			       ioc->name, attach, speed);
		else
			printk(KERN_INFO "%s link is offline\n", ioc->name);
	}

	wwnn.Low = le32_to_cpu(FcPort0->WWNN.Low);
    5b3b:	8b 8b 10 18 02 00    	mov    0x21810(%ebx),%ecx
	wwnn.High = le32_to_cpu(FcPort0->WWNN.High);
	wwpn.Low = le32_to_cpu(FcPort0->WWPN.Low);
	wwpn.High = le32_to_cpu(FcPort0->WWPN.High);
    5b41:	8b 93 1c 18 02 00    	mov    0x2181c(%ebx),%edx
	port_id = le32_to_cpu(FcPort0->PortIdentifier);
	protocol = le32_to_cpu(FcPort0->Flags) & MPI_FCPORTPAGE0_FLAGS_PROT_MASK;
    5b47:	83 e7 0f             	and    $0xf,%edi
    5b4a:	89 7d e8             	mov    %edi,-0x18(%ebp)

	if (priv->wwpn.Low != wwpn.Low ||
    5b4d:	8b 7d f0             	mov    -0x10(%ebp),%edi
		else
			printk(KERN_INFO "%s link is offline\n", ioc->name);
	}

	wwnn.Low = le32_to_cpu(FcPort0->WWNN.Low);
	wwnn.High = le32_to_cpu(FcPort0->WWNN.High);
    5b50:	89 45 e0             	mov    %eax,-0x20(%ebp)
	wwpn.Low = le32_to_cpu(FcPort0->WWPN.Low);
    5b53:	8b 83 18 18 02 00    	mov    0x21818(%ebx),%eax
	wwpn.High = le32_to_cpu(FcPort0->WWPN.High);
	port_id = le32_to_cpu(FcPort0->PortIdentifier);
    5b59:	8b 9b 0c 18 02 00    	mov    0x2180c(%ebx),%ebx
	protocol = le32_to_cpu(FcPort0->Flags) & MPI_FCPORTPAGE0_FLAGS_PROT_MASK;

	if (priv->wwpn.Low != wwpn.Low ||
    5b5f:	3b 47 34             	cmp    0x34(%edi),%eax
    5b62:	0f 84 56 01 00 00    	je     5cbe <mpt_stm_adapter_online+0xa6e>
	    priv->wwpn.High != wwpn.High ||
	    priv->port_id != port_id) {
		priv->wwnn.Low = wwnn.Low;
    5b68:	8b 7d f0             	mov    -0x10(%ebp),%edi
    5b6b:	89 4f 2c             	mov    %ecx,0x2c(%edi)
		priv->wwnn.High = wwnn.High;
    5b6e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
		priv->wwpn.Low = wwpn.Low;
    5b71:	89 47 34             	mov    %eax,0x34(%edi)
		priv->wwpn.High = wwpn.High;
    5b74:	89 57 38             	mov    %edx,0x38(%edi)
		priv->port_id = port_id;
    5b77:	89 5f 3c             	mov    %ebx,0x3c(%edi)

	if (priv->wwpn.Low != wwpn.Low ||
	    priv->wwpn.High != wwpn.High ||
	    priv->port_id != port_id) {
		priv->wwnn.Low = wwnn.Low;
		priv->wwnn.High = wwnn.High;
    5b7a:	89 4f 30             	mov    %ecx,0x30(%edi)
		priv->wwpn.Low = wwpn.Low;
		priv->wwpn.High = wwpn.High;
		priv->port_id = port_id;
		priv->protocol = protocol;
    5b7d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
		priv->device_changed = 1;
    5b80:	c7 47 58 01 00 00 00 	movl   $0x1,0x58(%edi)
		priv->wwnn.Low = wwnn.Low;
		priv->wwnn.High = wwnn.High;
		priv->wwpn.Low = wwpn.Low;
		priv->wwpn.High = wwpn.High;
		priv->port_id = port_id;
		priv->protocol = protocol;
    5b87:	89 4f 48             	mov    %ecx,0x48(%edi)
		priv->device_changed = 1;
		if (attach)
    5b8a:	8b 7d ec             	mov    -0x14(%ebp),%edi
    5b8d:	85 ff                	test   %edi,%edi
    5b8f:	0f 84 65 01 00 00    	je     5cfa <mpt_stm_adapter_online+0xaaa>
			printk(KERN_INFO "%s port is wwn %08x%08x, port id %x\n",
    5b95:	89 44 24 0c          	mov    %eax,0xc(%esp)
			       ioc->name, wwpn.High, wwpn.Low, port_id);
    5b99:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		priv->wwpn.High = wwpn.High;
		priv->port_id = port_id;
		priv->protocol = protocol;
		priv->device_changed = 1;
		if (attach)
			printk(KERN_INFO "%s port is wwn %08x%08x, port id %x\n",
    5b9c:	89 5c 24 10          	mov    %ebx,0x10(%esp)
    5ba0:	89 54 24 08          	mov    %edx,0x8(%esp)
    5ba4:	c7 04 24 2c 0e 00 00 	movl   $0xe2c,(%esp)
			       ioc->name, wwpn.High, wwpn.Low, port_id);
    5bab:	83 c0 08             	add    $0x8,%eax
    5bae:	89 44 24 04          	mov    %eax,0x4(%esp)
		priv->wwpn.High = wwpn.High;
		priv->port_id = port_id;
		priv->protocol = protocol;
		priv->device_changed = 1;
		if (attach)
			printk(KERN_INFO "%s port is wwn %08x%08x, port id %x\n",
    5bb2:	e8 fc ff ff ff       	call   5bb3 <mpt_stm_adapter_online+0x963>
    5bb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
		break;
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_PUBLIC_LOOP:
		attach = "public loop";
		break;
	default:
		attach = "unknown";
    5bba:	bb ff ff ff 00       	mov    $0xffffff,%ebx
    5bbf:	8b 40 20             	mov    0x20(%eax),%eax
    5bc2:	eb 4c                	jmp    5c10 <mpt_stm_adapter_online+0x9c0>
    5bc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}

	page = MPI_FC_DEVICE_PAGE0_PGAD_FORM_NEXT_DID + 0xffffff;

	while (1) {
		memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5bc8:	f7 c7 02 00 00 00    	test   $0x2,%edi
    5bce:	75 70                	jne    5c40 <mpt_stm_adapter_online+0x9f0>
    5bd0:	89 d1                	mov    %edx,%ecx
    5bd2:	89 f0                	mov    %esi,%eax
    5bd4:	c1 e9 02             	shr    $0x2,%ecx
    5bd7:	f6 c2 02             	test   $0x2,%dl
    5bda:	f3 ab                	rep stos %eax,%es:(%edi)
    5bdc:	74 09                	je     5be7 <mpt_stm_adapter_online+0x997>
    5bde:	31 c0                	xor    %eax,%eax
    5be0:	83 c7 02             	add    $0x2,%edi
    5be3:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    5be7:	83 e2 01             	and    $0x1,%edx
    5bea:	74 03                	je     5bef <mpt_stm_adapter_online+0x99f>
    5bec:	c6 07 00             	movb   $0x0,(%edi)
		if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_FC_DEVICE,
    5bef:	8b 7d f0             	mov    -0x10(%ebp),%edi
    5bf2:	31 c9                	xor    %ecx,%ecx
    5bf4:	ba 06 00 00 00       	mov    $0x6,%edx
    5bf9:	89 1c 24             	mov    %ebx,(%esp)
    5bfc:	89 f8                	mov    %edi,%eax
    5bfe:	e8 cd bd ff ff       	call   19d0 <stm_get_config_page.constprop.50>
    5c03:	85 c0                	test   %eax,%eax
    5c05:	75 49                	jne    5c50 <mpt_stm_adapter_online+0xa00>
					0, page, sleep)) {
			break;
		}
		FcDevice0 = (FCDevicePage0_t *)priv->hw->config_buf;
    5c07:	8b 47 20             	mov    0x20(%edi),%eax

		wwnn.Low = le32_to_cpu(FcDevice0->WWNN.Low);
		wwnn.High = le32_to_cpu(FcDevice0->WWNN.High);
		wwpn.Low = le32_to_cpu(FcDevice0->WWPN.Low);
		wwpn.High = le32_to_cpu(FcDevice0->WWPN.High);
		port_id = le32_to_cpu(FcDevice0->PortIdentifier);
    5c0a:	8b 98 14 18 02 00    	mov    0x21814(%eax),%ebx
	}

	page = MPI_FC_DEVICE_PAGE0_PGAD_FORM_NEXT_DID + 0xffffff;

	while (1) {
		memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5c10:	8d b8 00 18 02 00    	lea    0x21800(%eax),%edi
    5c16:	ba 00 04 00 00       	mov    $0x400,%edx
    5c1b:	f7 c7 01 00 00 00    	test   $0x1,%edi
    5c21:	74 a5                	je     5bc8 <mpt_stm_adapter_online+0x978>
    5c23:	8d b8 01 18 02 00    	lea    0x21801(%eax),%edi
    5c29:	66 ba ff 03          	mov    $0x3ff,%dx
    5c2d:	f7 c7 02 00 00 00    	test   $0x2,%edi
    5c33:	c6 80 00 18 02 00 00 	movb   $0x0,0x21800(%eax)
    5c3a:	74 94                	je     5bd0 <mpt_stm_adapter_online+0x980>
    5c3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    5c40:	31 c9                	xor    %ecx,%ecx
    5c42:	83 c7 02             	add    $0x2,%edi
    5c45:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    5c49:	83 ea 02             	sub    $0x2,%edx
    5c4c:	eb 82                	jmp    5bd0 <mpt_stm_adapter_online+0x980>
    5c4e:	66 90                	xchg   %ax,%ax

	if (IsFc(priv)) {
		/* wait up to 5 seconds for the link to come up */
		for (i = 0; i < 50; i++) {
			stm_fc_configuration(priv, NO_SLEEP);
			if (priv->port_flags != MPI_FCPORTPAGE0_FLAGS_ATTACH_NO_INIT)
    5c50:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c53:	8b 40 4c             	mov    0x4c(%eax),%eax
    5c56:	85 c0                	test   %eax,%eax
    5c58:	0f 85 39 f7 ff ff    	jne    5397 <mpt_stm_adapter_online+0x147>
    5c5e:	bb 64 00 00 00       	mov    $0x64,%ebx
    5c63:	90                   	nop
    5c64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				break;
			mdelay(100);
    5c68:	b8 58 89 41 00       	mov    $0x418958,%eax
    5c6d:	e8 fc ff ff ff       	call   5c6e <mpt_stm_adapter_online+0xa1e>
    5c72:	83 eb 01             	sub    $0x1,%ebx
    5c75:	75 f1                	jne    5c68 <mpt_stm_adapter_online+0xa18>
	if (IsFc(priv))
		stm_reset_link(priv);

	if (IsFc(priv)) {
		/* wait up to 5 seconds for the link to come up */
		for (i = 0; i < 50; i++) {
    5c77:	83 6d dc 01          	subl   $0x1,-0x24(%ebp)
    5c7b:	0f 84 16 f7 ff ff    	je     5397 <mpt_stm_adapter_online+0x147>
    5c81:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c84:	8b 00                	mov    (%eax),%eax
    5c86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    5c89:	e9 82 fd ff ff       	jmp    5a10 <mpt_stm_adapter_online+0x7c0>
	flags = le32_to_cpu(FcPort0->Flags) &
		MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK;
	current_speed = le32_to_cpu(FcPort0->CurrentSpeed);
	port_state = FcPort0->PortState;

	switch (flags) {
    5c8e:	3d 00 04 00 00       	cmp    $0x400,%eax
		break;
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_PRIVATE_LOOP:
		attach = "private loop";
		break;
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_FABRIC_DIRECT:
		attach = "fabric direct attach";
    5c93:	c7 45 ec 11 02 00 00 	movl   $0x211,-0x14(%ebp)
	flags = le32_to_cpu(FcPort0->Flags) &
		MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK;
	current_speed = le32_to_cpu(FcPort0->CurrentSpeed);
	port_state = FcPort0->PortState;

	switch (flags) {
    5c9a:	0f 84 28 fe ff ff    	je     5ac8 <mpt_stm_adapter_online+0x878>
    5ca0:	3d 00 08 00 00       	cmp    $0x800,%eax
		break;
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_FABRIC_DIRECT:
		attach = "fabric direct attach";
		break;
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_PUBLIC_LOOP:
		attach = "public loop";
    5ca5:	c7 45 ec 26 02 00 00 	movl   $0x226,-0x14(%ebp)
	flags = le32_to_cpu(FcPort0->Flags) &
		MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK;
	current_speed = le32_to_cpu(FcPort0->CurrentSpeed);
	port_state = FcPort0->PortState;

	switch (flags) {
    5cac:	0f 84 16 fe ff ff    	je     5ac8 <mpt_stm_adapter_online+0x878>
		break;
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_PUBLIC_LOOP:
		attach = "public loop";
		break;
	default:
		attach = "unknown";
    5cb2:	c7 45 ec 2a 00 00 00 	movl   $0x2a,-0x14(%ebp)
    5cb9:	e9 0a fe ff ff       	jmp    5ac8 <mpt_stm_adapter_online+0x878>
	wwpn.Low = le32_to_cpu(FcPort0->WWPN.Low);
	wwpn.High = le32_to_cpu(FcPort0->WWPN.High);
	port_id = le32_to_cpu(FcPort0->PortIdentifier);
	protocol = le32_to_cpu(FcPort0->Flags) & MPI_FCPORTPAGE0_FLAGS_PROT_MASK;

	if (priv->wwpn.Low != wwpn.Low ||
    5cbe:	3b 57 38             	cmp    0x38(%edi),%edx
    5cc1:	0f 85 a1 fe ff ff    	jne    5b68 <mpt_stm_adapter_online+0x918>
	    priv->wwpn.High != wwpn.High ||
    5cc7:	3b 5f 3c             	cmp    0x3c(%edi),%ebx
    5cca:	0f 85 98 fe ff ff    	jne    5b68 <mpt_stm_adapter_online+0x918>
    5cd0:	e9 e2 fe ff ff       	jmp    5bb7 <mpt_stm_adapter_online+0x967>
    5cd5:	8d 76 00             	lea    0x0(%esi),%esi
		speed = "unknown";
		break;
	}

	if (priv->port_flags != flags ||
	    priv->port_speed != current_speed ||
    5cd8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5cdb:	8b 52 50             	mov    0x50(%edx),%edx
	default:
		speed = "unknown";
		break;
	}

	if (priv->port_flags != flags ||
    5cde:	39 d7                	cmp    %edx,%edi
    5ce0:	0f 85 04 fe ff ff    	jne    5aea <mpt_stm_adapter_online+0x89a>
	    priv->port_speed != current_speed ||
	    priv->port_state != port_state) {
    5ce6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5ce9:	8b 52 54             	mov    0x54(%edx),%edx
		speed = "unknown";
		break;
	}

	if (priv->port_flags != flags ||
	    priv->port_speed != current_speed ||
    5cec:	39 55 e0             	cmp    %edx,-0x20(%ebp)
    5cef:	0f 85 f5 fd ff ff    	jne    5aea <mpt_stm_adapter_online+0x89a>
    5cf5:	e9 38 fe ff ff       	jmp    5b32 <mpt_stm_adapter_online+0x8e2>
		priv->device_changed = 1;
		if (attach)
			printk(KERN_INFO "%s port is wwn %08x%08x, port id %x\n",
			       ioc->name, wwpn.High, wwpn.Low, port_id);
		else
			printk(KERN_INFO "%s port is wwn %08x%08x\n",
    5cfa:	89 44 24 0c          	mov    %eax,0xc(%esp)
			       ioc->name, wwpn.High, wwpn.Low);
    5cfe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		priv->device_changed = 1;
		if (attach)
			printk(KERN_INFO "%s port is wwn %08x%08x, port id %x\n",
			       ioc->name, wwpn.High, wwpn.Low, port_id);
		else
			printk(KERN_INFO "%s port is wwn %08x%08x\n",
    5d01:	89 54 24 08          	mov    %edx,0x8(%esp)
    5d05:	c7 04 24 48 02 00 00 	movl   $0x248,(%esp)
			       ioc->name, wwpn.High, wwpn.Low);
    5d0c:	83 c0 08             	add    $0x8,%eax
    5d0f:	89 44 24 04          	mov    %eax,0x4(%esp)
		priv->device_changed = 1;
		if (attach)
			printk(KERN_INFO "%s port is wwn %08x%08x, port id %x\n",
			       ioc->name, wwpn.High, wwpn.Low, port_id);
		else
			printk(KERN_INFO "%s port is wwn %08x%08x\n",
    5d13:	e8 fc ff ff ff       	call   5d14 <mpt_stm_adapter_online+0xac4>
    5d18:	e9 9a fe ff ff       	jmp    5bb7 <mpt_stm_adapter_online+0x967>
		priv->device_changed = 1;
		if (attach)
			printk(KERN_INFO "%s link is online, type is %s, speed is %s\n",
			       ioc->name, attach, speed);
		else
			printk(KERN_INFO "%s link is offline\n", ioc->name);
    5d1d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d20:	c7 04 24 32 02 00 00 	movl   $0x232,(%esp)
    5d27:	83 c0 08             	add    $0x8,%eax
    5d2a:	89 44 24 04          	mov    %eax,0x4(%esp)
    5d2e:	e8 fc ff ff ff       	call   5d2f <mpt_stm_adapter_online+0xadf>
    5d33:	8b 83 04 18 02 00    	mov    0x21804(%ebx),%eax
    5d39:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5d3c:	e9 f1 fd ff ff       	jmp    5b32 <mpt_stm_adapter_online+0x8e2>
		break;
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_POINT_TO_POINT:
		attach = "point to point";
		break;
	case MPI_FCPORTPAGE0_FLAGS_ATTACH_PRIVATE_LOOP:
		attach = "private loop";
    5d41:	c7 45 ec 04 02 00 00 	movl   $0x204,-0x14(%ebp)
    5d48:	e9 7b fd ff ff       	jmp    5ac8 <mpt_stm_adapter_online+0x878>
	FCPortPage0_t	*FcPort0;
	FCDevicePage0_t	*FcDevice0;
	int			page;

	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5d4d:	31 c0                	xor    %eax,%eax
    5d4f:	83 c7 02             	add    $0x2,%edi
    5d52:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    5d56:	83 ea 02             	sub    $0x2,%edx
    5d59:	e9 db fc ff ff       	jmp    5a39 <mpt_stm_adapter_online+0x7e9>
    5d5e:	c6 80 00 18 02 00 00 	movb   $0x0,0x21800(%eax)
    5d65:	8d b8 01 18 02 00    	lea    0x21801(%eax),%edi
    5d6b:	66 ba ff 03          	mov    $0x3ff,%dx
    5d6f:	e9 b9 fc ff ff       	jmp    5a2d <mpt_stm_adapter_online+0x7dd>
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_fc_enable_els(MPT_STM_PRIV *priv, int els, int sleep)
{
	FCPortPage8_t	*FcPort8;
	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5d74:	c6 80 00 18 02 00 00 	movb   $0x0,0x21800(%eax)
    5d7b:	8d b8 01 18 02 00    	lea    0x21801(%eax),%edi
    5d81:	66 ba ff 03          	mov    $0x3ff,%dx
    5d85:	e9 54 f6 ff ff       	jmp    53de <mpt_stm_adapter_online+0x18e>
    5d8a:	e8 11 00 00 00       	call   5da0 <mpt_stm_adapter_online+0xb50>
    5d8f:	89 55 d0             	mov    %edx,-0x30(%ebp)
		sync = ScsiPort2->DeviceSettings[i].SyncFactor;
		if (ioc->facts.FWVersion.Word >= 0x01032900) {
			/* these firmware versions don't send the correct
			 * amount of data except at the slowest transfer
			 * factors */
			sync = max(0x32, sync);
    5d92:	83 f9 32             	cmp    $0x32,%ecx
    5d95:	ba 32 00 00 00       	mov    $0x32,%edx
    5d9a:	0f 4c ca             	cmovl  %edx,%ecx
			printk(KERN_ERR "forcing FAST-5 negotiation due to broken fw 0x%08X\n",
    5d9d:	89 44 24 04          	mov    %eax,0x4(%esp)
    5da1:	c7 04 24 c4 0d 00 00 	movl   $0xdc4,(%esp)
		sync = ScsiPort2->DeviceSettings[i].SyncFactor;
		if (ioc->facts.FWVersion.Word >= 0x01032900) {
			/* these firmware versions don't send the correct
			 * amount of data except at the slowest transfer
			 * factors */
			sync = max(0x32, sync);
    5da8:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
			printk(KERN_ERR "forcing FAST-5 negotiation due to broken fw 0x%08X\n",
    5dab:	e8 fc ff ff ff       	call   5dac <mpt_stm_adapter_online+0xb5c>
    5db0:	8b 55 d0             	mov    -0x30(%ebp),%edx
    5db3:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    5db6:	e9 5b fb ff ff       	jmp    5916 <mpt_stm_adapter_online+0x6c6>

	wcap = cap & ~MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK;
	ncap = wcap & ~MPI_SCSIPORTPAGE0_CAP_WIDE;

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	memset(priv->SCSIDevicePage1, 0, sizeof(SCSIDevicePage1_t) * NUM_SCSI_DEVICES);
    5dbb:	31 c0                	xor    %eax,%eax
    5dbd:	83 c7 02             	add    $0x2,%edi
    5dc0:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    5dc4:	83 ea 02             	sub    $0x2,%edx
    5dc7:	e9 e8 fa ff ff       	jmp    58b4 <mpt_stm_adapter_online+0x664>
    5dcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5dcf:	66 ba ff 00          	mov    $0xff,%dx
    5dd3:	c6 80 0c 0b 00 00 00 	movb   $0x0,0xb0c(%eax)
    5dda:	8d b8 0d 0b 00 00    	lea    0xb0d(%eax),%edi
    5de0:	e9 c3 fa ff ff       	jmp    58a8 <mpt_stm_adapter_online+0x658>
	stm_set_scsi_port_page1(priv, sleep);

	wcap = cap & ~MPI_SCSIPORTPAGE0_CAP_MIN_SYNC_PERIOD_MASK;
	ncap = wcap & ~MPI_SCSIPORTPAGE0_CAP_WIDE;

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5de5:	31 c0                	xor    %eax,%eax
    5de7:	83 c7 02             	add    $0x2,%edi
    5dea:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    5dee:	83 ea 02             	sub    $0x2,%edx
    5df1:	e9 79 fa ff ff       	jmp    586f <mpt_stm_adapter_online+0x61f>
    5df6:	c6 80 00 18 02 00 00 	movb   $0x0,0x21800(%eax)
    5dfd:	8d b8 01 18 02 00    	lea    0x21801(%eax),%edi
    5e03:	66 ba ff 03          	mov    $0x3ff,%dx
    5e07:	e9 57 fa ff ff       	jmp    5863 <mpt_stm_adapter_online+0x613>
	int i;
	int id = priv->port_id;

	TRACE_ENTRY();

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5e0c:	31 c0                	xor    %eax,%eax
    5e0e:	83 c7 02             	add    $0x2,%edi
    5e11:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    5e15:	83 ea 02             	sub    $0x2,%edx
    5e18:	e9 29 f9 ff ff       	jmp    5746 <mpt_stm_adapter_online+0x4f6>
    5e1d:	c6 80 00 18 02 00 00 	movb   $0x0,0x21800(%eax)
    5e24:	8d b8 01 18 02 00    	lea    0x21801(%eax),%edi
    5e2a:	66 ba ff 03          	mov    $0x3ff,%dx
    5e2e:	e9 07 f9 ff ff       	jmp    573a <mpt_stm_adapter_online+0x4ea>
	ScsiPort2 = &priv->SCSIPortPage2;
	memcpy(&priv->SCSIPortPage2, priv->hw->config_buf, sizeof(SCSIPortPage2_t));

	TRACE_DBG("%s scsi id is %d", ioc->name, priv->port_id);

	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5e33:	31 c9                	xor    %ecx,%ecx
    5e35:	83 c7 02             	add    $0x2,%edi
    5e38:	66 89 4f fe          	mov    %cx,-0x2(%edi)
    5e3c:	83 ea 02             	sub    $0x2,%edx
    5e3f:	e9 6c f8 ff ff       	jmp    56b0 <mpt_stm_adapter_online+0x460>
    5e44:	c6 80 00 18 02 00 00 	movb   $0x0,0x21800(%eax)
    5e4b:	8d b8 01 18 02 00    	lea    0x21801(%eax),%edi
    5e51:	66 ba ff 03          	mov    $0x3ff,%dx
    5e55:	e9 4a f8 ff ff       	jmp    56a4 <mpt_stm_adapter_online+0x454>
	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
	if (stm_get_config_page(priv, MPI_CONFIG_PAGETYPE_SCSI_PORT, 2, 0, sleep))
		return -1;
	ScsiPort2 = &priv->SCSIPortPage2;
	memcpy(&priv->SCSIPortPage2, priv->hw->config_buf, sizeof(SCSIPortPage2_t));
    5e5a:	0f b7 16             	movzwl (%esi),%edx
    5e5d:	83 c7 02             	add    $0x2,%edi
    5e60:	83 c6 02             	add    $0x2,%esi
    5e63:	83 e8 02             	sub    $0x2,%eax
    5e66:	66 89 57 fe          	mov    %dx,-0x2(%edi)
    5e6a:	e9 f5 f7 ff ff       	jmp    5664 <mpt_stm_adapter_online+0x414>
    5e6f:	8b 75 f0             	mov    -0x10(%ebp),%esi
    5e72:	0f b6 82 00 18 02 00 	movzbl 0x21800(%edx),%eax
    5e79:	8d be c1 0a 00 00    	lea    0xac1(%esi),%edi
    5e7f:	88 86 c0 0a 00 00    	mov    %al,0xac0(%esi)
    5e85:	8d b2 01 18 02 00    	lea    0x21801(%edx),%esi
    5e8b:	b8 4b 00 00 00       	mov    $0x4b,%eax
    5e90:	e9 c3 f7 ff ff       	jmp    5658 <mpt_stm_adapter_online+0x408>
	int			sync;
	int			flags;
	int			i;

	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5e95:	31 c0                	xor    %eax,%eax
    5e97:	83 c7 02             	add    $0x2,%edi
    5e9a:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    5e9e:	83 ea 02             	sub    $0x2,%edx
    5ea1:	e9 4a f7 ff ff       	jmp    55f0 <mpt_stm_adapter_online+0x3a0>
    5ea6:	c6 80 00 18 02 00 00 	movb   $0x0,0x21800(%eax)
    5ead:	8d b8 01 18 02 00    	lea    0x21801(%eax),%edi
    5eb3:	66 ba ff 03          	mov    $0x3ff,%dx
    5eb7:	e9 28 f7 ff ff       	jmp    55e4 <mpt_stm_adapter_online+0x394>
	int					i;
	dma_addr_t				dma_addr;

	TRACE_ENTRY();
	req = (TargetCmdBufferPostBaseRequest_t *)mpt_msg_frame_alloc(ioc, -1);
	memset(req, 0, sizeof(*req));
    5ebc:	31 ff                	xor    %edi,%edi
    5ebe:	83 c2 02             	add    $0x2,%edx
    5ec1:	66 89 7a fe          	mov    %di,-0x2(%edx)
    5ec5:	83 e9 02             	sub    $0x2,%ecx
    5ec8:	e9 4f f6 ff ff       	jmp    551c <mpt_stm_adapter_online+0x2cc>
    5ecd:	c6 00 00             	movb   $0x0,(%eax)
    5ed0:	8d 50 01             	lea    0x1(%eax),%edx
    5ed3:	b1 1b                	mov    $0x1b,%cl
    5ed5:	e9 39 f6 ff ff       	jmp    5513 <mpt_stm_adapter_online+0x2c3>
static int stm_fc_enable_aliases(MPT_STM_PRIV *priv, int num_aliases, int sleep)
{
	FCPortPage1_t	*FcPort1;

	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5eda:	31 c0                	xor    %eax,%eax
    5edc:	83 c7 02             	add    $0x2,%edi
    5edf:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    5ee3:	83 ea 02             	sub    $0x2,%edx
    5ee6:	e9 8c f5 ff ff       	jmp    5477 <mpt_stm_adapter_online+0x227>
    5eeb:	c6 80 00 18 02 00 00 	movb   $0x0,0x21800(%eax)
    5ef2:	8d b8 01 18 02 00    	lea    0x21801(%eax),%edi
    5ef8:	66 ba ff 03          	mov    $0x3ff,%dx
    5efc:	e9 6a f5 ff ff       	jmp    546b <mpt_stm_adapter_online+0x21b>
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_fc_enable_els(MPT_STM_PRIV *priv, int els, int sleep)
{
	FCPortPage8_t	*FcPort8;
	TRACE_ENTRY();
	memset(priv->hw->config_buf, 0, sizeof(priv->hw->config_buf));
    5f01:	31 c0                	xor    %eax,%eax
    5f03:	83 c7 02             	add    $0x2,%edi
    5f06:	66 89 47 fe          	mov    %ax,-0x2(%edi)
    5f0a:	83 ea 02             	sub    $0x2,%edx
    5f0d:	e9 d8 f4 ff ff       	jmp    53ea <mpt_stm_adapter_online+0x19a>
    5f12:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    5f19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00005f20 <mpt_enable_tgt>:

	return ret;
}

static int mpt_enable_tgt(struct scst_tgt *scst_tgt, bool enable)
{
    5f20:	55                   	push   %ebp
    5f21:	89 e5                	mov    %esp,%ebp
    5f23:	53                   	push   %ebx
    5f24:	e8 fc ff ff ff       	call   5f25 <mpt_enable_tgt+0x5>
	TRACE_EXIT_RES(ret);

	return ret;
}

static int mpt_enable_tgt(struct scst_tgt *scst_tgt, bool enable)
    5f29:	8b 58 34             	mov    0x34(%eax),%ebx

	MPT_ADAPTER *ioc;

	TRACE_ENTRY();

	if (tgt == NULL)
    5f2c:	85 db                	test   %ebx,%ebx
    5f2e:	74 26                	je     5f56 <mpt_enable_tgt+0x36>
		goto out;

	ioc = tgt->priv->ioc;
    5f30:	8b 43 04             	mov    0x4(%ebx),%eax

	if (enable)
		TRACE_DBG("Enable Target, %d, %d", ioc->id, tgt->target_enable);
		if (tgt->target_enable != 1) {
    5f33:	83 bb 24 04 00 00 01 	cmpl   $0x1,0x424(%ebx)
	TRACE_ENTRY();

	if (tgt == NULL)
		goto out;

	ioc = tgt->priv->ioc;
    5f3a:	8b 00                	mov    (%eax),%eax

	if (enable)
		TRACE_DBG("Enable Target, %d, %d", ioc->id, tgt->target_enable);
		if (tgt->target_enable != 1) {
    5f3c:	74 0e                	je     5f4c <mpt_enable_tgt+0x2c>
			mpt_stm_adapter_online(mpt_stm_priv[ioc->id]);
    5f3e:	8b 00                	mov    (%eax),%eax
    5f40:	8b 04 85 20 00 00 00 	mov    0x20(,%eax,4),%eax
    5f47:	e8 04 f3 ff ff       	call   5250 <mpt_stm_adapter_online>
		}
	else
		TRACE_DBG("Disable Target %d, %d", ioc->id, tgt->target_enable);
		if (tgt->target_enable != 0) {
			/* FIXME */
			tgt->target_enable = 0;
    5f4c:	c7 83 24 04 00 00 00 	movl   $0x0,0x424(%ebx)
    5f53:	00 00 00 
		}

out:
	return res;
}
    5f56:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    5f5b:	5b                   	pop    %ebx
    5f5c:	5d                   	pop    %ebp
    5f5d:	c3                   	ret    
    5f5e:	66 90                	xchg   %ax,%ax

00005f60 <stm_reset_process>:
	return 1;
}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
static int stm_reset_process(MPT_ADAPTER *ioc, int phase)
{
    5f60:	55                   	push   %ebp
    5f61:	89 e5                	mov    %esp,%ebp
    5f63:	53                   	push   %ebx
    5f64:	83 ec 08             	sub    $0x8,%esp
    5f67:	e8 fc ff ff ff       	call   5f68 <stm_reset_process+0x8>
	MPT_STM_PRIV	*priv = mpt_stm_priv[ioc->id];
    5f6c:	8b 08                	mov    (%eax),%ecx
    5f6e:	8b 1c 8d 20 00 00 00 	mov    0x20(,%ecx,4),%ebx
	int			i;

	TRACE_ENTRY();
	if (priv == NULL)
    5f75:	85 db                	test   %ebx,%ebx
    5f77:	74 09                	je     5f82 <stm_reset_process+0x22>
		return 1;

	if (phase == MPT_IOC_PRE_RESET) {
    5f79:	85 d2                	test   %edx,%edx
    5f7b:	74 10                	je     5f8d <stm_reset_process+0x2d>
		priv->config_pending = 0;
		for (i = 0; i < priv->num_cmd_buffers; i++)
			priv->io_state[i] = 0;
	}

	if (phase == MPT_IOC_POST_RESET) {
    5f7d:	83 fa 01             	cmp    $0x1,%edx
    5f80:	74 49                	je     5fcb <stm_reset_process+0x6b>
	}

	TRACE_EXIT();

	return 1;
}
    5f82:	83 c4 08             	add    $0x8,%esp
    5f85:	b8 01 00 00 00       	mov    $0x1,%eax
    5f8a:	5b                   	pop    %ebx
    5f8b:	5d                   	pop    %ebp
    5f8c:	c3                   	ret    
	if (priv == NULL)
		return 1;

	if (phase == MPT_IOC_PRE_RESET) {
		printk(KERN_ERR MYNAM ":%s IOC will be reset\n",
		       ioc->name);
    5f8d:	83 c0 08             	add    $0x8,%eax
    5f90:	89 44 24 04          	mov    %eax,0x4(%esp)
	TRACE_ENTRY();
	if (priv == NULL)
		return 1;

	if (phase == MPT_IOC_PRE_RESET) {
		printk(KERN_ERR MYNAM ":%s IOC will be reset\n",
    5f94:	c7 04 24 54 0e 00 00 	movl   $0xe54,(%esp)
    5f9b:	e8 fc ff ff ff       	call   5f9c <stm_reset_process+0x3c>
		       ioc->name);
		priv->in_reset = 1;
		priv->config_pending = 0;
		for (i = 0; i < priv->num_cmd_buffers; i++)
    5fa0:	8b 4b 14             	mov    0x14(%ebx),%ecx
		return 1;

	if (phase == MPT_IOC_PRE_RESET) {
		printk(KERN_ERR MYNAM ":%s IOC will be reset\n",
		       ioc->name);
		priv->in_reset = 1;
    5fa3:	c7 43 78 01 00 00 00 	movl   $0x1,0x78(%ebx)
		priv->config_pending = 0;
    5faa:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
		for (i = 0; i < priv->num_cmd_buffers; i++)
    5fb1:	85 c9                	test   %ecx,%ecx
    5fb3:	7e cd                	jle    5f82 <stm_reset_process+0x22>
    5fb5:	31 c0                	xor    %eax,%eax
    5fb7:	90                   	nop
			priv->io_state[i] = 0;
    5fb8:	8d 50 28             	lea    0x28(%eax),%edx
	if (phase == MPT_IOC_PRE_RESET) {
		printk(KERN_ERR MYNAM ":%s IOC will be reset\n",
		       ioc->name);
		priv->in_reset = 1;
		priv->config_pending = 0;
		for (i = 0; i < priv->num_cmd_buffers; i++)
    5fbb:	83 c0 01             	add    $0x1,%eax
    5fbe:	39 c8                	cmp    %ecx,%eax
			priv->io_state[i] = 0;
    5fc0:	c7 04 93 00 00 00 00 	movl   $0x0,(%ebx,%edx,4)
	if (phase == MPT_IOC_PRE_RESET) {
		printk(KERN_ERR MYNAM ":%s IOC will be reset\n",
		       ioc->name);
		priv->in_reset = 1;
		priv->config_pending = 0;
		for (i = 0; i < priv->num_cmd_buffers; i++)
    5fc7:	75 ef                	jne    5fb8 <stm_reset_process+0x58>
    5fc9:	eb b7                	jmp    5f82 <stm_reset_process+0x22>
			priv->io_state[i] = 0;
	}

	if (phase == MPT_IOC_POST_RESET) {
		printk(KERN_ERR MYNAM ":%s IOC has been reset, restarting now\n",
		       ioc->name);
    5fcb:	83 c0 08             	add    $0x8,%eax
    5fce:	89 44 24 04          	mov    %eax,0x4(%esp)
		for (i = 0; i < priv->num_cmd_buffers; i++)
			priv->io_state[i] = 0;
	}

	if (phase == MPT_IOC_POST_RESET) {
		printk(KERN_ERR MYNAM ":%s IOC has been reset, restarting now\n",
    5fd2:	c7 04 24 78 0e 00 00 	movl   $0xe78,(%esp)
    5fd9:	e8 fc ff ff ff       	call   5fda <stm_reset_process+0x7a>
		       ioc->name);
		mpt_stm_adapter_online(priv);
    5fde:	89 d8                	mov    %ebx,%eax
    5fe0:	e8 6b f2 ff ff       	call   5250 <mpt_stm_adapter_online>
    5fe5:	eb 9b                	jmp    5f82 <stm_reset_process+0x22>

Disassembly of section .text.unlikely:

00000000 <compound_head_by_tail>:
#endif
}

static inline struct page *compound_head_by_tail(struct page *tail)
{
	struct page *head = tail->first_page;
   0:	8b 50 1c             	mov    0x1c(%eax),%edx
	/*
	 * page->first_page may be a dangling pointer to an old
	 * compound page, so recheck that it is still a tail
	 * page before returning.
	 */
	smp_rmb();
   3:	f0 83 04 24 00       	lock addl $0x0,(%esp)
   8:	8b 08                	mov    (%eax),%ecx
	if (likely(PageTail(tail)))
		return head;
   a:	80 e5 80             	and    $0x80,%ch
   d:	0f 44 d0             	cmove  %eax,%edx
	return tail;
}
  10:	89 d0                	mov    %edx,%eax
  12:	c3                   	ret    

00000013 <dma_sync_sg_for_cpu.part.32>:
dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
		    int nelems, enum dma_data_direction dir)
{
	struct dma_map_ops *ops = get_dma_ops(dev);

	BUG_ON(!valid_dma_direction(dir));
  13:	0f 0b                	ud2    

00000015 <mpt_msg_frame_alloc.part.33>:
		mpt_free_msg_frame(_HANDLE_IOC_ID, priv->current_mf[index]);
		priv->current_mf[index] = NULL;
	}
}

static inline MPT_FRAME_HDR *mpt_msg_frame_alloc(MPT_ADAPTER *ioc, int index)
  15:	83 ec 10             	sub    $0x10,%esp
		WARN_ON(priv->current_mf[index] != NULL);
	}

	mf = mpt_get_msg_frame(stm_context, _IOC_ID);

	sBUG_ON(mf == NULL);
  18:	c7 44 24 0c a8 00 00 	movl   $0xa8,0xc(%esp)
  1f:	00 
  20:	c7 44 24 08 52 01 00 	movl   $0x152,0x8(%esp)
  27:	00 
  28:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  2f:	00 
  30:	c7 04 24 b3 00 00 00 	movl   $0xb3,(%esp)
  37:	e8 fc ff ff ff       	call   38 <mpt_msg_frame_alloc.part.33+0x23>
  3c:	ff 15 0c 00 00 00    	call   *0xc
  42:	64 a1 00 00 00 00    	mov    %fs:0x0,%eax
  48:	f6 c4 ff             	test   $0xff,%ah
  4b:	74 11                	je     5e <mpt_msg_frame_alloc.part.33+0x49>
  4d:	ba 00 02 00 00       	mov    $0x200,%edx
  52:	b8 4d 00 00 00       	mov    $0x4d,%eax
  57:	e8 fc ff ff ff       	call   58 <mpt_msg_frame_alloc.part.33+0x43>
  5c:	eb e4                	jmp    42 <mpt_msg_frame_alloc.part.33+0x2d>
  5e:	0f 0b                	ud2    

00000060 <scst_rx_mgmt_fn_lun.part.37>:
static inline int scst_rx_mgmt_fn_lun(struct scst_session *sess, int fn,
	const void *lun, int lun_len, int atomic, void *tgt_priv)
{
	struct scst_rx_mgmt_params params;

	BUG_ON(fn == SCST_ABORT_TASK);
  60:	0f 0b                	ud2    

Disassembly of section .altinstr_replacement:

00000000 <.altinstr_replacement>:
   0:	0f ae e8             	lfence 

Disassembly of section .init.text:

00000000 <init_module>:
 */
int __scst_register_target_template(struct scst_tgt_template *vtt,
	const char *version);
static inline int scst_register_target_template(struct scst_tgt_template *vtt)
{
	return __scst_register_target_template(vtt, SCST_INTERFACE_VERSION);
   0:	ba ac 0e 00 00       	mov    $0xeac,%edx
   5:	b8 20 00 00 00       	mov    $0x20,%eax
   a:	e8 fc ff ff ff       	call   b <init_module+0xb>
   f:	31 d2                	xor    %edx,%edx
  11:	85 c0                	test   %eax,%eax
  13:	0f 4e d0             	cmovle %eax,%edx
	return res;

out_unreg_target:
	scst_unregister_target_template(&tgt_template);
	goto out;
}
  16:	89 d0                	mov    %edx,%eax
  18:	c3                   	ret    

Disassembly of section .exit.text:

00000000 <cleanup_module>:
static void __exit mpt_target_exit(void)
{
	TRACE_ENTRY();

	mpt_proc_log_entry_clean(&tgt_template);
	scst_unregister_target_template(&tgt_template);
   0:	b8 20 00 00 00       	mov    $0x20,%eax
   5:	e8 fc ff ff ff       	call   6 <cleanup_module+0x6>
}

static void _mpt_stm_exit(void)
{
	TRACE_ENTRY();
	if (stm_context > 0) {
   a:	a1 14 00 00 00       	mov    0x14,%eax
   f:	85 c0                	test   %eax,%eax
  11:	7e 34                	jle    47 <cleanup_module+0x47>
		mpt_reset_deregister(stm_context);
  13:	0f b6 c0             	movzbl %al,%eax
  16:	e8 fc ff ff ff       	call   17 <cleanup_module+0x17>
		mpt_event_deregister(stm_context);
  1b:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
  22:	e8 fc ff ff ff       	call   23 <cleanup_module+0x23>

		mpt_device_driver_deregister(MPTSTM_DRIVER);
  27:	b8 06 00 00 00       	mov    $0x6,%eax
  2c:	e8 fc ff ff ff       	call   2d <cleanup_module+0x2d>

		mpt_deregister(stm_context);
  31:	0f b6 05 14 00 00 00 	movzbl 0x14,%eax
  38:	e8 fc ff ff ff       	call   39 <cleanup_module+0x39>
		stm_context = 0;
  3d:	c7 05 14 00 00 00 00 	movl   $0x0,0x14
  44:	00 00 00 
  47:	c3                   	ret    
